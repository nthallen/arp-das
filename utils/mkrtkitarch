#! /usr/bin/perl -w
use strict;
use File::Path;
use File::Copy;
use Cwd;

# mkrtkitarch <destdir> <pkg> [<pkg> ...]
#
# Package definitions are found under /var/huarp/pkg/<pkg>-<ver>/
# Each directory must include a Header file with at least the
# following information
#  ^Requires:(?:\s+(\w+)(?:-(\d+(?:\.\d+)*))?)*$
# A full package implementation would allow dependency on
# specific version ranges. I will probably opt for taking the
# latest version in most cases, particularly at this point
# where were making initial installs.
#
# Later, as new packages are created or old packages are updated,
# I will want a package install utility that would need to look
# at the dependencies and decide whether other packages need
# to be updated.
#
# Optional Header contents:
#  ^SrcRoot: <path>
#    Directory to cd to before creating archive

my $pkgroot = "/var/huarp/pkg";
my $pkgcache = "/var/cache/huarp/pkg";

-d $pkgroot || mkpath($pkgroot) || die "Fatal: Unable to create pkgroot $pkgroot\n";
-d $pkgroot || die "Fatal: Misunderstood mkpath return\n";

-d $pkgcache || mkpath($pkgcache) || die "Fatal: Unable to create pkgcache $pkgcache\n";
-d $pkgcache || die "Fatal: Misunderstood mkpath return\n";

die "Insufficient arguments\n" unless @ARGV >= 2;
my $pkgdest = shift @ARGV;
my @reqlist;
my @pkglist;
while ( @ARGV ) {
  my $pkg = pop(@ARGV);
  push( @reqlist, pkg_check($pkg, 'Command Line') );
}

while (@reqlist) {
  my $pkg = pop(@reqlist);
  my @opts = sort vercmp map s|^.*/|| && pkg_check($_, "Package directory: $pkgroot"),
    <$pkgroot/$pkg->{root}-*>;
  # These are sorted in ascending order, so the last element is the one we want
  die "Unable to locate package $pkg->{root} required by $pkg->{src}\n"
    unless @opts;
  my $inst = pop(@opts);
  die "Latest version of package $pkg->{root} is older than version required by $pkg->{src}\n"
    unless vercmp( $pkg, $inst ) >= 0;
  push( @pkglist, $inst );
  $inst->{name} = "$inst->{root}-" . join( '.', @{$inst->{ver}});
  $inst->{SrcRoot} = "/";
  pkg_read_header( $inst );
  -d $inst->{SrcRoot} || die "SrcRoot for package $inst->{name} does not exist\n";
  if ( ! -f "$pkgcache/$inst->{name}" ) {
    ### Create the archive
    my $cwd = getcwd();
    cwd($inst->{SrcRoot});
    print "Creating archive $inst->{name}.tar.gz\n";
    system( "tar -czf $pkgcache/$inst->{name}.tar.gz --owner=0 --group=0 --transform=s,^x86/,," .
            "-T $pkgroot/$inst->{name}/MANIFEST" ) &&
      die "tar failed creating archive for $inst->{name}\n";
    cwd($cwd);
  }
}

# Now go through @pkglist and copy the archives into the repository directory
for my $pkg ( @pkglist ) {
  print "Copying archive $pkg->{name}.tar.gz into repository\n";
  copy( $pkgcache/$pkg->{name}.tar.gz, "repository/$pkg->{name}.tar.gz" );
}

sub pkg_check {
  my ( $pkg, $src ) = @_;
  if ( $pkg =~ m/^(\w+)(?:-(\d+(?:\.\d+)*))?$ ) {
    my $root = $1;
    my @ver;
    @ver = split( /\./, $2 ) if $2;
    return { root => $root, ver => \@ver, src => $src };
  } else {
    die "Invalid package reference: '$pkg' from $src\n";
  }
}

sub vercmp {
  my $i = 0;
  my $va = $a->{ver};
  my $vb = $b->{ver};
  for ( my $i = 0; ; ++$i ) {
    if ( $i >= @$va ) {
      if ( $i >= @$vb ) {
        return 0;
      } else {
        return -1;
      }
    }
    my $rv = $va->[$i] <=> $vb->[$i];
    return $rv if $rv;
  }
}

sub pkg_read_header {
  # Now read the header
  #  ^Requires: Add packages to reqlist in reverse order
  #  ^SrcRoot: 
  my $pkg = shift;
  open HDR, "<$pkgroot/$pkg->{name}/Header" ||
    die "Unable to read Header for package $pkg->{name} required by $pkg->{src}\n";
  while ( my $line = <HDR> ) {
    chomp $line;
    next if $line =~ m/^\s*(?:#.*)?$/;
    if ( $line =~ m/^\s*Requires:((?:\s+[-\w.]+)*)$/ ) {
      for my $rpkg ( reverse split ' ', $1 ) {
        push( @reqlist, pkg_check( $rpkg, $pkg->{name} );
      }
    } elsif ( $line =~ m|\s*SrcRoot| ) {
      if ( $line =~ m|^\s*SrcRoot:\s+(/[\w/]*)\s*$| ) {
        $pkg->{SrcRoot} = $1;
      } else {
        die "Syntax error in 'SrcRoot' line of $pkg->{name}/Header\n";
      }
    } else {
      die "Syntax error in $pkg->{name}/Header\n";
    }
  }
}
