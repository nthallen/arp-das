todo {
  code generation {
	tmcalgo code generation 1.2 when waiting at the end of a state,
	still should call tma_time_check() (see 1.2 below under code)
  }
  runtime { done
	tma.c needs to deal gracefully with the case nexttime==0
  }
}
Support Routines {
  void tma_new_state(int partition, const char *name);
  void tma_new_time(int partition, long int t1, const char *next_cmd);
	specify the next significant time for a partition
  int tma_time_check(int partition);
	Check to see if a significant time is up
  void tma_sendcmd(const char *cmd);
  { Display Command at debug(2)
	Send Command if that option is specified
  }
  void tma_init_options(const char *hdr, int argc, char **argv);
  { calls Con_init_options() and
	cic_options()
  }
  For each partition {
	Keep track of (Current state name), base time, next time
	Console number, Console Row
  }
  #define OPT_TMA_INIT "r:pm"
}
Documentation {
  "Holding" options can stop the clock, but cannot stop conditions
  which are in place. If you want to stop conditions, you must
  support a holding state, or explicitly support holding in your
  conditions.
  
  Startup procedure:
	tma_init_options
	Initialize_States_from_NVRAM
	Initialize_Other_Stuff
  "Telemetry Start" cannot be in a non-volatile state, since it
  must be issued no matter what the startup procedure.
}
Options {
  >msg_init_options("TMA", argc, argv); OPT_MSG_INIT msg.txt
  >DC_init_options(argc, argv); OPT_DC_INIT dc.txt
  Con_init_options(argc, argv); OPT_CON_INIT nl_cons.txt
  cic_options(argc, argv, "TMA"); OPT_CIC_INIT client.txt
  tma_init_options(MSG_HEADER, argc, argv); OPT_TMA_INIT tma.txt
  
  nl_cons.h is included always, so OPT_CON_INIT is defined
  We must define CONSOLE_INIT, since it is only defined when
  N_CONSOLES is defined. Of course nothing precludes an
  algorithm from also being a display program... I suggest
  we define CONSOLE_INIT to call tma_init_options() and have
  tma_init_options call Con_init_options and cic_options.
  We will have to define OPT_CONSOLE_INIT to be:

  #ifndef MSG_LABEL
	#define MSG_LABEL "TMA"
  #endif
  #define OPT_CONSOLE_INIT OPT_CON_INIT OPT_CIC_INIT OPT_TMA_INIT
  #define CONSOLE_INIT tma_init_options(MSG_LABEL, nparts, argc, argv)
  
  Display Options:
	Display a Partition on Device d at Line l
	-A,-a <console> Define (first,next) console
	-r <row> Display next partition at this row of current console
	-r -1 Don't display next partition
	Display on a terminal?
  Playback Option:
	-p Playback or simulation: don't send commands to server
	Don't send commands to a command server {
	  Probably used in conjunction with debug options
	}
  NVRAM Option:
	-m Don't use NVRAM, even if present
	Do or Don't support use of NVRAM (Playback option
	should probably disable NVRAM.) As a rule, probably
	support it if it exists, else don't.
	This option probably belongs in DC_init_options
	(and maybe DG_init_options as well) since it affects
	states in general, not just algorithms.
  CIC Option:
	-C
	Specify node on which to locate command interpreter
  MSG Options:
  Debug levels:
    1. Message State Transitions
	2. Message Commands Begin Sent (This is a debug option,
	since commands will be logged by the server)
}
Code generation {
  for each partition:
	Output top-level state declaration
  for each partition:
	for each state:
	  Output low-level state declaration
	  Output TMC commands for T=-1
	  for each command:
		process
  Substates {
	i = -1, 0, ... , N
	t(i) = time associated with i'th substate.
		   t(-1)=-1, t(0)=0, t(N+1)=0
	T(i) = TMC commands listed at time t(i) (no commands listed at t(N+1))
	C(i) = Interpreter commands listed at time t(i)
	
	for each T in T(-1)
	  depending on (State) { T }
	
	depending on (State once) {
	  tma_new_state(partition, "State"); /* sets starting time, name */
	  validate State_0_;
	}

	for i = 0, ..., N
	  depending on (State_i_ once) {
		C(i)
		tma_new_time(partition, t(i+1), text);
	  }
	for i = 0, ..., N-1
	  for each T in T(i)
		depending on (State_i_ once) { T }
	  depending on (State_i_, 1 Hz) {
		if (tma_check_time(partition))
		  validate State_i+1_;
	  }
	if (i == N)  1.2
	  for each T in T(i)
		depending on (State_i_) { T }
	  depending on (State_i_, 1 Hz) {
		tma_check_time(partition);
	  }
  }
}
Parsing {
  For prettiness: swallow leading whitespace intelligently
  when reading tmc statements. Replace appropriate indentation
  during output.
}
