#! /usr/bin/perl -w
use strict;

#ifdef __USAGE
#   osupdate [-n]
#     update the current node against the reference node
#   osupdate [-n] nodename
#     update the specified node against the reference node
#
#     -n Do nothing, just report what would be done
#endif

# Look through /var/huarp/pkg to see what packages are installed,
# sorting by package and version.
# Look through /net/$ref/var/huarp/pkgcache to see what packages
# are available, sorting by package and version

# For each installed package, check to see if a newer version
# is available. If so, remove all the old versions and install
# the new version.
# When installing, check to make sure all dependent packages
# are also installed.

if ( $> != 0 ) {
  exec 'sudo', $0, @ARGV;
  die "exec sudo failed\n";
}

my $node;
my $npath = '';
my $doit = 1;
if ( @ARGV && $ARGV[0] eq '-n') {
  $doit = 0;
  shift @ARGV;
}
if ( @ARGV ) {
  $node = shift @ARGV;
  $npath = "/net/$node";
}

my $refnode = 'nortvm650';
my $cache = "/net/$refnode/var/huarp/pkgcache";
my $refpkg = "/net/$refnode/var/huarp/pkg";

my @pkgs;
my %pkg; # the currently installed packages
my $pkgdir = "$npath/var/huarp/pkg";
chdir $pkgdir || die "Cannot chdir $pkgdir\n";
for my $pkg ( <*> ) {
  my $pp = pkg_check($pkg, $pkgdir);
  if ( ! defined $pkg{$pp->{root}} ) {
    $pkg{$pp->{root}} = [];
    push @pkgs, $pp->{root};
  }
  push @{$pkg{$pp->{root}}}, $pp;
}
for my $pkg ( sort @pkgs ) {
  $pkg{$pkg} = [ sort { ver_comp($b,$a); } @{$pkg{$pkg}} ];
}

# Now check for available packages
my @avpkgs;
my %avpkg; # the available packages
chdir $cache ||
  die "Cannot chdir $cache\n";
for my $pkg ( <*> ) {
  $pkg =~ s/\.tar\.gz$//;
  my $pp = pkg_check($pkg, $cache);
  if ( ! defined $avpkg{$pp->{root}} ) {
    $avpkg{$pp->{root}} = [];
    push @avpkgs, $pp->{root};
  }
  push @{$avpkg{$pp->{root}}}, $pp;
}
for my $pkg ( sort @avpkgs ) {
  $avpkg{$pkg} = [ sort { ver_comp($b,$a); } @{$avpkg{$pkg}} ];
}


my @plan; # array of arrayrefs with e.g. [ 'uninstall' $pp ]

# Now for each installed package, check to see if there is
# a newer available package.
for my $pkg ( sort @pkgs ) {
  if ( ! defined $avpkg{$pkg} ) {
    warn "No archives available for package $pkg\n";
  } else {
    my $inst = $pkg{$pkg}->[0];
    my $avail = $avpkg{$pkg}->[0];
    if ( ver_comp( $inst, $avail ) < 0 ) {
      print "Upgrading ", ver_print($inst), " to ",
	    ver_print($avail), "\n";
      while ( @{$pkg{$pkg}} ) {
	push @plan, [ uninstall => pop @{$pkg{$pkg}} ];
      }
      # now install any dependent packages that aren't installed
      my $hdr = "$refpkg/" . ver_print($avail) . "/Header";
      if ( open( my $hdrfh, "<", $hdr ) ) {
	while (<$hdrfh>) {
	  if ( s/^\s*Requires:\s*// ) {
	    my @pkgs = split(' ');
	    for my $reqpkg (@pkgs) {
	      $reqpkg =~ s/^(\w+)(?:-(\d+(?:\.\d+)*))?$/$1/;
	      if ( ! defined $pkg{$reqpkg} ) {
		if ( defined $avpkg{$reqpkg} ) {
		  my $pp = $avpkg{$reqpkg}->[0];
		  print "Installing " . ver_print($pp) .
			" required by " . ver_print($avail) . "\n";
		  push( @plan, [ 'install', $pp ] );
		  $pkg{$reqpkg} = [ $pp ];
		} else {
		  warn "Unable to locate package '$reqpkg' required by " .
		    ver_print($avail) . "\n";
		}
	      }
	    }
	  }
	}
      	close($hdrfh) || warn "Error closing $hdr\n";
      } else {
      	die "No Header for " . ver_print($avail) . "\n";
      }
      push @plan, [ install => $avail ];
    }
  }
}

while (@plan) {
  my $cmdset = shift @plan;
  my ( $cmd, $pp ) = @$cmdset;
  if ( $doit ) {
    if ( $cmd eq 'install' ) {
      install( $npath, $pp );
    } elsif ( $cmd eq 'uninstall' ) {
      uninstall( $npath, $pp );
    } else {
      die "Invalid command in \@plan\n";
    }
  } else {
    print "$cmd: ", ver_print($pp), "\n";
  }
}

sub install {
  my ( $npath, $pp ) = @_;
  print "  Installing ", ver_print($pp), " to $npath/\n";
  my $archive = "$cache/" . ver_print($pp) . ".tar.gz";
  -f $archive || die "Archive $archive not found\n";
  chdir "$npath/" || die "Cannot chdir $npath/\n";
  system( "tar -xzf $archive" ) &&
    die "Error from tar -xzf $archive\n";
}

sub pkg_check {
  my ( $pkg, $src ) = @_;
  if ( $pkg =~ m/^(\w+)(?:-(\d+(?:\.\d+)*))?$/ ) {
    my $root = $1;
    my @ver;
    @ver = split( /\./, $2 ) if $2;
    return { root => $root, ver => \@ver, src => $src };
  } else {
    die "Invalid package reference: '$pkg' from $src\n";
  }
}

sub ver_comp {
  # I am going with slow so I can call this function
  # outside sort.
  my ( $a, $b ) = @_;
  my $i = 0;
  my $va = $a->{ver};
  my $vb = $b->{ver};
  for ( my $i = 0; ; ++$i ) {
    if ( $i >= @$va ) {
      if ( $i >= @$vb ) {
        return 0;
      } else {
        return -1;
      }
    } elsif ( $i >= @$vb ) {
      return 1;
    }
    my $rv = $va->[$i] <=> $vb->[$i];
    return $rv if $rv;
  }
}

sub ver_print {
  my $a = shift;
  return $a->{root} . '-' . join '.', @{$a->{ver}};
}


sub uninstall {
  my ( $npath, $pp ) = @_;
  my $pkgdir = "$npath/var/huarp/pkg";
  my $pkg = ver_print($pp);
  print "  [Uninstalling $pkg from $npath/]\n";
  my @manifests;
  my $proot = "$pkgdir/$pkg";
  my $hdr = "$proot/Header";
  open( my $hdrfh, "<", $hdr ) ||
    die "Unable to locate package header for $pkg\n";
  while (<$hdrfh>) {
    if ( m/^Files:\s*(\w+)\s\@/ ) {
      push @manifests, "$proot/$1";
    }
  }
  close($hdrfh) || warn "Error closing $hdr\n";
  while (@manifests) {
    my @dirs;
    my $manifest = shift @manifests;
    open( my $cont, "<", $manifest ) ||
      die "Unable to read manifest $manifest\n";
    while (<$cont>) {
      chomp;
      my $path = "$npath/$_";
      if ( -d $path ) {
	push(@dirs, $path);
      } elsif ( -f $path ) {
	# print "rm $path\n";
	unlink $path;
      }
    }
    close($cont) || warn "Error closing manifest $manifest\n";
    while ( @dirs ) {
      my $dir = pop(@dirs);
      # print "rmdir $dir\n";
      rmdir $dir;
    }
  }
  rmdir $proot || warn "Unable to remove package directory '$proot'\n";
  # print "rmdir $proot\n";
}
