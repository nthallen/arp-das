/* cis.c Defines functions used by Command Interpreter Server */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include "cis.h"
#include "tm.h"
#include "nortlib.h"
#include "nl_assert.h"

static int io_read (resmgr_context_t *ctp, io_read_t *msg, RESMGR_OCB_T *ocb);
static int io_write(resmgr_context_t *ctp, io_write_t *msg, RESMGR_OCB_T *ocb);
static int io_notify(resmgr_context_t *ctp, io_notify_t *msg, RESMGR_OCB_T *ocb);
static int io_close_ocb(resmgr_context_t *ctp, void *rsvd, RESMGR_OCB_T *ocb);
static command_out_t *new_command(void);
static command_out_t *free_command( command_out_t *cmd );

static resmgr_connect_funcs_t    connect_funcs;
static resmgr_io_funcs_t         rd_io_funcs, wr_io_funcs;
static IOFUNC_ATTR_T             wr_attr;
static int                       wr_id;
static resmgr_attr_t             resmgr_attr;
static dispatch_t                *dpp;
static IOFUNC_ATTR_T             *rd_attrs;

// These will be generated by cmdgen and included in a separate module.
// char ci_version[] = "";
// void cis_initialize(void) {}
// void cis_terminate(void) {}
// void cis_interfaces(void) {}
// int  cmd_batch( char *cmd, int test ) {
//   cmd = cmd;
//   test = test;
// }

static struct ocb *ocb_calloc (resmgr_context_t *ctp, IOFUNC_ATTR_T *device) {
  ocb_t *ocb = calloc( 1, sizeof(ocb_t) );
  if ( ocb == 0 ) return 0;
  /* Initialize any other elements. Currently all zeros is good. */
  /* Increment count on first command */
  if ( device->first_cmd )
    device->first_cmd->ref_count++;
  ocb->next_command = device->first_cmd;
  return ocb;
}

static void ocb_free (struct ocb *ocb) {
  /* Be sure to remove this from the blocking list:
     Actually, there really is no way it should be on
     the blocking list. */
  assert( ocb->rcvid == 0 );
  assert( ocb->next_ocb == 0 );
  if ( ocb->next_command ) {
    assert( ocb->next_command->ref_count > 0 );
    ocb->next_command->ref_count--;
  }
  free( ocb );
}

static iofunc_funcs_t ocb_funcs = { /* our ocb allocating & freeing functions */
    _IOFUNC_NFUNCS,
    ocb_calloc,
    ocb_free
};

/* the mount structure, we have only one so we statically declare it */
static iofunc_mount_t mountpoint = { 0, 0, 0, 0, &ocb_funcs };

/* rdrs is a linked list of rdr IOFUNC_ATTR_Ts */
typedef struct rdrs_s {
  struct rdrs_s *next;
  int id;
  IOFUNC_ATTR_T *rdr;
} rdrs_t;
static rdrs_t *rdrs;

/* Called from code generated by cmdgen for each interface definition */
IOFUNC_ATTR_T *cis_setup_rdr( char *node ) {
  ioattr_t *rd_attr = new_memory(sizeof(ioattr_t));
  char nodebase[80], *nodename;
  int id;
  rdrs_t *rs = new_memory(sizeof(rdrs_t));

  /* initialize attribute structure used by the device */
  iofunc_attr_init(&(rd_attr->attr), S_IFNAM | 0444, 0, 0);
  IOFUNC_NOTIFY_INIT(rd_attr->notify);
  rd_attr->attr.nbytes = 0;
  rd_attr->attr.mount = &mountpoint;
  rd_attr->nodename = nl_strdup( node );
  
  /* Check Experiment variable for sanity: \w[\w.]* */
  /* Build device name */
  snprintf( nodebase, 80, "cmd/%s", node );
  nodename = tm_dev_name( nodebase );
  
  rd_attr->first_cmd = rd_attr->last_cmd = new_command();
  rd_attr->next = rd_attrs;
  rd_attrs = rd_attr;

  /* attach our device name */
  id = resmgr_attach(dpp,            /* dispatch handle        */
                     &resmgr_attr,   /* resource manager attrs */
                     nodename,       /* device name            */
                     _FTYPE_ANY,     /* open type              */
                     0,              /* flags                  */
                     &connect_funcs, /* connect routines       */
                     &rd_io_funcs,   /* I/O routines           */
                     rd_attr);       /* handle                 */
  if(id == -1) {
    nl_error( 3, "Unable to attach name: '%s'", nodename );
  }
  rs->rdr = rd_attr;
  rs->id = id;
  rs->next = rdrs;
  rdrs = rs;
  return rd_attr;
}

static void cis_shutdown_rdr( rdrs_t **p ) {
  rdrs_t *cur_rdr = *p;
  IOFUNC_ATTR_T *attr;
  int rv;

  assert( cur_rdr != NULL);
  attr = cur_rdr->rdr;
  nl_error( -2, "Shutting down reader %s", attr->nodename );
  rv = resmgr_detach( dpp, cur_rdr->id, _RESMGR_DETACH_ALL );
  if ( rv < 0 )
    nl_error( 2, "Error %d from resmgr_detach(%s)",
      errno, attr->nodename );
  nl_free_memory( attr->nodename );
  nl_free_memory( attr );
  *p = cur_rdr->next;
  nl_free_memory( cur_rdr );
}

static int quit_received = 0;

static int all_closed(void) {
  rdrs_t **cur_rdr_p = &rdrs;
  rdrs_t *cur_rdr;
  IOFUNC_ATTR_T *cur_attr;
  for (;;) {
    cur_rdr = *cur_rdr_p;
    if ( cur_rdr == NULL ) break;
    assert( cur_rdr->rdr != NULL );
    cur_attr = cur_rdr->rdr;
    if ( cur_attr->attr.count == 0 )
      cis_shutdown_rdr( cur_rdr_p );
    else
      cur_rdr_p = &(cur_rdr->next);
  }
  return rdrs == NULL && wr_attr.attr.count == 0;
}

static void process_quit(void) {
  rdrs_t *rr;
  int rv;
  nl_error( -2, "Processing Quit" );
  for ( rr = rdrs; rr != NULL; rr = rr->next ) {
    cis_turf( rr->rdr, "" );
  }
  rv = resmgr_detach( dpp, wr_id, _RESMGR_DETACH_PATHNAME );
  if ( rv < 0 )
    nl_error( 2, "Error %d from resmgr_detach(wr_id)", errno );
  all_closed();
  quit_received = 1;
}

void ci_server(void) {
    int use_threads = 0;
    char *server_name;

    cis_initialize();

    /* initialize dispatch interface */
    if((dpp = dispatch_create()) == NULL) {
        nl_error(3, "Unable to allocate dispatch handle.");
    }

    /* initialize resource manager attributes. */
    /* planning to share this struct between rd and wr */
    memset(&resmgr_attr, 0, sizeof resmgr_attr);
    // resmgr_attr.nparts_max = 0;
    // resmgr_attr.msg_max_size = 0;

    /* initialize functions for handling messages */
    iofunc_func_init(_RESMGR_CONNECT_NFUNCS, &connect_funcs, 
                     _RESMGR_IO_NFUNCS, &rd_io_funcs);
    rd_io_funcs.read = io_read;
    /* Will want to handle _IO_NOTIFY at least */
    rd_io_funcs.notify = io_notify;
    rd_io_funcs.close_ocb = io_close_ocb;

    iofunc_func_init(_RESMGR_CONNECT_NFUNCS, &connect_funcs, 
                     _RESMGR_IO_NFUNCS, &wr_io_funcs);
    wr_io_funcs.write = io_write;

    /* initialize attribute structure used by the device */
    iofunc_attr_init(&wr_attr.attr, S_IFNAM | 0664, 0, 0);
    IOFUNC_NOTIFY_INIT(wr_attr.notify);
    wr_attr.attr.nbytes = 0;
    wr_attr.attr.mount = &mountpoint;
    wr_attr.nodename = nl_strdup("writer");

    server_name = nl_strdup( tm_dev_name( CMDSRVR_NAME ) );
    /* Check Experiment variable for sanity: \w[\w.]* */
    /* Build device name */
    /* attach our device name */
    wr_id = resmgr_attach(dpp,            /* dispatch handle        */
                       &resmgr_attr,   /* resource manager attrs */
                       server_name,    /* device name            */
                       _FTYPE_ANY,     /* open type              */
                       0,              /* flags                  */
                       &connect_funcs, /* connect routines       */
                       &wr_io_funcs,   /* I/O routines           */
                       &wr_attr);      /* handle                 */
    if( wr_id == -1 )
      nl_error( 3, "Unable to attach name");
    
    // Call the cmdgen-generated initialization routine
    cis_interfaces();
    // if_foo = cis_setup_rdr( "foo" );
    // if_bar = cis_setup_rdr( "bar" );

    if ( use_threads ) {
      thread_pool_attr_t   pool_attr;
      thread_pool_t        *tpp;

      /* initialize thread pool attributes */
      memset(&pool_attr, 0, sizeof pool_attr);
      pool_attr.handle = dpp;
      pool_attr.context_alloc = dispatch_context_alloc;
      pool_attr.block_func = dispatch_block;
      pool_attr.handler_func = dispatch_handler;
      pool_attr.context_free = dispatch_context_free;
      pool_attr.lo_water = 2;
      pool_attr.hi_water = 4;
      pool_attr.increment = 1;
      pool_attr.maximum = 50;     /* allocate a thread pool handle */
      if((tpp = thread_pool_create(&pool_attr,
                                   POOL_FLAG_EXIT_SELF)) == NULL) {
          nl_error(3, "Unable to initialize thread pool");
      }     /* start the threads, will not return */
      thread_pool_start(tpp);
    } else {
      dispatch_context_t   *ctp;
      ctp = dispatch_context_alloc(dpp);
      while ( 1 ) {
        if ((ctp = dispatch_block(ctp)) == NULL) {
          nl_error( 2, "block error\n" );
          return;
        }
        // printf( "  type = %d,%d  attr.count = %d\n",
        //   ctp->resmgr_context.msg->type,
        //   ctp->resmgr_context.msg->connect.subtype, attr.count );
        dispatch_handler(ctp);
        if ( quit_received && ctp->resmgr_context.rcvid == 0
              && all_closed() ) {
          break;
        }
      }
    }
    return;
}

// This is where commands are recieved. We'll require that only one
// command be received per write. That prevents doing something like
//   cat commandlist.txt > /dev/huarp/Exp/cmd/server
// but there's no particular reason why we'd want to do that. In
// actual use, commands come in one at a time. Also, it's easy enough
// to do:
//  cat commandlist.txt | while read line; do
//    echo $line >/dev/huarp/Exp/cmd/server; done
static int io_write( resmgr_context_t *ctp, io_write_t *msg, RESMGR_OCB_T *ocb ) {
  int status, msgsize;
  char buf[CMD_MAX_COMMAND_IN+1];

  status = iofunc_write_verify(ctp, msg, (iofunc_ocb_t *)ocb, NULL);
  if ( status != EOK )
    return status;

  if ((msg->i.xtype &_IO_XTYPE_MASK) != _IO_XTYPE_NONE )
    return ENOSYS;

  msgsize = msg->i.nbytes;
  if ( msgsize > CMD_MAX_COMMAND_IN )
    return E2BIG;

  _IO_SET_WRITE_NBYTES( ctp, msg->i.nbytes );

  resmgr_msgread( ctp, buf, msgsize, sizeof(msg->i) );
  buf[msgsize] = '\0';

  // Parse leading options
  // No spaces, colons or right brackets allowed in mnemonics 
  { char *mnemonic = "--";
    int quiet = 0;
    int testing = 0;
    char *s = buf;

    if ( *s == '[' ) {
      s++;
      if ( isgraph(*s) && *s != ':' && *s != ']' ) {
        mnemonic = s++;
        while ( isgraph(*s) && *s != ':' && *s != ']' )
          s++;
      }
      if ( !isgraph(*s) ) {
        nl_error( 2, "Invalid mnemonic string" );
        return EINVAL;
      }
      if ( *s == ':' ) {
        int end_of_opts = 0;
        char *ver;

        *s++ = '\0'; // terminate the mnemonic
        // and then handle the options
        while (!end_of_opts) {
          switch (*s) {
            case 'T': testing = 1; s++; break;
            case 'Q': quiet = 1; s++; break;
            case 'X': process_quit(); return EOK;
            case 'V': // handle version command
              ver = ++s;
              while ( *s != ']' && *s != '\0' ) s++;
              if ( *s == '\0' ) {
                nl_error( 2, "Unterminated version string" );
                return EINVAL;
              }
              *s = '\0';
              if ( strcmp( ver, ci_version ) == 0 )
                return EOK;
              nl_error( 2, "Command Versions don't match" );
              return EINVAL;
            case ']': end_of_opts = 1; break;
            default:
              nl_error( 2, "Invalid option" );
              return EINVAL;
          }
        }
      }
      // blank out trailing ']' in case it's the end of the mnemonic
      *s++ = '\0';
    }
    { char *cmd = s;
      int len = 0;
      int rv;
      int clen;

      // Now s points to a command we want to parse.
      // Make sure it's kosher
      while ( *s ) {
        if ( ! isprint(*s) && *s != '\n' ) {
          nl_error( 2, "Invalid character in command" );
          return EINVAL;
        }
        len++;
        s++;
      }
      if ( len > 0 && cmd[len-1] == '\n' ) len--;
      nl_error( quiet ? -2 : 0, "%s: %*.*s",
        mnemonic, len, len, cmd );
      cmd_init();
      rv = cmd_batch( cmd, testing );
      ocb->hdr.attr->attr.flags |= IOFUNC_ATTR_MTIME | IOFUNC_ATTR_CTIME;
      switch ( CMDREP_TYPE(rv) ) {
        case 0: return EOK;
        case 1:
	  if (testing) return EOK;
	  process_quit();
	  return ENOENT;
        case 2: /* Report Syntax Error */
          if ( nl_response ) {
            nl_error( 2, "%s: Syntax Error", mnemonic );
            nl_error( 2, "%*.*s", len, len, cmd);
            nl_error( 2, "%*s", rv - CMDREP_SYNERR, "^");
          }
          return EINVAL;
        default: return EIO;
      }
    }
  }
}

static int io_notify(resmgr_context_t *ctp, io_notify_t *msg, RESMGR_OCB_T *ocb) {
  IOFUNC_ATTR_T *rd_attr = ocb->hdr.attr;
  int trig = 0;
  if ( ocb->next_command->cmdlen > ocb->hdr.offset ||
       ocb->next_command->next )
    trig |= _NOTIFY_COND_INPUT;
  return(iofunc_notify(ctp, msg, rd_attr->notify, trig, NULL, NULL ));
}

static int io_close_ocb(resmgr_context_t *ctp, void *rsvd, RESMGR_OCB_T *ocb) {
  IOFUNC_ATTR_T *rd_attr = ocb->hdr.attr;
  iofunc_notify_remove(ctp, rd_attr->notify);
  return(iofunc_close_ocb_default(ctp, rsvd, ocb));
}

static void read_reply( RESMGR_OCB_T *ocb ) {
  int nb = ocb->nbytes_requested;
  command_out_t *cmd = ocb->next_command;
  int cmdbytes = cmd->cmdlen - ocb->hdr.offset;
  int bytes_returned = nb > cmdbytes ? cmdbytes : nb;

  assert(cmd->ref_count > 0);
  assert(cmdbytes >= 0);
  MsgReply( ocb->rcvid, bytes_returned,
    cmd->command + ocb->hdr.offset, bytes_returned );
  ocb->rcvid = 0;
  if ( bytes_returned < cmdbytes ) {
    ocb->hdr.offset += bytes_returned;
  } else {
    IOFUNC_ATTR_T *handle = ocb->hdr.attr;
    ocb->hdr.offset = 0;
    cmd->ref_count--;
    ocb->next_command = cmd->next;
    ocb->next_command->ref_count++;
    if ( handle->first_cmd->ref_count == 0 &&
         handle->first_cmd->next != 0 ) {
      handle->first_cmd = free_command( handle->first_cmd );
    }
  }
}

static int io_read (resmgr_context_t *ctp, io_read_t *msg, RESMGR_OCB_T *ocb) {
  int status, nonblock = 0;
  IOFUNC_ATTR_T *handle = ocb->hdr.attr;

  if ((status = iofunc_read_verify( ctp, msg,
                     (iofunc_ocb_t *)ocb, &nonblock)) != EOK)
    return (status);
      
  if ((msg->i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE)
    return (ENOSYS);

  ocb->rcvid = ctp->rcvid;
  ocb->nbytes_requested = msg->i.nbytes;
  if ( ocb->next_command->cmdlen > ocb->hdr.offset ||
  		ocb->next_command->next ) {
    // we've got something to send now
    read_reply( ocb );
  } else if (nonblock) {
    ocb->rcvid = 0;
    return EAGAIN;
  } else {
    // Nothing at the moment.
    ocb->next_ocb = handle->blocked;
    handle->blocked = ocb;
  }
  return _RESMGR_NOREPLY;
}

static command_out_t *free_commands;

static command_out_t *new_command(void) {
  command_out_t *cmd;
  if ( free_commands ) {
    cmd = free_commands;
    free_commands = cmd->next;
  } else {
    cmd = new_memory(sizeof(command_out_t));
  }
  cmd->next = NULL;
  cmd->ref_count = 0;
  cmd->command[0] = '\0';
  cmd->cmdlen = 0;
  return cmd;
}

// Returns the next command so it's easy to free the
// first command in a list:
// list = free_command( list );
static command_out_t *free_command( command_out_t *cmd ) {
  command_out_t *nxt;
  assert( cmd != NULL );
  assert( cmd->ref_count == 0 );
  nxt = cmd->next;
  cmd->next = free_commands;
  free_commands = cmd;
  return nxt;
}

void cis_turf( IOFUNC_ATTR_T *handle, char *format, ... ) {
  va_list arglist;
  command_out_t *cmd;
  int nb;

  assert( handle != NULL );
  cmd = handle->last_cmd;
  va_start( arglist, format );
  nb = vsnprintf( cmd->command, CMD_MAX_COMMAND_OUT, format, arglist );
  va_end( arglist );
  if ( nb >= CMD_MAX_COMMAND_OUT ) {
    nl_error( 2, "Output buffer overflow to node %s", handle->nodename );
    cmd->command[0] = '\0';
  } else {
    cmd->cmdlen = nb;
    cmd->next = handle->last_cmd = new_command();
    // Now run the queue of blocked clients:
    while ( handle->blocked ) {
      IOFUNC_OCB_T *ocb = handle->blocked;
      handle->blocked = ocb->next_ocb;
      ocb->next_ocb = NULL;
      assert(ocb->hdr.offset == 0);
      read_reply(ocb);
    }
    // Then notify non-blocking clients:
    if (IOFUNC_NOTIFY_INPUT_CHECK(handle->notify, 1, 0))
    	iofunc_notify_trigger(handle->notify, 1, IOFUNC_NOTIFY_INPUT);
  }
}

/*
=Name ci_server(): Command Server main loop
=Subject Command Server and Client

=Synopsis

#include "tm.h"
void ci_server(void);

=Description

ci_server() does all the work for a command server. It does
not return until =cmd_batch=() returns a CMDREP_QUIT or it receives
a CMDINTERP_QUIT message.<P>

It registers the CMDINTERP_NAME with the operating system, then
loops to Receive messages. For each received command, ci_server()
calls =cmd_init=() and =cmd_batch=(). If needed, a hook could
be added to Receive other messages.

=Returns
Nothing.

=SeeAlso
=Command Server and Client= functions.

=End

=Name cmd_batch(): Parse a command in batch mode
=Subject Command Server and Client
=Name cmd_init(): Initialize command parser
=Subject Command Server and Client
=Synopsis

#include "cmdalgo.h"
int cmd_batch( char *cmd, int test );
void cmd_init( void );
void cis_initialize(void);
void cis_terminate(void);
void cis_interfaces(void);

=Description

  These functions are all generated by CMDGEN. cmd_init()
  resets the parser to its start state. cmd_batch() provides an
  input string that the parser will act on. If test is non-zero,
  no actions associated with the command will be executed.
  cis_initialize() is called at the very beginning of ci_server(),
  and cis_terminate() is called at the very end. These are used
  by cmdgen and soldrv to handle proxy-based commands in QNX4.
  It remains to be seen if these will be used in QNX6.
  cis_interfaces() is called from ci_server() to initialize
  reader interfaces in QNX6.

=Returns

  cmd_batch() returns the same error codes as =ci_sendcmd=().

=SeeAlso

  =Command Server and Client= functions.

=End

*/
