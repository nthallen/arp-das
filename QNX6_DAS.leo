<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20091104124904.1987"><vh>@chapters</vh></v>
<v t="ntallen.20070319130904" a="E"><vh>QNX6 Data Acquisition Architecture</vh>
<v t="ntallen.20110216082835.2101"><vh>Todo</vh>
<v t="ntallen.20110216082835.2102"><vh>Switch DCCC to res mgr</vh>
<v t="ntallen.20110216082835.2103"><vh>done: Cmdgen: define new syntax</vh>
<v t="ntallen.20110215130743.2097"><vh>Server writing commands to driver</vh></v>
<v t="ntallen.20110216082835.2110"><vh>Server writing data to collection</vh></v>
</v>
<v t="ntallen.20110216082835.2104"><vh>done: tmlib: define, implement API</vh></v>
<v t="ntallen.20110218102714.2118"><vh>done: tmpplib: implement API</vh></v>
<v t="ntallen.20110216082835.2107"><vh>done: DACSdiag: modify *.cmd</vh></v>
<v t="ntallen.20110216082835.2108"><vh>HHH: modify *.cmd</vh></v>
<v t="ntallen.20110216082835.2106"><vh>done: dccc: implement resmgr</vh></v>
<v t="ntallen.20110218102714.2119"><vh>done: subbusd</vh></v>
</v>
</v>
<v t="ntallen.20070815151915"><vh>Status</vh>
<v t="ntallen.20080729145409"><vh>Overview</vh></v>
<v t="ntallen.20071127160602"><vh>OS Install</vh>
<v t="ntallen.20071127160602.1"><vh>Save</vh></v>
<v t="ntallen.20071204104659"><vh>Install</vh></v>
<v t="ntallen.20090225110248"><vh>Install 6.4.0</vh></v>
<v t="ntallen.20090824101208"><vh>Install 6.4.1</vh>
<v t="ntallen.20090910171038"><vh>C++ Compiling and Linking</vh></v>
<v t="ntallen.20090911120219"><vh>phrtg compile hacks</vh></v>
<v t="ntallen.20090930220540"><vh>Eli 4.6.1 CVS</vh></v>
</v>
<v t="ntallen.20100723121747.2023"><vh>Install 6.5.0</vh>
<v t="ntallen.20101124082052.2043"><vh>C++ Compile issue</vh></v>
</v>
<v t="ntallen.20101129134921.2045"><vh>Eli</vh></v>
<v t="ntallen.20090824123722"><vh>Runtime kit Creation and Usage</vh>
<v t="ntallen.20090505113338"><vh>Flight System Configuration</vh></v>
<v t="ntallen.20091109122106.1991"><vh>GSE Initialization</vh></v>
<v t="ntallen.20100726093122.2025"><vh>Add pkgs to install CD: done</vh>
<v t="ntallen.20100720160700.2021"><vh>pkg_copy, pkg_include?</vh></v>
<v t="ntallen.20100726093122.2026"><vh>Add compiler to install CD</vh></v>
<v t="ntallen.20091104124904.1988"><vh>GSE System Install Kit</vh></v>
</v>
<v t="ntallen.20101206091106.2047"><vh>QNX650 Update</vh>
<v t="ntallen.20101207141953.2053"><vh>qnx package</vh></v>
<v t="ntallen.20101207141953.2054"><vh>photon package</vh></v>
</v>
<v t="ntallen.20101206091106.2048"><vh>Organizing my pkgs</vh>
<v t="ntallen.20101206091106.2049"><vh>Versions</vh></v>
<v t="ntallen.20101222082748.2057"><vh>Versions II</vh></v>
</v>
</v>
<v t="ntallen.20090818124956"><vh>6.4.1 Upgrade and CLARREO IIP</vh>
<v t="ntallen.20090818124956.1"><vh>Install 6.4.1 on Windows</vh></v>
<v t="ntallen.20090818124956.2"><vh>Install 6.4.1 on VM</vh></v>
<v t="ntallen.20090818124956.3"><vh>Create flight runtime kit for 6.4.1 and install on IIP flight system</vh></v>
<v t="ntallen.20091030133630"><vh>Create gse runtime kit for 6.4.1 and install on IIP GSE</vh></v>
<v t="ntallen.20090818124956.4"><vh>Investigate consolidation of libraries into single autoconf group</vh></v>
</v>
</v>
<v t="ntallen.20070815151915.1"><vh>Command</vh></v>
<v t="ntallen.20080516115802"><vh>memo</vh></v>
<v t="ntallen.20070815151915.2"><vh>Data</vh>
<v t="ntallen.20080715165457"><vh>tmc Changes</vh></v>
<v t="ntallen.20080716230618"><vh>Timestamp issue</vh></v>
<v t="ntallen.20080724120806"><vh>To Cache or not to Cache</vh></v>
<v t="ntallen.20080724120806.1"><vh>TM Receive</vh>
<v t="ntallen.20080724120806.2"><vh>Client library</vh></v>
<v t="ntallen.20080724120806.3"><vh>Collection Side</vh></v>
</v>
</v>
<v t="ntallen.20080627131220"><vh>Resources</vh>
<v t="ntallen.20080627131220.1"><vh>QFC</vh></v>
<v t="ntallen.20080627131220.2"><vh>Subversion and Eclipse</vh></v>
<v t="ntallen.20080627131220.3"><vh>doxygen</vh></v>
<v t="ntallen.20080627131220.4"><vh>pkgsrc</vh></v>
</v>
</v>
<v t="ntallen.20070815151915.3"><vh>Lessons</vh>
<v t="ntallen.20090430131154"><vh>Linking Problem: 090430</vh></v>
</v>
<v t="ntallen.20070409132623"><vh>PR</vh>
<v t="ntallen.20070409133739"><vh>Operation</vh>
<v t="ntallen.20070409133739.1"><vh>Configurations</vh>
<v t="ntallen.20070409132623.1"><vh>Full Up with GSE</vh></v>
<v t="ntallen.20070409132623.2"><vh>Flight Mode</vh></v>
<v t="ntallen.20070409132623.3"><vh>Playback</vh></v>
<v t="ntallen.20070409132623.4"><vh>Extraction</vh></v>
<v t="ntallen.20070409132623.5"><vh>Remote GSE</vh></v>
</v>
<v t="ntallen.20070409133739.2"><vh>Display Options</vh>
<v t="ntallen.20070409132623.6"><vh>Data</vh></v>
<v t="ntallen.20070409132623.7"><vh>Command</vh></v>
</v>
<v t="ntallen.20070409132623.8"><vh>Applications</vh>
<v t="ntallen.20070409132623.9"><vh>Memo</vh></v>
</v>
</v>
<v t="ntallen.20070409133739.3"><vh>Implementation</vh></v>
</v>
<v t="ntallen.20070413134915"><vh>QNX Development Issues</vh>
<v t="ntallen.20070425144317"><vh>Handling more than one executable per project</vh></v>
<v t="ntallen.20070413134915.1"><vh>Development Strategy</vh>
<v t="ntallen.20070425144317.1"><vh>cmdgen</vh>
<v t="ntallen.20070430134037"><vh>QNX4</vh></v>
</v>
<v t="ntallen.20070502121159"><vh>Names and Devices</vh></v>
<v t="ntallen.20070425144317.4"><vh>nortlib</vh></v>
<v t="ntallen.20070425144317.2"><vh>tmlib</vh></v>
<v t="ntallen.20070425144317.3"><vh>tmphlib</vh></v>
<v t="ntallen.20100927130121.2034"><vh>displib</vh></v>
<v t="ntallen.20100927130121.2033"><vh>tmnclib</vh></v>
</v>
</v>
<v t="ntallen.20070502121159.1"><vh>Implementation</vh>
<v t="ntallen.20070320121924"><vh>cmdgen</vh>
<v t="ntallen.20070501165557"><vh>Done</vh>
<v t="ntallen.20070411152334"><vh>Add Interface Definitions</vh>
<v t="ntallen.20070404111542"><vh>Initialization</vh></v>
</v>
<v t="ntallen.20070501165557.1"><vh>Figure out appropriate library flag</vh></v>
<v t="ntallen.20070502121159.2"><vh>Syntax and version checking</vh>
<v t="ntallen.20070502121159.3"><vh>cis must produce syntax error messages</vh></v>
<v t="ntallen.20070502121159.4"><vh>cic must handle version test differently</vh></v>
</v>
<v t="ntallen.20070404165230.1"><vh>Handle Quit</vh></v>
<v t="ntallen.20070501165557.2"><vh>Fix up the experiment path correctly in cis.c</vh></v>
<v t="ntallen.20070508171951"><vh>cmdgen: cis_interface needs to be bracketed by #ifdef SERVER</vh></v>
<v t="ntallen.20070508171951.1"><vh>cmdgen: cmdgen.skel needs main() changes for PHOTON</vh></v>
<v t="ntallen.20070501165557.3"><vh>Tweak cmdgen.skel</vh></v>
<v t="ntallen.20070501165557.4"><vh>Write a photon command client</vh></v>
<v t="ntallen.20070508171951.3"><vh>cmdgen: cmdgen.skel needs to be distributed</vh></v>
<v t="ntallen.20070509151554"><vh>Move oui libary to $(datadir)/oui</vh></v>
<v t="ntallen.20070508171951.4"><vh>cmdgen: cmdgen.skel atexit() needs to be investigated</vh></v>
<v t="ntallen.20070509151554.1"><vh>cmdgen: cmdgen.skel SERVER DISPLAY_EOL</vh></v>
<v t="ntallen.20070508171951.5"><vh>Handle quit and exit in cmdclient</vh></v>
<v t="ntallen.20070509151554.2"><vh>Move cmdclient.c into tmphlib</vh></v>
<v t="ntallen.20070502121159.5"><vh>Memo interface can wait</vh></v>
<v t="ntallen.20070509151554.3"><vh>Add default .cmd files as appropriate</vh></v>
</v>
<v t="ntallen.20070508171951.2"><vh>Todo</vh>
<v t="ntallen.20070508171951.6"><vh>Draw polygon</vh></v>
<v t="ntallen.20070508171951.7"><vh>Get a cursor in cmd_text somehow</vh></v>
</v>
</v>
<v t="ntallen.20070509151554.4"><vh>appgen</vh>
<v t="ntallen.20070509151554.5"><vh>command server</vh></v>
</v>
<v t="ntallen.20080516115802.1"><vh>memo</vh></v>
<v t="ntallen.20091022143321"><vh>mkdoit3	</vh></v>
<v t="ntallen.20091022143321.1"><vh>algorithm status</vh></v>
</v>
<v t="ntallen.20070502121159.6"><vh>Design</vh>
<v t="ntallen.20070319130904.1"><vh>Data</vh>
<v t="ntallen.20070524163205"><vh>Data Issues</vh>
<v t="ntallen.20070524163205.1"><vh>What is the difference between the telemetry stream and the TM stream as returned from TMbfr?</vh>
<v t="ntallen.20070524163205.2"><vh>TM has no timestamps</vh></v>
<v t="ntallen.20070524163205.3"><vh>Does not include TM info struct or identifiers</vh></v>
</v>
<v t="ntallen.20070524163205.4"><vh>What form should Inetin/Inetout use?</vh></v>
<v t="ntallen.20080708155309"><vh>What are the optimized data formats that TMbfr supports?</vh>
<v t="ntallen.20080708155309.1"><vh>T1 full minor frames</vh></v>
<v t="ntallen.20080708155309.2"><vh>T2 full rows with header</vh></v>
<v t="ntallen.20080708155309.3"><vh>T3 optimized rows with header</vh></v>
<v t="ntallen.20080708155309.4"><vh>T4: T3 with chksum word</vh></v>
</v>
<v t="ntallen.20070524163205.5"><vh>What form should lgr/rdr use?</vh></v>
<v t="ntallen.20070524163205.6"><vh>What about other DGs? Collection?</vh></v>
<v t="ntallen.20070524163205.7"><vh>What sort of data transformations should TMbfr perform?</vh></v>
<v t="ntallen.20070524163205.9"><vh>TMbfr Client Options</vh>
<v t="ntallen.20070524163205.11"><vh>Incomplete Data</vh></v>
</v>
<v t="ntallen.20080715165457"></v>
</v>
<v t="ntallen.20070319130904.2"><vh>TMbfr</vh>
<v t="ntallen.20070524163205.8"><vh>TMbfr Operation</vh>
<v t="ntallen.20080516131227"><vh>TMbfr Write Modes: O_NONBLOCK</vh></v>
<v t="ntallen.20080516131227.1"><vh>TMbfr Read Modes: DCo, DCf</vh></v>
<v t="ntallen.20070525114357"><vh>Register Names</vh></v>
<v t="ntallen.20070525114357.1"><vh>Delay allocating buffers</vh></v>
<v t="ntallen.20070525114357.2"><vh>DG initialization</vh></v>
<v t="ntallen.20070525114357.3"><vh>Store incoming data in circular queue</vh></v>
<v t="ntallen.20070525114357.4"><vh>Store metadata in linked list</vh>
<v t="ntallen.20070706110550"><vh>How to track reader progress</vh></v>
</v>
<v t="ntallen.20070525114357.5"><vh>Store TimeStamps in linked list</vh></v>
<v t="ntallen.20070529132018"><vh>Extend Attribute Structure</vh></v>
<v t="ntallen.20070529132018.1"><vh>Provide iofunc_open_handler for DG</vh></v>
<v t="ntallen.20070525114357.6"><vh>Store context in each OCB</vh>
<v t="ntallen.20070525132754"><vh>Partial frames</vh></v>
</v>
<v t="ntallen.20070529132018.2"><vh>io_write</vh>
<v t="ntallen.20070531163245"><vh>States</vh>
<v t="ntallen.20070529133623"><vh>Partial Header</vh></v>
<v t="ntallen.20070531162708"><vh>TM_Info</vh></v>
<v t="ntallen.20070529133623.1"><vh>Partial Data</vh></v>
</v>
<v t="ntallen.20070611133034"><vh>Data Handling</vh>
<v t="ntallen.20070612165620"><vh>States</vh></v>
<v t="ntallen.20080708165645"><vh>Conversions</vh></v>
<v t="ntallen.20070611133034.1"><vh>T1-&gt;T1</vh></v>
<v t="ntallen.20070611133034.2"><vh>T1-&gt;T2</vh></v>
<v t="ntallen.20070611133034.3"><vh>T1-&gt;T3</vh></v>
<v t="ntallen.20070611133034.4"><vh>T2-&gt;T1 x</vh></v>
<v t="ntallen.20070611133034.5"><vh>T2-&gt;T2</vh></v>
<v t="ntallen.20070611133034.6"><vh>T2-&gt;T3 x</vh></v>
<v t="ntallen.20070611133034.7"><vh>T3-&gt;T1 x</vh></v>
<v t="ntallen.20070611133034.8"><vh>T3-&gt;T2 x</vh></v>
<v t="ntallen.20070611133034.9"><vh>T3-&gt;T3</vh></v>
<v t="ntallen.20070612220750"><vh>Scratch</vh></v>
</v>
</v>
<v t="ntallen.20070531154309"><vh>io_read</vh>
<v t="ntallen.20070531163245.1"><vh>States</vh>
<v t="ntallen.20070531163245.2"><vh>Partial Header</vh></v>
<v t="ntallen.20070531163245.3"><vh>TM_Info</vh></v>
<v t="ntallen.20070531163245.4"><vh>Partial Data</vh></v>
</v>
</v>
<v t="ntallen.20070601102213"><vh>Commandability</vh></v>
</v>
<v t="ntallen.20070612165620.1"><vh>TMbfr Testing</vh></v>
</v>
<v t="ntallen.20070319130904.3"><vh>Data Generators</vh>
<v t="ntallen.20080516131227"></v>
<v t="ntallen.20070817133522.5"><vh>DG API and design issues</vh>
<v t="ntallen.20080624104326"><vh>Interfaces</vh>
<v t="ntallen.20080625152707"><vh>Command Interfaces</vh></v>
<v t="ntallen.20080624104326.1"><vh>Driver Interface</vh>
<v t="ntallen.20080624104326.2"><vh>Driver Class</vh></v>
</v>
<v t="ntallen.20080624104326.3"><vh>Driver Synchronization</vh>
<v t="ntallen.20080624104326.4"><vh>Blocking writes</vh></v>
<v t="ntallen.20080624104326.5"><vh>Non-blocking writes and ionotify</vh></v>
</v>
</v>
<v t="ntallen.20080707135523"><vh>Main</vh>
<v t="ntallen.20080707135523.1"><vh>Read Thread</vh></v>
<v t="ntallen.20080708133047"><vh>Write Thread</vh></v>
</v>
<v t="ntallen.20070823131008"><vh>data_queue (DQ)</vh>
<v t="ntallen.20080710162929"><vh>DQ hierarchy</vh>
<v t="ntallen.20080710162929.1"><vh>Commands</vh></v>
<v t="ntallen.20080710162929.2"><vh>Collection strategy</vh></v>
<v t="ntallen.20080908205900"><vh>rdr (or general extraction) Strategy</vh>
<v t="ntallen.20080909114112"><vh>Control Thread</vh></v>
<v t="ntallen.20080710162929.3"><vh>Output Thread</vh></v>
<v t="ntallen.20080909114112.1"><vh>Input Thread</vh></v>
</v>
</v>
<v t="ntallen.20080708165645.1"><vh>Will DQ provide type translation?</vh></v>
<v t="ntallen.20080623133120"><vh>DQ Semaphore</vh></v>
<v t="ntallen.20070823131008.1"><vh>Writer operations</vh>
<v t="ntallen.20080709115758"><vh>Initialization</vh></v>
<v t="ntallen.20070823131008.2"><vh>allocate_rows(n_rows_max)</vh></v>
<v t="ntallen.20070823131008.3"><vh>commit_rows(MFCtr, row_start, n_rows)</vh></v>
<v t="ntallen.20070823131008.4"><vh>commit_tstamp(MFCtr, time)</vh></v>
</v>
<v t="ntallen.20070823131008.5"><vh>Reader operations</vh>
<v t="ntallen.20070823131008.6"><vh>transmit_rows(n_rows)</vh></v>
</v>
</v>
<v t="ntallen.20070820135203"><vh>Collection</vh></v>
<v t="ntallen.20070822162630"><vh>rdr</vh></v>
<v t="ntallen.20070822162630.1"><vh>Inetin</vh></v>
<v t="ntallen.20070820135203.1"><vh>Everything else</vh></v>
</v>
<v t="ntallen.20070319130904.4"><vh>Collection</vh>
<v t="ntallen.20070404221945"><vh>Define data interfaces</vh></v>
</v>
<v t="ntallen.20070319130904.5"><vh>rdr</vh>
<v t="ntallen.20100810122935.2031"><vh>rdr options</vh></v>
</v>
<v t="ntallen.20070319130904.6"><vh>Inetin</vh></v>
<v t="ntallen.20080516132543"><vh>TMRelay</vh></v>
</v>
<v t="ntallen.20070319130904.7"><vh>Data Clients</vh>
<v t="ntallen.20080519132626"><vh>DC API</vh></v>
<v t="ntallen.20080516131227.1"></v>
<v t="ntallen.20070319130904.8"><vh>lgr</vh></v>
<v t="ntallen.20070319130904.9"><vh>display</vh>
<v t="ntallen.20100927130121.2035"><vh>ncurses</vh>
<v t="ntallen.20101229203740.2059"><vh>Start Up</vh></v>
<v t="ntallen.20100927130121.2037"><vh>table mods</vh></v>
<v t="ntallen.20100927130121.2038"><vh>appgen mods</vh></v>
</v>
</v>
<v t="ntallen.20070319130904.10"><vh>extractions</vh></v>
<v t="ntallen.20070319130904.11"><vh>algorithms</vh></v>
</v>
<v t="ntallen.20070404221945.1"><vh>TMC rework</vh></v>
<v t="ntallen.20070404221945.2"><vh>SNAFU/ssp library</vh></v>
</v>
<v t="ntallen.20070319130904.12"><vh>Command</vh>
<v t="ntallen.20070320110353"><vh>Command Server</vh>
<v t="ntallen.20070404111542.1"><vh>Write: sending commands to server</vh>
<v t="ntallen.20070404111542.2"><vh>How will syntax testing work?</vh></v>
</v>
<v t="ntallen.20110216082835.2105"><vh>Getting commands from server</vh>
<v t="ntallen.20110220101447.2123"><vh>%INTERFACE</vh></v>
<v t="ntallen.20070320135407"><vh>Reading from server</vh>
<v t="ntallen.20070320135407.1"><vh>Node Name</vh></v>
<v t="ntallen.20070320135407.2"><vh>Client Message Definition</vh>
<v t="ntallen.20070320135407.4"><vh>Message contents</vh></v>
<v t="ntallen.20070320135407.5"><vh>Queue Length</vh></v>
</v>
<v t="ntallen.20070320140803"><vh>Operation</vh>
<v t="ntallen.20070330134656.1"><vh>Command Type</vh></v>
</v>
<v t="ntallen.20070320140803.1"><vh>Errors</vh>
<v t="ntallen.20070320140803.2"><vh>Out of Memory</vh></v>
<v t="ntallen.20070320140803.3"><vh>No Readers</vh></v>
<v t="ntallen.20070320140803.4"><vh>Missed Command</vh></v>
</v>
</v>
<v t="ntallen.20110215130743.2097"></v>
<v t="ntallen.20110216082835.2110"></v>
<v t="ntallen.20110220101447.2124"><vh>Server communicating with subbus</vh></v>
</v>
<v t="ntallen.20070320150841"><vh>Development Plan</vh>
<v t="ntallen.20070403140218"><vh>resmgr_attach()</vh>
<v t="ntallen.20070403140218.1"><vh>dispatch_t *dpp</vh></v>
<v t="ntallen.20070403140218.2"><vh>resmgr_attr_t resmgr_attr</vh></v>
<v t="ntallen.20070403140218.3"><vh>path</vh></v>
<v t="ntallen.20070403140218.4"><vh>IOFUNC_ATTR_T handle</vh>
<v t="ntallen.20070403140218.5"><vh>iofunc_mount_t mountpoint</vh></v>
</v>
</v>
<v t="ntallen.20070330134656"><vh>Define data structures for queuing command output</vh>
<v t="ntallen.20070330134656.1"></v>
</v>
<v t="ntallen.20070404165230"><vh>Support SELECT</vh></v>
<v t="ntallen.20070404165230.1"></v>
<v t="ntallen.20070320150841.4"><vh>Incorporate cmdgen</vh></v>
<v t="ntallen.20070404165230.2"><vh>Support Signals</vh></v>
</v>
</v>
<v t="ntallen.20070320150524.1"><vh>Command Sources</vh>
<v t="ntallen.20070320150524.2"><vh>Keyboard</vh></v>
<v t="ntallen.20070320150524.3"><vh>Algorithm</vh></v>
<v t="ntallen.20110215130743.2095"><vh>Soldrv</vh></v>
<v t="ntallen.20110215130743.2096"><vh>MuxCtrl</vh></v>
</v>
<v t="ntallen.20070320150524.4"><vh>Command Receivers</vh>
<v t="ntallen.20070320150524.5"><vh>DG</vh></v>
<v t="ntallen.20070320150524.6"><vh>lgr</vh></v>
<v t="ntallen.20070320150524.8"><vh>Indexer</vh></v>
<v t="ntallen.20070320150524.9"><vh>DCCC</vh></v>
<v t="ntallen.20070322160353"><vh>Quit</vh></v>
<v t="ntallen.20110218102714.2117"><vh>subbusd</vh></v>
</v>
</v>
<v t="ntallen.20070322130922"><vh>memo</vh>
<v t="ntallen.20070322160353.1"><vh>Message formatting probably takes place in the library</vh></v>
<v t="ntallen.20070322130922.1"><vh>Adopt /dev/huarp/exp/memo</vh></v>
<v t="ntallen.20070322130922.3"><vh>Write to log file, etc.</vh></v>
<v t="ntallen.20070330134656.3"><vh>Can eliminate ocb_funcs here</vh></v>
<v t="ntallen.20070322130922.2"><vh>Accept atomic writes from multiple sources</vh></v>
<v t="ntallen.20070322160353.2"><vh>Strategy for termination, communication with the command server</vh>
<v t="ntallen.20070322180349"><vh>Find out how to gracefully shut down a resource manager</vh></v>
<v t="ntallen.20070322160353.3"><vh>Avoiding Deadlock</vh></v>
<v t="ntallen.20070322160353.4"><vh>Terminate after at least one client has opened and all have closed</vh></v>
</v>
</v>
<v t="ntallen.20100729115515.2029"><vh>subbus_usb</vh></v>
<v t="ntallen.20090202133816"><vh>Utilities</vh>
<v t="ntallen.20090202133816.1"><vh>mkdoit</vh>
<v t="ntallen.20090202133816.2"><vh>Dedicated Acquisition node</vh></v>
<v t="ntallen.20110106130520.2064"><vh>doit [-ns] [-p run] [-i src] [start|stop|not|wait]</vh>
<v t="ntallen.20110110214655.2067"><vh>.doit</vh>
<v t="ntallen.20110110214655.2068"><vh>Possible optimizations</vh></v>
</v>
</v>
<v t="ntallen.20090202133816.3"><vh>Development node</vh></v>
<v t="ntallen.20110106130520.2063"><vh>Playback</vh>
<v t="ntallen.20110111074722.2071"><vh>Run identifier</vh></v>
</v>
<v t="ntallen.20110113085104.2073"><vh>Syntax and invocation</vh>
<v t="ntallen.20110113085104.2075"><vh>Dependencies</vh></v>
</v>
</v>
</v>
<v t="ntallen.20110421132300.2127"><vh>Data Management</vh>
<v t="ntallen.20110421132300.2128"><vh>The Need</vh></v>
<v t="ntallen.20110421132300.2129"><vh>Operations</vh></v>
<v t="ntallen.20110421132300.2131"><vh>Queries</vh></v>
<v t="ntallen.20110421132300.2130"><vh>Information to maintain</vh></v>
</v>
</v>
<v t="ntallen.20070404221945.3" a="E"><vh>Graphics</vh>
<v t="ntallen.20090203160910" a="E"><vh>PhRTG</vh>
<v t="ntallen.20090316133552"><vh>Bugs</vh>
<v t="ntallen.20090422104622"><vh>Marking line visible does not redraw...</vh></v>
<v t="ntallen.20090316133552.1"><vh>Resolved: Divider Issue</vh></v>
</v>
<v t="ntallen.20090211110324"><vh>Todo</vh>
<v t="ntallen.20090508182157"><vh>Derived</vh>
<v t="ntallen.20090514103050"><vh>X Units</vh></v>
<v t="ntallen.20090508132540"><vh>Detrend</vh></v>
<v t="ntallen.20090508132540.2"><vh>FFT</vh></v>
</v>
<v t="ntallen.20090422102356.2"><vh>Figure out how palette works</vh></v>
<v t="ntallen.20090227133851"><vh>Data Feed</vh></v>
<v t="ntallen.20090302125256"><vh>Warnings</vh></v>
<v t="ntallen.20090508132540.1"><vh>Done: ~RTG_Variable</vh></v>
<v t="ntallen.20090429153442"><vh>Done: Deleting a Graph should flag a change in range</vh></v>
<v t="ntallen.20090422102356.1"><vh>Done: Remove Pane from PhAB module</vh></v>
<v t="ntallen.20090429153442.1"><vh>Done: Adding a graph switches away from Line Tab</vh></v>
<v t="ntallen.20090428171747"><vh>Done: Provide reasonable defaults for current_child</vh></v>
<v t="ntallen.20090211110418.1"><vh>Drag and Drop test programs</vh></v>
<v t="ntallen.20090325170837"><vh>Done: Keep for Reference: plot_obj destructors</vh></v>
<v t="ntallen.20090331140856.1"><vh>Done? Consider get_focus changes</vh></v>
<v t="ntallen.20090211110324.1"><vh>Done: PtDivider test program</vh></v>
</v>
<v t="ntallen.20090323135341.1"><vh>Done</vh>
<v t="ntallen.20090422110349"><vh>Done: Service dialog callbacks</vh></v>
<v t="ntallen.20090429164601"><vh>Done: Eliminate or downgrade most nl_error outputs</vh></v>
<v t="ntallen.20090429164601.1"><vh>Done: Try to compile on 6.3.2</vh></v>
<v t="ntallen.20090430095233"><vh>Done: Create a realtime test</vh></v>
<v t="ntallen.20090211110418"><vh>Done: PtTree test program</vh></v>
<v t="ntallen.20090323135341"><vh>Done: Window Tree</vh></v>
<v t="ntallen.20090316133552.2"><vh>Done: Pane handling</vh>
<v t="ntallen.20090505142020"><vh>Figure</vh>
<v t="ntallen.20090505142020.1"><vh>PtOSContainer</vh>
<v t="ntallen.20090505142020.2"><vh>Figure_Div</vh></v>
</v>
</v>
</v>
</v>
<v t="ntallen.20090203160910.1" a="E"><vh>Object hierarchy</vh>
<v t="ntallen.20090514140929"><vh>Rendering flags</vh></v>
<v t="ntallen.20090515141753"><vh>Rendering drill</vh></v>
<v t="ntallen.20090401102408.1" a="E"><vh>plot_obj</vh>
<v t="ntallen.20090218163512.1" a="E"><vh>plot_graph</vh>
<v t="ntallen.20090219084511.4"><vh>plot_graph Properties</vh></v>
</v>
</v>
<v t="ntallen.20090218163512" a="E"><vh>RTG_Variable</vh>
<v t="ntallen.20110609114734.2138"><vh>RTG_Variable_Node</vh></v>
<v t="ntallen.20110609114734.2137" a="E"><vh>RTG_Variable_Data</vh>
<v t="ntallen.20110609114734.2139" a="E"><vh>RTG_Variable_Matrix</vh>
<v t="ntallen.20110609114734.2140"><vh>RTG_Variable_MLF</vh></v>
<v t="ntallen.20110609114734.2141" a="E"><vh>RTG_Variable_Derived</vh>
<v t="ntallen.20110609114734.2144"><vh>Strategies when using GUI to derive</vh></v>
<v t="ntallen.20110609114734.2142"><vh>RTG_Variable_Detrend</vh></v>
<v t="ntallen.20110609114734.2143"><vh>RTG_Variable_PSD</vh></v>
</v>
</v>
</v>
<v t="ntallen.20090204093154"><vh>Data Feed</vh></v>
<v t="ntallen.20090226163758"><vh>Operation</vh></v>
<v t="ntallen.20090403102636"><vh>Trends</vh></v>
</v>
<v t="ntallen.20090218164400"><vh>Figure Window</vh>
<v t="ntallen.20090219084511"><vh>Figure Properties</vh></v>
</v>
<v t="ntallen.20090219084511.1"><vh>Window Pane</vh>
<v t="ntallen.20090219084511.2"><vh>Pane Properties</vh></v>
</v>
<v t="ntallen.20090203162108"><vh>Axes</vh>
<v t="ntallen.20090203160910.2"><vh>Axes scenarios</vh></v>
<v t="ntallen.20090219084511.3"><vh>Axis properties</vh></v>
</v>
<v t="ntallen.20090218164400.1" a="E"><vh>Line</vh>
<v t="ntallen.20090219084511.5"><vh>Line Properties</vh></v>
</v>
</v>
<v t="ntallen.20090203162108.1"><vh>Photon Issues</vh>
<v t="ntallen.20090227092327"><vh>Command Line Options</vh></v>
<v t="ntallen.20090227131711"><vh>Cleanup</vh></v>
<v t="ntallen.20090204093154"></v>
<v t="ntallen.20090331165341"><vh>Rendering</vh>
<v t="ntallen.20090401155216"><vh>Root</vh></v>
<v t="ntallen.20090403102636.1"><vh>Variables</vh></v>
<v t="ntallen.20090331165341.1"><vh>Window</vh></v>
<v t="ntallen.20090331165341.2"><vh>Pane</vh></v>
<v t="ntallen.20090331165341.3"><vh>Axes</vh></v>
<v t="ntallen.20090331165341.4"><vh>Graph</vh></v>
<v t="ntallen.20090331165341.5"><vh>Line</vh></v>
</v>
<v t="ntallen.20090413114310"><vh>Visibility Changes</vh></v>
<v t="ntallen.20090519153418"><vh>Building on 6.3.2</vh></v>
</v>
<v t="ntallen.20090529113129"><vh>Configuration</vh>
<v t="ntallen.20090529113129.1"><vh>File Format</vh>
<v t="ntallen.20090529113129.2"><vh>Console</vh></v>
<v t="ntallen.20090529122349"><vh>Variable</vh></v>
<v t="ntallen.20090529113129.3"><vh>Figure</vh></v>
<v t="ntallen.20090529132820"><vh>Pane</vh></v>
<v t="ntallen.20090529132820.1"><vh>Axes</vh>
<v t="ntallen.20090529132820.2"><vh>Axis</vh></v>
</v>
<v t="ntallen.20090529132820.3"><vh>Graph</vh></v>
<v t="ntallen.20090529132820.4"><vh>Line</vh></v>
</v>
<v t="ntallen.20090602162607"><vh>Serializer</vh></v>
<v t="ntallen.20090529113129.4"><vh>Data Feed</vh></v>
<v t="ntallen.20090602153925"><vh>Parser</vh>
<v t="ntallen.20090602154813"><vh>Variable</vh></v>
</v>
<v t="ntallen.20090529113129.5"><vh>Window Size and Position</vh></v>
</v>
<v t="ntallen.20090210131028"><vh>UI</vh>
<v t="ntallen.20090210131028.1"><vh>Windows</vh>
<v t="ntallen.20090210131028.3"><vh>Console</vh>
<v t="ntallen.20090224121203"><vh>Drag and Drop</vh></v>
<v t="ntallen.20090223110548"><vh>Menu</vh></v>
<v t="ntallen.20090224102255"><vh>Variables Tab</vh></v>
<v t="ntallen.20090224102255.1"><vh>Graphs Tab</vh></v>
<v t="ntallen.20090218161257.1"><vh>Window Tab</vh>
<v t="ntallen.20090219084511"></v>
</v>
<v t="ntallen.20090224110843"><vh>X,Y Tabs</vh>
<v t="ntallen.20090219084511.6"><vh>Pane Properties</vh>
<v t="ntallen.20090219084511.2"></v>
</v>
<v t="ntallen.20090218161257.2"><vh>Axes Properties</vh>
<v t="ntallen.20090219084511.3"></v>
</v>
<v t="ntallen.20090219085744"><vh>Data Properties</vh>
<v t="ntallen.20090219084511.4"></v>
</v>
</v>
<v t="ntallen.20090219085744.1"><vh>Line Properties</vh>
<v t="ntallen.20090219084511.5"></v>
</v>
</v>
<v t="ntallen.20090210131028.2"><vh>GraphWindow</vh></v>
</v>
<v t="ntallen.20090210131028.4"><vh>Operations</vh>
<v t="ntallen.20090210131028.5"><vh>Startup</vh></v>
<v t="ntallen.20090210131028.6"><vh>Define a variable</vh></v>
<v t="ntallen.20090210131028.7"><vh>Create a new Graph Window</vh></v>
<v t="ntallen.20090210131028.8"><vh>Create a new Graph</vh></v>
<v t="ntallen.20090210131028.9"><vh>Create new axes</vh></v>
<v t="ntallen.20090210131028.10"><vh>Control graph options</vh>
<v t="ntallen.20090210131028.11"><vh>Window Properties</vh></v>
<v t="ntallen.20090210131028.12"><vh>Axes Properties</vh></v>
<v t="ntallen.20090210131028.13"><vh>Line Properties</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ntallen.20070404221945.4"><vh>Drivers</vh>
<v t="ntallen.20110117144243.2077"><vh>General</vh></v>
<v t="ntallen.20110131090023.2079"><vh>Subbus</vh>
<v t="ntallen.20110131090023.2080"><vh>Subbusd</vh>
<v t="ntallen.20110131090023.2082"><vh>subbusd_serusb</vh></v>
<v t="ntallen.20110131090023.2083"><vh>subbusd_sc104</vh></v>
</v>
<v t="ntallen.20110131090023.2081"><vh>libsubbus</vh></v>
<v t="ntallen.20070404221945.5"><vh>Subbus Old Implementation</vh></v>
</v>
<v t="ntallen.20070404221945.6"><vh>SCDC/DCCC</vh></v>
<v t="ntallen.20070404221945.7"><vh>Indexer</vh>
<v t="ntallen.20091015133220"><vh>Define command protocol</vh></v>
<v t="ntallen.20090804144000"><vh>IntServ</vh>
<v t="ntallen.20090810133013"><vh>Separate Process</vh></v>
</v>
</v>
<v t="ntallen.20070404221945.8"><vh>Thompson?</vh></v>
<v t="ntallen.20070404221945.9"><vh>dacache</vh></v>
<v t="ntallen.20091112115242.1993"><vh>hart</vh>
<v t="ntallen.20091112115242.1994"><vh>gpib232</vh>
<v t="ntallen.20091112115242.1995"><vh>gpib232_init</vh></v>
<v t="ntallen.20091112115242.1996"><vh>gpib232_cmd( const char *cmd )</vh></v>
<v t="ntallen.20091112115242.1997"><vh>gpib232_cmd_read( const char *cmd, char *rep, int nb)</vh></v>
<v t="ntallen.20091112115242.1998"><vh>gpib232_write( int addr, const char *cmd )</vh></v>
<v t="ntallen.20091112115242.1999"><vh>gpib232_write_read( addr, cmd, rep, nb )</vh></v>
</v>
</v>
</v>
<v t="ntallen.20070323134835"><vh>Resmgr Notes</vh>
<v t="ntallen.20070323134835.1"><vh>resmgr_attach()</vh>
<v t="ntallen.20080625171218"><vh>Meta</vh>
<v t="ntallen.20080630113952"><vh>DG_dispatch</vh></v>
<v t="ntallen.20080626163820"><vh>device semantics</vh></v>
</v>
<v t="ntallen.20070323134835.2"><vh>dispatch_t *dpp</vh></v>
<v t="ntallen.20070323134835.3"><vh>resmgr_attr_t resmgr_attr</vh></v>
<v t="ntallen.20070323134835.4"><vh>path</vh></v>
<v t="ntallen.20070323134835.5"><vh>iofunc_attr_t handle</vh>
<v t="ntallen.20070323134835.6"><vh>iofunc_mount_t mountpoint</vh></v>
</v>
</v>
<v t="ntallen.20070330134656.4"><vh>OCB</vh></v>
<v t="ntallen.20070330134656.5"><vh>Strategy for multiple readers</vh></v>
</v>
<v t="ntallen.20070817133522"><vh>Documentation</vh>
<v t="ntallen.20070817133522.1"><vh>QNX4</vh>
<v t="ntallen.20070817133522.2"><vh>DG</vh></v>
</v>
<v t="ntallen.20070817133522.3"><vh>QNX6</vh>
<v t="ntallen.20071127160602"></v>
<v t="ntallen.20110102095209.2061"><vh>cmdgen</vh></v>
<v t="ntallen.20080716155154"><vh>DataQueue.h</vh>
<v t="ntallen.20080716155154.1"><vh>DG.h</vh>
<v t="ntallen.20080716155154.2"><vh>Collector.h</vh></v>
<v t="ntallen.20080716155154.3"><vh>Extractor.h</vh></v>
</v>
<v t="ntallen.20080716155154.4"><vh>DC.h</vh>
<v t="ntallen.20080720213239"><vh>Simple Data Client</vh></v>
<v t="ntallen.20080720213239.1"><vh>Photon Data Client</vh></v>
<v t="ntallen.20080720213239.2"><vh>Data Client with Command Interface</vh></v>
</v>
</v>
<v t="ntallen.20070817133522.4"><vh>DC</vh></v>
<v t="ntallen.20070817133522.5"></v>
</v>
</v>
<v t="ntallen.20110211111845.2089"><vh>QNX6 Sys Admin</vh>
<v t="ntallen.20110211111845.2090"><vh>mkrtkit</vh>
<v t="ntallen.20110211111845.2091"><vh>Version Numbering</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20070319130904">@nocolor
</t>
<t tx="ntallen.20070319130904.1"></t>
<t tx="ntallen.20070319130904.10">Reads data from TMbfr and outputs it in some format. Generally does not process commands.</t>
<t tx="ntallen.20070319130904.11">Reads data from TMbfr and sends commands. Should receive any command info via TM stream.</t>
<t tx="ntallen.20070319130904.12">The command architecture consists of Command Sources, the central Command Server and Command Receivers.
Command Sources include algorithms and the keyboard client
Command Receivers are client programs that wish to receive commands.

The keyboard client and the command server are both compiled from the same source code generated by cmdgen that knows how to parse text commands and perform actions based on those commands. These are in turn linked with library functions (in tmlib or tmphlib?) to make appropriate executables</t>
<t tx="ntallen.20070319130904.2">Only a single writer (Data Generator) is allowed.
</t>
<t tx="ntallen.20070319130904.3">Data Generators (DGs) are where telemetry data enters the system. These programs open the TMbfr for write. TMbfr is limited to a single writer, so only one DG is allowed per instrument.

DGs will create a /dev/huarp/$Experiment/DG/cmd device which will accept commands.

The DG library will need to support basic timing functions. Collection needs timing in order to build the frame. Other DGs need timing in playback modes
</t>
<t tx="ntallen.20070319130904.4">Collection is the realtime DG which collects data from the instrument. Each Collection program is instrument-specific, and is compiled from TMC code.</t>
<t tx="ntallen.20070319130904.5">The Reader reads telemetry data from log files written by lgr. rdr is not instrument-specific.
</t>
<t tx="ntallen.20070319130904.6">Inetin retrieves telemetry data from a remote system via TCP/IP.
</t>
<t tx="ntallen.20070319130904.7">Data Clients (DCs) read telemetry data from TMbfr and process it in various ways.</t>
<t tx="ntallen.20070319130904.8">The Logger (lgr) writes telemetry data to disk. It reads commands from the Command Server for 'logging suspend/resume'.
</t>
<t tx="ntallen.20070319130904.9">Display programs read telemetry data from TMbfr and display it on screen as text or graphics.
Display programs could read commands from srvr e.g. to redraw screens
</t>
<t tx="ntallen.20070320110353">Command server is experiment-specific, compiled from .cmd input by cmdgen. It accepts ASCII command sequences from clients, parses them and executes the specified code. In this version, that can include making the command available to other client programs.</t>
<t tx="ntallen.20070320121924">Defines command syntax and code to execute on command reception.
</t>
<t tx="ntallen.20070320135407">%INTERFACE &lt;node&gt;
This is the original interface type and supports all three features.

Readers are programs that wish to receive commands without setting up their own device interface.</t>
<t tx="ntallen.20070320135407.1">Will appear under /dev/huarp/$exp/cmd/$node
</t>
<t tx="ntallen.20070320135407.2">Could be combined with options.</t>
<t tx="ntallen.20070320135407.4">ASCII text, client-specific. Each message should end with a newline so it will play well with shell tools.
There will be a fixed maximum message length for all clients.
</t>
<t tx="ntallen.20070320135407.5">Will simply provide linked list with no real limit. However commands queued before a reader connects will be discarded.</t>
<t tx="ntallen.20070320140803">Each interface contains a queue
If no readers exist, no commands will be enqueued
Commands are dequeued when all current readers have received them or when the queue overflows
The first command written to the queue is numbered 1.
Queue records oldest command number and newest command number.
Each reader has a record of last command read.
</t>
<t tx="ntallen.20070320140803.1"></t>
<t tx="ntallen.20070320140803.2">Logged. Not reported back to the writer. Causes oldest command to be deleted.</t>
<t tx="ntallen.20070320140803.3">Logged. Could be reported back to writer. Command is not enqueued.</t>
<t tx="ntallen.20070320140803.4">To be reported to a reader if the queue overflowed while it was processing.</t>
<t tx="ntallen.20070320150524.1"></t>
<t tx="ntallen.20070320150524.2">Also compiled from cmdgen sources</t>
<t tx="ntallen.20070320150524.3">Does not see cmdgen source, but invokes the command server in test mode to test command syntax
</t>
<t tx="ntallen.20070320150524.4"></t>
<t tx="ntallen.20070320150524.5">%INTERFACE &lt;DG:DG/cmd&gt;
</t>
<t tx="ntallen.20070320150524.6">%INTERFACE &lt;lgr&gt;

Not using a command interface currently. Could get logging suspend/enable.
</t>
<t tx="ntallen.20070320150524.8">%INTERFACE &lt;idx64&gt;
</t>
<t tx="ntallen.20070320150524.9">%INTERFACE &lt;dccc:dccc&gt;

One.
</t>
<t tx="ntallen.20070320150841"></t>
<t tx="ntallen.20070320150841.4">I believe this is done.</t>
<t tx="ntallen.20070322130922">I used the name 'lgr' for awhile, although that was obviously confusing.
This needs to be formally renamed and cleaned up. (08-05-16)</t>
<t tx="ntallen.20070322130922.1">This is not implemented. Should use tm_dev_name() from tmlib</t>
<t tx="ntallen.20070322130922.2"></t>
<t tx="ntallen.20070322130922.3"></t>
<t tx="ntallen.20070322160353">%INTERFACE &lt;Quit&gt;

Everyone wants to get the Quit command. This one almost certainly requires multiple support, and it is written to every interface.

On exit, zero bytes are written to every interface (except DG/data interfaces) and the interfaces are closed.
The Quit interface simply provides this option to clients that have no other command requirements.
</t>
<t tx="ntallen.20070322160353.1">Examine current library for options
Usual message format includes:
    timestamp: hdr: severity: message

timestamp: Some sort of hook should be available for tweaking this. In playback, we want this to reflect the playback time, as opposed to the realtime, though we might want to mix the two. Perhaps playback time should be prefixed with something: &lt;00:00:00&gt;:

Ideally, lgr will check incoming messages to determine whether they have been properly formatted. If they don't have a timestamp, one should be added. If they don't have a header, maybe it can make one up?

Perhaps Timestamps should include the date. lgr could strip it out, but add a date stamp whenever it changes.

[[mm/dd/yyyy ]hh:mm:ss:][&lt;mm/dd/yyyy hh:mm:ss&gt;][hdr[.SEVERITY]:]message</t>
<t tx="ntallen.20070322160353.2"></t>
<t tx="ntallen.20070322160353.3">Memo cannot read commands from the command server and also accept log messages from the command server without risking a deadlock. The only command we're interested in is 'Quit.'</t>
<t tx="ntallen.20070322160353.4">Suppose I adopt the simple strategy of having Memo begin termination after at least one client has opened a connection and all clients have closed. Startup procedure would be to start Memo, then the command server, and then everything else.</t>
<t tx="ntallen.20070322180349">Monitor messages received. Figure out what the '0' command really is.
No idea, but simply terminating seems to work fine.
</t>
<t tx="ntallen.20070323134835"></t>
<t tx="ntallen.20070323134835.1"></t>
<t tx="ntallen.20070323134835.2"></t>
<t tx="ntallen.20070323134835.3">Probably common to all mountpoints
nparts_max, msg_max_size
other_func (for handling non-resource-manager messages. Probably not necessary for now)</t>
<t tx="ntallen.20070323134835.4">Unique to each mountpoint</t>
<t tx="ntallen.20070323134835.5">unique to each mountpoint
count records the number of OCBs using this attribute. zero should mean all clear
Probably want to extend to keep track of open handles for this resource.</t>
<t tx="ntallen.20070323134835.6">The mountpoint structure is where the ocb_calloc and ocb_free functions are specified. The structure is optional, so it is only needed if certain options need to be specified or if you want to extend the ocb structure. We may need to do that for TMbfr and/or the Command Server, but perhaps not for the Logger.
</t>
<t tx="ntallen.20070330134656"></t>
<t tx="ntallen.20070330134656.1">Each command receiver is a command type.
For each command type, there is a mountpoint and a command output queue.
The mountpoint is /dev/huarp/$exp/cmd/$node

    Don't maintain list of OCBs with each command. Just maintain a reference count
    OCBs still point to command. When command is serviced (written to reading client)
      the current command reference count is decremented
        If it is the first command and the reference count is zero, recycle
      the OCB's command link is pointed to the next command
      the next command's reference count is incremented
    The only time a client will block is when the command queue is empty, so then we
    can maintain a list of waiting OCBs, but we don't have to keep it with each command.
    When a new command is received, send replies to all waiting clients and remove them
    from the waiting list.
    
    We also use the resource manager library to maintain a list of clients with
    outstanding select/ionotify requests.

    In this case, OCBs need
      next_command pointer
      rcvid (to indicate blocking)
      next_ocb pointer (for blocked OCBs list)
    Command needs
      reference count
      next_command pointer
    Each mountpoint (RESMGR_HANDLE_T)
      list of blocked OCBs

    In the ocb_alloc func, point to oldest command and increment reference count
    In ocb_free, decrement reference count (and possibly release the command)</t>
<t tx="ntallen.20070330134656.3"></t>
<t tx="ntallen.20070330134656.4">Unique to each open file handle. Points to the iofunc_attr_t (so you can tell what resource you're accessing.)
May need to extend if necessary to record state for this handle.
</t>
<t tx="ntallen.20070330134656.5">In single-threaded approach:
    On write, we should queue the write, then process any pending reads on that resource
        queue the data
        reply successfully to the writer
        process pending reads
        return(_RESMGR_NOREPLY);
    On read, if data is present, reply immediately, otherwise queue:
        save ctp-&gt;rcvid
        return(_RESMGR_NOREPLY);
In multi-threaded approach:
    On read, if data is not present, block on thread-specific semaphore.
    On write, queue the write and then wake up blocked reader threads.
    This assumes readers haven't locked any structures</t>
<t tx="ntallen.20070403140218"></t>
<t tx="ntallen.20070403140218.1"></t>
<t tx="ntallen.20070403140218.2">Probably common to all mountpoints. Initialized in main()
nparts_max, msg_max_size
other_func (for handling non-resource-manager messages. Probably not necessary for now)</t>
<t tx="ntallen.20070403140218.3">Unique to each mountpoint</t>
<t tx="ntallen.20070403140218.4">unique to each mountpoint, needs to be extended to include list of blocked OCBs
#define IOFUNC_ATTR_T struct ioattr_s

Extended to include:
    blocked; // list of blocked OCBs
    commands; // list of pending commands
    next; // link to another handle

</t>
<t tx="ntallen.20070403140218.5">Defines how ocb structure is extended. Can be common to all mountpoints

The mountpoint structure is where the ocb_calloc and ocb_free functions are specified. The structure is optional, so it is only needed if certain options need to be specified or if you want to extend the ocb structure. We may need to do that for TMbfr and/or the Command Server, but perhaps not for the Logger.
</t>
<t tx="ntallen.20070404111542">Reader initializations should be combined in a function called at startup.
Calling of initialization functions is generally handled via oui. In this case, where we expect almost every command server to initialize reader interfaces, we might modify the command server oui to call a known function.

Reader initialization will look something like:
    
    IOFUNC_ATTR_T *if_indxr;
    IOFUNC_ATTR_T *if_scdc;
    
    void cis_interfaces( void ) {
      if_indxr = cmdsrvr_setup_rdr( "indxr" );
      if_scdc = cmdsrvr_setup_rdr( "scdc" );
    }
    
    { cmdsrvr_turf( if_indxr, "indexer command text" ); }

The fact that this is so formulaic suggests we could make the specification easier. Something like:
    
    %INTERFACE &lt;indxr&gt;
    %INTERFACE &lt;scdc&gt;
    
    { cmdsrvr_turf( if_indxr, "indexer command text" ); }

Allowing INTERFACE definitions on separate lines means they can be further separated into multiple files.</t>
<t tx="ntallen.20070404111542.1">Writers open the write interface in order to issue commands.

/dev/huarp/Exp/cmd/server
Maximum command length arbitrary (256)
Command messages are all ASCII, terminated by newline
One command per write()
Use an optional prefix:
    [ '[' mnemonic [ ':' [T][Q] ] ']' ] command
    '[' [ mnemonic ] ':V' version ] '\n'
mnemonic is the sender's mnemonic to be passed on to the log when command is received
</t>
<t tx="ntallen.20070404111542.2">For tmcalgo, we can play all sorts of games, but for file slurping, we need realtime feedback.
Can I return an error code and log the actual text?

Let's try for returning an error code. Server should produce the verbose error message to the log, but the client really only needs to know whether or not the command is correct.
</t>
<t tx="ntallen.20070404165230">This has been implemented and tested, and is now part of the command server library functions.
I will be using this capability in the DG code. We may find we need to add support for SELECT
in TMbfr.</t>
<t tx="ntallen.20070404165230.1">When Quit is received, run queues on all clients returning zero bytes and return zero bytes to anyone about to block. Whenever an OCB is closed, check to see how many remain open. When the number drops to zero, we can quit.</t>
<t tx="ntallen.20070404165230.2">Not clear whether this is still necessary.</t>
<t tx="ntallen.20070404221945"></t>
<t tx="ntallen.20070404221945.1"></t>
<t tx="ntallen.20070404221945.2"></t>
<t tx="ntallen.20070404221945.3"></t>
<t tx="ntallen.20070404221945.4"></t>
<t tx="ntallen.20070404221945.5">The current implementation of the subbus library is not ISR-safe, which means you cannot access the subbus library during an ISR. This will certainly be even more true as we move to a USB-based subbus.

The implication for the IntServ (and hence the Indexer driver) is that the INTA pulse cannot be issued in the ISR, so the interrupt will have to be masked.</t>
<t tx="ntallen.20070404221945.6"></t>
<t tx="ntallen.20070404221945.7">Include IntServ functionality, including IRQ#
Open command channel for read
  Use ionotify() to attach a pulse to the command channel
Use IntServ code to attach a pulse to the interrupt
  InterruptAttachEvent()
  Need a channel ID from ConnectAttach() which requires ChannelCreate()
Open TM channel for write
  Use ionotify() to attach a pulse and use non-blocking writes
  (double-checked to make sure I support ionotify() in collection)

Create a MsgReceive() loop to listen for commands or interrupts
  When an interrupt pulse arrives, invoke IntServ handler, which
    identifies the board, then calls the indexer service routine
  When command pulse arrives, read the command and execute
  When a TM pulse arrives, write current TM data

</t>
<t tx="ntallen.20070404221945.8"></t>
<t tx="ntallen.20070404221945.9">Implemented (in part) within subbusd
</t>
<t tx="ntallen.20070409132623">Flash app to display different modes of operation</t>
<t tx="ntallen.20070409132623.1"></t>
<t tx="ntallen.20070409132623.2"></t>
<t tx="ntallen.20070409132623.3"></t>
<t tx="ntallen.20070409132623.4"></t>
<t tx="ntallen.20070409132623.5"></t>
<t tx="ntallen.20070409132623.6">Data should highlight the data flow</t>
<t tx="ntallen.20070409132623.7">Command highlights the command flow</t>
<t tx="ntallen.20070409132623.8">Selecting an application displays a synopsis of its function and pointers to further information</t>
<t tx="ntallen.20070409132623.9">Memo is a special case.
Within any of the modes, selecting Memo should highlight the message links from active apps to Memo
</t>
<t tx="ntallen.20070409133739"></t>
<t tx="ntallen.20070409133739.1"></t>
<t tx="ntallen.20070409133739.2"></t>
<t tx="ntallen.20070409133739.3">Apps
DataLinks
CmdLinks
MemoLinks

For Each App and Link, need to know which configurations apply
For Apps, simply need to know which configurations
For Links, they are present if both their source and destination apps are present
Could be calculated or pre-calculated
Simplest implementation I can think of encodes object name and bit-mapped object type and configuration modes

Simpler approach is to use a different frame-range for each configuration and use layers for:
    Applications
    DataLinks
    CommandLinks
    MemoLinks

This requires no encoding</t>
<t tx="ntallen.20070411152334"></t>
<t tx="ntallen.20070413134915"></t>
<t tx="ntallen.20070413134915.1">How shall I organize the source code? I'd like to have some sort of hierarchy, but that's bucking the IDE's approach.
Let me try to lay out a hierarchy, and see if it can't work.

Each node below here will be an IDE project. If there are sub-nodes, they will be extra executables

Avoid Recursive Makes wherever possible
Use automake/autoconf
  subdir-objects option, etc.</t>
<t tx="ntallen.20070425144317">The frustrating thing is that the documentation on the Makefile conventions used clearly documents more layers than are implemented by the IDE. For any but the simplest projects, understanding the Makefile conventions is very useful, so having the two systems out of agreement makes life more complicated.

That said, I think I have figured out how to create a QNX C Project with a SECTION layer.

1: Create the Project in the IDE
2: Open a shell and delete the target processor subdirectory(ies)
3: Edit Makefile and change LIST=CPU to LIST=OS
4: run: addvariant section1 x86 o
   [ replace section1 with the desired section name(s) ]
   [ replace x86 with the appropriate processor(s) ]
   [ replace o with the appropriate variant(s) ]
5: Edit Makefile again and change LIST=OS to LIST=SECTION
   [ this step may not be necessary, but I had some problem under
     neutrino when I didn't do this... ]
6: Edit common.mk and change:

   include $(MKFILES_ROOT)/qmacros.mk

  to

   EXTRA_SILENT_VARIANTS=$(SECTION)
   include $(MKFILES_ROOT)/qmacros.mk
   NAME=$(SECTION)

7: Refresh the project in the IDE

NOTES: addvariant does nothing unless it finds LIST=OS, so if you want to add variants later, you have to make that change in the root Makefile. addvariant clearly doesn't understand sections, but it is still useful for adding the right Makefiles at each level. I'm taking advantage of the fact that addvariant *does* support the OS layer, which I don't need. I'm pretending that the section layer is an OS layer. For deeper nesting, manual intervention would be the thing to do.
</t>
<t tx="ntallen.20070425144317.1"></t>
<t tx="ntallen.20070425144317.2">Functions that pertain directly to the data acquisition system. Probably depends on nortlib.</t>
<t tx="ntallen.20070425144317.3">Data acquisition functions that depend directly on Photon. If I adopt a server-based approach, I should be able to limit the number of applications that depend directly on this library.</t>
<t tx="ntallen.20070425144317.4">General utility functions. Should be mostly portable between operating systems.</t>
<t tx="ntallen.20070430134037">Added autoconf/automake support, but turns out it isn't backwards compatible for a couple reasons:
    1. -lnort needs to be -lnortlib on QNX4. Could check for either library and take whatever is found.
    2. Lib check for compiler_init_options() returns undefined symbols on QNX4. I've added yyin.c and optstr.c to nortlib2, and perhaps they need to be back-ported to QNX4.
Fixed those two, but now running into a sed incompatability.

Trying to port recent GNU sed
need to edit bootstrap.sh
  need to add HAVE_LIMITS_H
  need to define HAVE_SYS_FILE_H
  need to add '1' to blank defines
  need to add -lunix -N1M to link step
  need to #define inline

When running configure, probably need to pass in -lunix -N1M
./configure LDFLAGS="-lunix -N1M" LD=wlink
Getting lots of "Memory exhausted" complaints from sed
</t>
<t tx="ntallen.20070501165557"></t>
<t tx="ntallen.20070501165557.1">Some flag passed to the linker to embed the library path into the executable
ld flag -rpath /usr/local/lib
LDFLAGS=-Wl,-rpath /usr/local/lib -L/usr/local/lib -ltm -lnort
CFLAGS=-I/usr/local/include
</t>
<t tx="ntallen.20070501165557.2">/dev/huarp/&lt;Exp&gt;/cmd/&lt;server&gt;</t>
<t tx="ntallen.20070501165557.3">My guess is that when CLIENT is not defined, we don't need any interface functions.
Right now, server is getting some output because DISPLAY_EOL is being invoked.</t>
<t tx="ntallen.20070501165557.4">Modify this to skip Phab. It's pretty basic:
    PtInit(NULL)
    PtWidget_t *w = tbl_window("name", w,h); // may want to select some other attributes
    // attach keyboard event to window
    PtAddFilterCallback(w, ph_EV_KEY, my_key_event, NULL);
    PtWidget_t *cmd = tbl_field( w, "cmd", x, y, w, h );
    PtWidget_t *prompt = tbl_field( w, "prompt", x, y, w, h );
    // figure out how to draw my funky prompt symbol
    // PgDrawPolygon()
    PtRealizeWidget(w);
    // phinitfunc();  // This is what did all the drawing in CRphdisp.c
    PtMainLoop();

Link with -ltmph -ltm? -lph</t>
<t tx="ntallen.20070502121159">QNX4 nortlib had nl_make_name() and nl_find_name() for building names that were then searched for.
nl_find_name() actually opened a connection. Since the connection is now an fd, the corresponding function would have to take open flags (O_RDONLY, etc.)

The QNX6 function for building a name is tm_dev_name()
The function for establishing a connection is tm_open_name( fqen, node, flags )</t>
<t tx="ntallen.20070502121159.1"></t>
<t tx="ntallen.20070502121159.2"></t>
<t tx="ntallen.20070502121159.3"></t>
<t tx="ntallen.20070502121159.4"></t>
<t tx="ntallen.20070502121159.5">Just because it should be easy to add via oui. Use nl_error() now, and that will map to memo seamlessly.</t>
<t tx="ntallen.20070502121159.6"></t>
<t tx="ntallen.20070508171951"></t>
<t tx="ntallen.20070508171951.1"></t>
<t tx="ntallen.20070508171951.2"></t>
<t tx="ntallen.20070508171951.3"></t>
<t tx="ntallen.20070508171951.4"></t>
<t tx="ntallen.20070508171951.5"></t>
<t tx="ntallen.20070508171951.6"></t>
<t tx="ntallen.20070508171951.7"></t>
<t tx="ntallen.20070509151554">given package name 'foo', oui currently looks for
  foo.oui
  $path/foo.oui
  oui/foo.oui
  $path/oui/foo.oui

where $path is a searchenv() call on INCLUDE
I'm inclined to go with:
    foo.oui
    oui/foo.oui
    $(datadir)/foo.oui
    $(datadir)/oui/foo.oui</t>
<t tx="ntallen.20070509151554.1">Do not require an interface definition if SERVER alone is defined</t>
<t tx="ntallen.20070509151554.2"></t>
<t tx="ntallen.20070509151554.3">root.cmd at least, but it needs editing</t>
<t tx="ntallen.20070509151554.4">Let's avoid including appgen.mk. Include it directly into the Makefile instead.
autotools gives explicit link instructions:
    cmdgen$(EXEEXT): $(cmdgen_OBJECTS) $(cmdgen_DEPENDENCIES)
        @rm -f cmdgen$(EXEEXT)
        $(LINK) $(cmdgen_OBJECTS) $(cmdgen_LDADD) $(LIBS)
Hence it wouldn't be unreasonable to add the appropriate usemsg and/or promote instructions
</t>
<t tx="ntallen.20070509151554.5">LDFLAGS needs -Wl,-rpath -Wl,/usr/local/lib
Need to promote, add usage</t>
<t tx="ntallen.20070524163205">What is the difference between the telemetry stream and the TM stream as returned from TMbfr?
</t>
<t tx="ntallen.20070524163205.1"></t>
<t tx="ntallen.20070524163205.11">This is an idea to facilitate more playback options. Clients that deem incomplete data to be OK could receive only occassional updates during fast forward or search operations. Certain clients are apt to be more sensitive to the complete data set, specifically algorithms that maintain state information. These would be set to receive the complete data set and would also be prevented from seeing non-monotonic data.</t>
<t tx="ntallen.20070524163205.2">Timestamps allow date/time to high precision without recording YYMMDDHHMMSS in every frame.</t>
<t tx="ntallen.20070524163205.3">App is assumed to match local definition. Can only check that MFCtr/Synch make sense releative to TM info.</t>
<t tx="ntallen.20070524163205.4">Might as well use a format similar to TMbfr's output</t>
<t tx="ntallen.20070524163205.5">Same here, although we might choose to add some sort of checksuming.

Both are currently limited to T3.
</t>
<t tx="ntallen.20070524163205.6">If Inetin and rdr use the TMbfr format, all DGs should</t>
<t tx="ntallen.20070524163205.7">TMbfr presumably will understand at least the four basic data formats, TMTYPE_DATA_T[1-4]
Should it:
    Decide based on the format which output format to use, or
    Respond to client requests in order to provide alternate formats

At the moment, I don't know that there is any motivation to provide a less compact format, except for the purpose of breaking up a long record into shorter records. A telemetry output program might need to add MFCtr and Synch to a T3 record, but that is going to be pretty rare. TMbfr should be able to promote a stream from T1 to T3 or T4 if it is capable. If it receives a T1 or T2 stream, it should perform sanity checks to make sure MFCtr and Synch agree with the spec (although these should be redundant). In T4 streams, checksum should be checked (or might be optionally checked.)</t>
<t tx="ntallen.20070524163205.8"></t>
<t tx="ntallen.20070524163205.9">There are three basic modes of operation worth considering:
    fast realtime response
    optimal batch performance
    playback regulated output
Fast realtime repsonse is desired by display programs and algorithms that need to respond to current conditions in a timely manner
Optimal batch performance delivers larger chunks of data to programs that don't need realtime response such as lgr and ext
Regulated output is used for playback or remote display to emulate realtime operation, but also support DVR controls

Playback control is a feature of the DG now, so TMbfr doesn't really know whether or not the input is regulated or not. Similarly, the DG doesn't know what sort of readers are on the TMbfr. I think it will be up to the operator and the script creators to make sure each program runs in the optimal mode for the task at hand.

    /dev/huarp/Exp/TM/DG writer interface
    /dev/huarp/Exp/TM/DCf fast reader interface
    /dev/huarp/Exp/TM/DCo optimal reader interface

In fast forward, DCf and DCo are treated essentially the same. The DG will write largish chunks of data, and they will be passed through to the readers.
</t>
<t tx="ntallen.20070525114357">/dev/huarp/$Experiment/TM/DG write only
/dev/huarp/$Experiment/TM/DCf read only
/dev/huarp/$Experiment/TM/DCo read only
</t>
<t tx="ntallen.20070525114357.1">We can initialize the MD list immediately, and each client OCB can refer to the one active empty MD and indicated that 0 TimeStamps have been processed.
Until we hear from the DG, we don't know how much buffer space to allocate in the data queue.</t>
<t tx="ntallen.20070525114357.2">When the initial configuration arrives, we can make decisions about what data format to use for output and hence what buffer dimensions to use.

If nrowminf == 1 &amp;&amp; mfc_lsb == 0 &amp;&amp; mfc_msb == 1, use T3
else if nrowminf &gt; 1, use T2
else use T1

Incoming data may always come in in T1 or T2, so we'll need to be able to translate between formats

DG initialization also includes the starting TimeStamp, so we can initialize the TS list and kick all of the client OCBs</t>
<t tx="ntallen.20070525114357.3">Data is stored in rows (i.e. smallest storage unit is a row) Actual storage size depends on TM format and choice of output format. T3  rows are shorter by 4 bytes. Data is identified by Qrow, which runs from 0 to max_Qrows-1.</t>
<t tx="ntallen.20070525114357.4">Metadata records aka MD aka dq_descriptor or dqd

Starting coordinate {
  metadata_serial_number: [might not be necessary]
  starting_Qrow: Which Qrow contains the first row of data for this block
  ref_count: How many OCBs are pointing to this record
  TS_serial_number: starts at 1
  n_Qrows: How many Qrows in this block. May wrap in queue
  MFCtr, Row: What is the MFCtr and Row index for the starting Qrow of data
  Qrows_expired: How many Qrows have been expired from this metatdata block
}

TimeStamps don't expire until all the data they pertain to expire. That way new clients can always receive the TimeStamp for the oldest data on record

A single metatdata record can be used for an extended period of time. The Qrows_expired field is used to note that rows have been expired. In each client OCB, a record is kept of which metatdata block is current and how many rows within that block have been delivered.
A Metadata record is active if it is the most recent metatdata record and hence might receive additional data

A metadata record is empty if it is inactive and all of its data records have expired (or equivalently, n_Qrows == 0)
  A MD can only be empty if all preceeding MD records are empty as well

TimeStamp Metadata records can be expired when no longer referenced by active or non-empty MD
  or perhaps we just merge old MD records so new clients can note that they did not see the
  start of data.

An empty, inactive, unreferenced MD can expire. Will only actually expire it if it is first in DQD_Queue, but will skip over empty inactive dqd's on read. Could theoretically be merged into the preceeding empty MD record by adding its number of expired rows to the preceeding MD's, but the only point would be to count rows and let incoming clients know that they have missed some data. (Note that no current clients would know what to do with that information.) Could instead maintain a global expired rows count.

To expire, dqd must meet three conditions:
    1. n_Qrows == 0
    2. ref_count == 0
    3. Must be first in DQD_Queue

These conditions might initially arise:
    1. On write, when rows are expired
    2. On read, when moving to a new dqd (dq_deref())
    3. On reader's close (dq_deref())

When a MD becomes empty (as data rows are expired) reduce ref count on associated TS. TS will expire if unreferenced.
When OCB points to new MD, update ref counts. If old MD is now empty and unreferenced, do merge check.

Before the first actual TM data arrives, there will be no queued timestamps or data records.
When the tm_info_t arrives, we can create the first timestamp record and the first MD record which references it. The MD will have n_Qrows of zero indicating that MFC, rownum, etc are not yet defined.

[We could either create a starting dq_descriptor with a flag indicating it is uninitialized, or we could wait to create it until it can be initialized (when the first data arrives) The former approach means initialization takes place in two places for no particular gain.
Well, one gain might be that we can immediately reference the current TS through the current MD, and we can immediately transmit tm_info_t. Actually, we need the 'uninitialized MD' flag whenever a new timestamp arrives, since we don't know what MFC, etc. will arrive. If n_Qrows is zero, we can modify the MFC, rownum, etc.]

When first data arrives, initialize first MD, visit any queued OCBs and link them into this record
</t>
<t tx="ntallen.20070525114357.5">next
TS_serial_number
unixtime
MFCtr
</t>
<t tx="ntallen.20070525114357.6">Which Metadata block: store as pointer
How many rows have already been processed?
Next pointer for list of pending requests

We don't advance to another metadata block until there *is* another metadata block to advance to. Even if we've processed all of the current block's data, it might be augmented in the future.

When we first start, there might not be even one metadata record, so no OCBs will point to anything.
</t>
<t tx="ntallen.20070525132754">Need provision for handling partial frame requests
Need to be able to buffer the header and at least one row so a data request for 1 byte can buffer the output data
These allocations cannot occur before the DG is initialized. But of course the DG interface needs to be ready to accept the tm_info_t structure, potentially as a partial frame. First record must be tm_info_t, so we could read it directly into a tm_hdr_t and then into tm_info.</t>
<t tx="ntallen.20070529132018">Need to differentiate between nodes
Need to maintain a list of pending reads. Should I do it here, or globally? Ideally should handle highest priority first.</t>
<t tx="ntallen.20070529132018.1">Just need to make sure only one open is allowed.</t>
<t tx="ntallen.20070529132018.2">On the writer, we need a scratch buffer for interpreting incoming messages, and we may as well use the partial buffer for this purpose.

I don't necessarily need to buffer an entire tm_msg_t. For example, if the tm_msg_t actually exceeds the size of the data queue, that wouldn't make sense. I expect that the underlying OS functionality will break a big message up into smaller messages. We need to use the partial buffer to handle this.

Partial buffer should be big enough to hold the tm_hdr_t, the largest data header (T2), and one row of data.

The smallest tm_msg_t is 10 bytes (Tstamp).
The first 6 bytes include all the information we need to determine the total message size[, but rather than waste time on multiple syscalls, read in up to 64 bytes (tm_info_t), since that will include all the info we need to decide how to proceed. Might want to modify that number upwards depending on nbrow. If it turns out most frames arrive in, say, 65 bytes, we might want to go ahead and get the whole thing.] Only need to read tm_info_t once at the beginning, so it is foolish to optimize this operation for that case. Instead, optimize for incoming data. Could adjust based on the data type actually being used (i.e. DG is probably going to use the same data type throughout, so once we've received one data block, we can guess what the future data blocks will hold.)

Rego: tm_info_t must be the first type read and will never recur, so don't need to use it as a benchmark
12 bytes will include all header data without trying to retrieve any data. Data will go elsewhere, so there is little advantage in reading it here.

Read in up to 12 bytes. If at least 4 have been read, we can check if we have all the header data we need:
    TM_TYPE_INIT: 64
    TM_TYPE_TSTAMP: 10
    TM_TYPE_DATA_T1: 6
    TM_TYPE_DATA_T2: 10
    TM_TYPE_DATA_T3: 8
    TM_TYPE_DATA_T4: 12
If we don't, note the partial frame. If we do, proceed with processing
INIT and TSTAMP processing is straightforward, since all the data is present in the message.
For Data messages, determine the actual message size and compare it to the write size


</t>
<t tx="ntallen.20070529133623">In this state, we are waiting to receive a complete header. The state information includes how many bytes are in the partial header (and may be zero) We can read up to 10 bytes if they are available. Some decisions can be made with fewer bytes read, but there is very little advantage in doing so, since no message will be less than 10 bytes.</t>
<t tx="ntallen.20070529133623.1">In this state, we have received a complete header, and may have received some data or not. All complete rows have already been entered into the data queue. [Any partial row is stored in the partial buffer.] Partial rows can be stored directly in the Data_Queue (past the end of the queue) since as writer we control that end of the queue. The size and destination of the initial read is calculated based on the current status.

If partial_data + write_size &gt;= nbrow, prepare to write data into the data queue. Copy partial data into beginning of target and read remaining fraction plus whole rows from the message.</t>
<t tx="ntallen.20070531154309">When read request arrives, determine whether it can be handled immediately. If not, block.
Whenever data arrives, check queued read requests to see if they can be satisfied. If so,
process them.

If tm_info has not been written yet, OCB will not have a dq_descriptor
</t>
<t tx="ntallen.20070531162708">Reading data into tm_info. This should only be used if we're getting tm_info in tiny bits.

process_tm_info();
As soon as tm_info has been received, we can decide what data format to output, how much buffer space to allocate and in what configuration. We can then create the first timestamp record (with the TS in the tm_info) and the first dq_descriptor, albeit with no Qrows, but refrencing the the first timestamp. Then we can check to see if any readers are waiting, and initialize them.

T1: Complete minor frames
T2: Complete rows
T3: Truncated rows

if ( mfc_lsb == 0 &amp;&amp; mfc_msb == 1 &amp;&amp; nrowminf == 1 ) use T3
else if ( nrowminf == 1 ) use T1
else use T2</t>
<t tx="ntallen.20070531163245"></t>
<t tx="ntallen.20070531163245.1">Actually may not need states per se.

If there is partial data present ( ocb-&gt;part.nbdata ) then send it
else If dqd is not set, we need to transmit the TMTYPE_INIT record
else If current dqd is done and next dqd has a new TS, transmit the new TS
else transmit from the current dqd

</t>
<t tx="ntallen.20070531163245.2">Store the size of the header we are transmitting (nbhdr) and the current offset. Use the OCB's tm_hdrs_t struct. Also buffer the data portion of the record in the buffer and set nbdata.

If offset is zero, we're just starting {
  Initialize the tm_hdrs_t and set nbhdr and nbdata
  If the entire request can be satisfied immediately {
    set up the buffers to send the data, and leave offset at zero and state at Partial Header
    return
  } else {
    copy the data into the partial buffer (and initialize it if necessary)
  }
}
set up buffers to send partial data and possibly switch to Partial Data state
</t>
<t tx="ntallen.20070531163245.3">I think this state will only be used for writer, or maybe it will be eliminated altogether.

Used when transmitting the initial tm_info struct(? how is the tstamp handled?)
</t>
<t tx="ntallen.20070531163245.4">Only used when transmitting a single row. All larger requests will be processed in integral numbers of rows.
</t>
<t tx="ntallen.20070601102213">On second thought... it doesn't necessarily make sense to handle playback timing in TMbfr when it could more easily be handled in the DG. The DG must already monitor the command channel to handle start/quit, and we already need to implement timing there to handle collection, so it should be fairly trivial to provide it for other DGs. In that case, there are no command requirements for TMbfr, which is as it should be.

===old discussion follows===

As discussed elsewhere, in realtime operation TMbfr will not handle any commands. It will forward all data that is written, and it will shutdown gracefully when the write stream is closed. By 'gracefully' I mean it will signal EOF to all readers, and won't actually shut down until all of the reader streams are also closed.

In playback or remote operation, it will monitor commands from the command server for data regulation, but it will not accept a QUIT command via that route because it is difficult to signal back to the DG that the channel should be closed. Instead, the DG should monitor its own command channel for QUIT.

What if the DG never starts up? cat /dev/null &gt;/dev/huarp/Exp/TM/DG
</t>
<t tx="ntallen.20070611133034">When processing data we have:
    n_rows in ocb-&gt;part.hdr.s.u.dhdr.n_rows
Determine how many complete rows we can handle in one pass from the current message
  nr = n_rows
  if ( rows_to_end_of_queue &lt; nr ) nr = rows_to_end_of_queue
  look at nbytes in the message, and limit to whole rows
Set ocb-&gt;part.nrows_receiving = nr
  n_rows -= nr
  ocb-&gt;part.nbdata = nr * nbrow?
  ocb-&gt;part.dptr = end_of_the_queue
  
When nbdata == 0, update Data_Queue with nrows_receiving new rows, then reassess status</t>
<t tx="ntallen.20070611133034.1">Copy straight in. T1 output does not include calculation of MFCtr, so there are no requirements for consecutive frames.</t>
<t tx="ntallen.20070611133034.2">Should be a straight copy, but need to verify MFCtr, Row_num
T2 output does require that frames be consecutive, so we need to read in the rows and then check them to make sure they belong with the previous records.

Hmmm. The message is guaranteed to have whole minor frames, but the segment going into the queue may not. I guess for both T1-&gt;T2 and T1-&gt;T3, the partial buffer should be big enough for a minor frame.

No, a simpler solution is to guarantee that total_Qrows is divisible by nrowminf. This solution works if and only if the input stream is consistently T1. If the DG slipped in a T2 partial frame, it would throw the whole thing off. There is no reason why a real DG would shift from one data type to another mid-stream. Maybe I should make that illegal. I could select data_state_init and data_state_eval functions once and access them via function pointers.</t>
<t tx="ntallen.20070611133034.3">Need to go row-by-row, verify MFCtr

This case requires considerable kluging.
Data will be copied into the partial buffer one row at a time, then MFCtr and SYNCH will be extracted, and the rest of the row will be copied into the queue. nb_queue and off_queue will need to be fudged before and corrected after each row.
</t>
<t tx="ntallen.20070611133034.4">Not likely. Could be illegal.</t>
<t tx="ntallen.20070611133034.5">Copy straight in, then verify continuity with previous records</t>
<t tx="ntallen.20070611133034.6">Not likely, could be illegal (i.e. T2 only applies when nrowminf &gt; 1)</t>
<t tx="ntallen.20070611133034.7">Won't happen</t>
<t tx="ntallen.20070611133034.8">Won't happen</t>
<t tx="ntallen.20070611133034.9">Copy straight in. Verify consecutive, etc.</t>
<t tx="ntallen.20070612165620">Can leave io_write in several states:
    Processed entire message and complete record
    Processed entire message, partial record
    Not done processing message (queue is full, writer is blocked)
</t>
<t tx="ntallen.20070612165620.1">Write a DG synthesizer to exercise different modes of operation.
Take tm.dac or text definition file as input
Allow override of output data format
Introduce scripted gaps, etc.

DC receiver (perhaps similar to lgr) to log the data as it comes in, perhaps taking it back to raw format or just reporting the pertinent info about the data. Could report contiguous rows and cksum, for example. Use a common summary library.</t>
<t tx="ntallen.20070612220750">Save state across invocations.
 States include
  HEADER
    ocb-&gt;part.nbdata bytes expected to ocb-&gt;part.dptr
  INFO
    ocb-&gt;part.nbdata bytes expected to ocb-&gt;part.dptr
  DATA

also
  ocb-&gt;write.rcvid // writer
  ocb-&gt;write.msgsize // bytes remaining in message
  ocb-&gt;write.msgoffset // offset within message

DATA state is challenging because we have the data record, the message
and the target queue buffer that may all be overlapping in odd ways.
If we come to the end of the record (nb_rec == 0) we go back to
the HEADER state. If we come to the end of the message (
ocb-&gt;write.msgsize == 0 ) we unblock the writer. If we come to the end
of the queue space, (nb_queue == 0) we try to find some more (If the
queue isn't full, proceed with the next block. If it is full and we're
non-blocking, then expire enough rows to hold the rest of the message

io_write( nb_msg ) {
  assert( ocb-&gt;part.nbdata &gt; 0 ); // ??
  while (msgsize &gt; 0 &amp;&amp; nbdata &gt; 0) {
    read min(nbdata,msgsize) to ocb-&gt;part.dptr
    update nb_msg, off_msg, nbdata, dptr
    if ( state == DATA ) {
      update nb_rec, off_rec, nb_queue, off_queue
    }
    if (nbdata == 0) {
      switch ( state ) {
        case HEADER:
          process_header
          switch (hdr.tm_type) {
            case TMTYPE_INIT:
            case TMTYPE_TSTAMP:
            case TMTYPE_DATA_*:
              initialize data state
              evaluate data state // does not actually move data
              copy data from header if necessary
          }
          setup to read more data as necessary
        case INFO:
          process_info();
          switch back to HEADER
        case DATA:
          evaluate data state
      }
    }
  }
  if (msgsize == 0) MsgReply();
  if (rows_arrived) run_read_queue();
}

initialize data state {
  nb_rec
  off_rec
  nb_msg
  off_msg
  nb_queue
  off_queue
  if T1-&gt;T3, make sure write buffer is allocated
}</t>
<t tx="ntallen.20070706110550">When data is coming in, we need to know how much of the old data has already been processed (at least in the blocking case. In the non-blocking case, we just take what we need.) Hence we need to know which reader has read the least. Probably the most efficient data structure for doing that is a heap. The min value is kept at the root, and there are two children on either side, each with values greater than or equal to the root. When a node's value changes, it can percolate up or down.

heap functionality

Each ocb records how many Qrows have been processed in the current dqd
(ocb-&gt;data.n_Qrows) There will be multiple readers for each dqd, and
we need to be able to keep track of the minimum value of
ocb-&gt;data.n_Qrows among those readers.

Events:
  ocb enters dqd
    increment reference count
    enter ocb's n_Qrows into the heap and adjust
  ocb reads some data
    n_Qrows increases, so adjust heap
  ocb leaves dqd
    decrement reference count
    remove ocb's n_Qrows from the heap and adjust

0 root
1          2
3     4    5      6
7  8  9 10 11 12  13  14

children are 2n+1 and 2n+2
parent is (n-1)/2

Each ocb needs to know it's position in the heap.
Any adjustment of the heap needs to 

Shouldn't bother with heap overhead in nonblocking case. The
decision can be made on the first write.
</t>
<t tx="ntallen.20070815151915"></t>
<t tx="ntallen.20070815151915.1">cmdgen is compiled and tested
tmlib has appropriate functions to generate a cmdsrvr
  I *think* tmlib has functional cmd client functions (command senders)
tmphlib has functions to support a keyboard client
appgen supports building


</t>
<t tx="ntallen.20070815151915.2">TMbfr is operational. Will need further work to support memo, additional data formats
tmc is functional.
DG_data.cc: done
lgr: done
rdr: Needs more options
ssp: done
qcli: done
subbus: done
</t>
<t tx="ntallen.20070815151915.3">For setuid root, need to link with -rpath to find .so in /usr/local/lib:
    LDFLAGS=-Wl,-rpath -Wl,/usr/local/lib

Get a lot of unresolved symbol errors when linking c++ stuff. Apparently necessary to get all the options straight. Now using:
    VER=3.3.5
    TGT=-V$(VER),gcc_ntox86_cpp -lang-c++
    CFLAGS=$(TGT) -I... -Wall -g
    LDFLAGS=-L... -M
    LIBS=-ltm -lnort

and the make rule for the binary:
    cc $(CFLAGS) $(LDFLAGS) -o name $(OBJS) $(LIBS)
</t>
<t tx="ntallen.20070817133522"></t>
<t tx="ntallen.20070817133522.1">Original design documentation for DRing operation is lost: it was in agenda format and never extracted. But we've got the source code!</t>
<t tx="ntallen.20070817133522.2">These functions are all provided by colmain.skel. Non-tmc DGs probably have hand-crafted versions.

main() {
  oui_init_options() -&gt; DG_init();
  DG_operate() -&gt; DG_other(), DG_get_data(), DG_s_data();
}
DG_DAScmd()
DG_other() -&gt; Collect_row()
DG_get_data() -&gt; DG_s_data(), DG_s_tstamp()
Collect_row()

</t>
<t tx="ntallen.20070817133522.3">Doxygen set up to run in QNX6 directory. Simply run "doxygen" in the QNX6 directory. Output goes into ../doc/html etc.

Note here items that need more documentation.
</t>
<t tx="ntallen.20070817133522.4">library functions:
    TM_read_stream() Opens fd and reads until EOF. Calls:
        TM_quit()
        TM_data() -&gt; TM_row()
        TM_init()
        TM_tstamp()
    Default versions of all of these exist that essentially do nothing.
</t>
<t tx="ntallen.20070817133522.5">DG needs a command channel to support:
    Telemetry Start
    Quit
Some DGs could probably get by without any commands (rdr could auto-start end on EOF) but collection definitely needs to receive commands and data.

Options:
    autostart: Don't wait for 'Telemetry Start' command
    regulate: Request rows based on time regulation (and possibly support speed commands)
    collect: Fill in MFCtr and Synch before calling TM_DG_Get_Data
</t>
<t tx="ntallen.20070820135203">The basic loop will require waiting for:
    Timing pulse
    Incoming commands: use ionotify() to have these send a pulse as well
When the Timing pulse comes in, a row of data is collected and written to TMbfr.
The library could provide a template and fill in the MFCtr and Synch

Could in fact have the writer and reader in separate threads from ctrl and
use semaphores to control execution.

First-cut Ctrl thread uses a timer pulse and MsgReceive() to regulate timing.

Second-cut Ctrl thread reads from /dev/huarp/$Experiment/cmd/DG using ionotify()
to get a pulse delivered as well. Same MsgReceive() loop.

Third-cut Ctrl thread is a resource manager /dev/huarp/$Experiment/DG/$vargroup
to support input from other processes.
</t>
<t tx="ntallen.20070820135203.1">Timing

rdr:
    Get the entire frame from the file, then need to perform sanity checks
inetin:
    Get the entire frame in stream format or QNX4 format, then perform sanity checks before forwarding
</t>
<t tx="ntallen.20070822162630">Can operate full throttle (extraction) or time-regulated (playback)

service_row_timer() {
  transmit_data( single_row );
  fill_buffer()
}

Start a separate thread
full_throttle() {
  while ( started ) {
    fill_buffer();
    transmit_data( 0 );
  }
}
  </t>
<t tx="ntallen.20070822162630.1">Generally operates with local time regulation to absorb any network delays. Incoming data would be placed in a circular buffer and then shipped off to the TMbfr according to the appropriate timing.</t>
<t tx="ntallen.20070823131008">Review the overall architecture again

DG could be implemented as a single thread with an appropriately designed event loop. However, this requires all external I/O to be recast in terms of non-blocking calls with select/ionotify signalling. Some of this can be simplified by breaking into separate threads, but it's worth considering the cost/benefit.

Collection might be a case where three threads is overkill. Two may be plenty, and one may actually be enough. Perhaps going to more threads should be an option, not a requirement.

Collection as single thread:
    on timer pulse, collect the row and transmit it to TMbfr
Collection as three threads:
    on timer pulse, post to semaphore
    writer thread awakes and collects the row, then posts to reader thread
    reader thread awakes and writes to TMbfr

Multi-threaded approaches might be helpful in non-collection cases:
    rdr/extraction: having a separate thread to read and forward data leaves the control thread free to accept commands and gracefully exit.
    rdr/playback: During regulated playback, having the DQwriter as a separate thread and queuing can guarantee smooth operation. During fast forward, DQreader is apt to block on TMbfr, so it should be in a separate thread.
    Inetin/Serin: Three thread design gives most flexibility

I think I need to rethink the core of the data_queue and make these various incarnations sub classes.
------------------------------------------
Probably very similar to TMbfr, except with only one writer and one reader. This simplifies certain things. We don't have to keep track of how many clients have processed a given row.

I have divided the functionality into writer and reader in order to avoid blocking except under controlled circumstances. Writing data to TMbfr is a potentially time-consuming operation. Collection will certainly use the O_NONBLOCK option, but even so, it would be preferable if collection operations were not held up for all the processing required on the TMbfr end. If we put the DG writer and reader functions in separate threads, the reader thread can tolerate the delay while the writer thread continues to process collection operations.

May actually make more sense to break into three threads: Control, assemble and transmit.

DataQueue will be accessed by three threads: control, writer/assembler and reader/transmitter. DataQueue regulates the flow of data through the DG and also supports timing functions. Access to the DataQueue internals is regulated by a mutex.</t>
<t tx="ntallen.20070823131008.1">The DG Writer is the place where all customization takes place. Each DG should create a subclass of DataQueue, overriding a handful of functions including:
    Collect_Rows()
A single object of the subclass should be instantiated and initialized, and then the control_thread() should be invoked. The initialization must define the global tm_info (so the reader thread can properly initialize the connection to TMbfr. It should also define wr_rows_requested, which will be a constant throughout the operation.

    It might be argued that there are cases where the initialization of tm_info might be delayed (Inetin, for example) but I think we're better off discounting that option.</t>
<t tx="ntallen.20070823131008.2">Returns when the space and time is right to collect or transmit more data. For collection, will block on a semaphore waiting for a timing pulse, then verify that space is available in the queue. For other DGs, will block on the queue semaphore.

This routine may block pending forwarding data to TMbfr or a collection timer.
optionally die or do something else that is drastic in the collection case</t>
<t tx="ntallen.20070823131008.3">This is always a non-blocking operation, since the space is already allocated. It may very well kick the reader thread into operation.

Certify rows that have already been written into allocated rows of the DQ. Will perform basic sanity checks. In the case of optimized output formats (T2,T3), will automatically identify the need for new DQD headers (i.e. for missing rows). Note that this function cannot provide missing time stamps; the writer must handle that.

Note that for collection, we will never require a new DQD header except when the timestamp changes</t>
<t tx="ntallen.20070823131008.4"></t>
<t tx="ntallen.20070823131008.5"></t>
<t tx="ntallen.20070823131008.6">Who calls this function? What determines the value n_rows?

n_rows specifies the number of rows to transmit. Actual rows transmitted will be the minimum of:
    n_rows
    rows available in DQD if not the current DQD
timestamps will be transmitted as necessary

Operation may block on a semaphore waiting for or optionally register a pulse to be sent when data becomes available.
    blocking is appropriate for:
        collection
        rdr/extraction w/o any commanding
    pulses are appropriate for non-collection DGs where either commandability or timing is required:
        rdr/playback
        inetin

Need to determine when to unblock/send pulse. Probably when the minimum request requirement is filled.
</t>
<t tx="ntallen.20071127160602">Need to reinstall the development system on desktop
First, make sure everything important is backed up somewhere. Most of the software is already in CVS, so it's just a matter of checking in, but check other directories. Then do the install from CD.

Currently running 6.3.2 Neutrino Host.</t>
<t tx="ntallen.20071127160602.1">/home/nort/work/opt saved to bottesini:QNX6/opt.tar.gz

bsp-x86-bios-1.0.0-20060551018-qnx6.sh: probably not needed
ide-4.0.1-20070810000-nto.sh: probably not needed
ml403_81_1.0.0_project.zip
</t>
<t tx="ntallen.20071204104659">Installing 6.3.2 from CD using my new perpetual license (Email 11/27/2007, Printed and filed)
Installed ssh from the 6.3.1 repository
Installed:
    pkgsrc_qnxutil-0.13.tar.gz (I think)
    bootstrap-pkgsrc-QNX-6.3.2-x86-20071009.tar.gz
Updated configuration as per the wiki doc:
    Added /usr/pkg/bin:/usr/pkg/sbin to PATH
    Added /usr/pkg/lib to CS_LIBPATH via setconf in /etc/rc.d/rc.local
    Set default compiler via: qcc -V 3.3.5,gcc_ntox86 -set-default
        (use qcc -V to see the current default)
Checked out pkgsrc/HEAD
Built:
    autoconf
    automake
    m4
    bzip2
    perl5.8.8
    libtool
    gtexinfo
    sudo (non-pkgsrc)
    nortutil
    nortlib
    cmdgen
    tmlib
    tmphlib
    oui
Still Want/need:
    man: can I port from OpenBSD? Linux?
    
</t>
<t tx="ntallen.20080516115802">Needs to use tm_dev_name() to set up name
Needs to provide time stamping, but perhaps not in playback mode?
Can memo use the msg() library?
Add additional functionality shown below:

Need appropriate library support to tie into nl_error
msg() drop-in replacement for nl_error. Uses msg_hdr prefix, adds severity info
Needs to assemble the entire message into a buffer before sending to memo

I think the time-stamping should take place in the msg() library function. That way if the output is redirected, it retains timestamp info. memo should add timestamp if one is not present

Format of messages to memo should be standardized to allow it to interpret the results and/or filter output
Messages that do not fit the format should be augmented

(\d{2}:\d{2}:\d{2}\s+)?(\[(?:WARNING|ERROR|FATAL|INTERNAL|DEBUG \d+)\]\s+)?(?:(\w+):\s+)?(.*)$
timestamp
severity
application mnemonic
message

Continuation lines are possible, but they must start with a leading space. Memo could insert those as necessary.

msg_hdr set via msghdr_default, -h options
msg( lvl, "my message %d", args )
library adds level message, timestamp:
    00:00:00 [Severity] Hdr: my message 7

time stamps should use UTC.
</t>
<t tx="ntallen.20080516115802.1">Needs cleanup.
Needs to use tm_dev_name() during initialization.
Probably needs proper oui set for consistency.
I think the termination strategy is sound.
</t>
<t tx="ntallen.20080516131227">DG modes:
    
Writer (DG) can specify O_NONBLOCK to signal realtime (i.e. Collection). The significance of O_NONBLOCK is that rows in the TMbfr will be discarded if the clients do not read fast enough. Without O_NONBLOCK, the DG can block waiting for the clients to drain the buffer.

Collection will always specify O_NONBLOCK, except possibly during debugging. Recording the data at the correct rate and logging it is more important than displaying it in realtime. Clients will detect the loss of data and can note it for system tuning.

rdr and Inetin, not being the original collectors, will not usually specify O_NONBLOCK, since they have more leeway with their timing. Again, there may be reason to specify O_NONBLOCK during testing.
</t>
<t tx="ntallen.20080516131227.1">There are two device nodes for reading:
    /dev/huarp/Exp/TM/DCf fast reader interface
    /dev/huarp/Exp/TM/DCo optimal reader interface
    
When reading from the DCf node, a read() operation will return as soon as there is any data ready (although it will return as much data as possible based on the request). disp and algo programs will usually read from DCf.

When reading from DCo, the reader will block until their request is complete. Assuming the request buffer is large, this should involve fewer context switches. This mode is appropriate for lgr or ext programs which have no realtime requirements.</t>
<t tx="ntallen.20080516132543">Reads from one TMbfr and writes to another. Might be the recommended way to run display on another node.</t>
<t tx="ntallen.20080519132626"></t>
<t tx="ntallen.20080623133120">The DataQueue will use two semaphores to help facilitate communication between the threads.

The reader will block on the read_sem, with posts originating either from control or the write thread, depending on the mode of operation.

The writer will block on the write_sem with posts originating either from control (for timing) or the read thread (data flow), depending on the mode of operation.</t>
<t tx="ntallen.20080624104326">
The basic idea for the DG/data/* interfaces is that each is associated with a data set. The driver opens the interface and writes whenever data is ready. Synchronization can be handled in several ways (in subnode)</t>
<t tx="ntallen.20080624104326.1">The basic idea for the DG/data/* interfaces is that each is associated with a data set. The driver opens the interface and writes whenever data is ready. Synchronization can be handled in several ways. Reading from these interfaces is undefined. ionotify and unblock will be supported. Multiple writers are not supported.

Driver interfaces to DG (only during collection) have certain common requirements:
    Define a dataset name
    Define the structure of the data written (struct) for use in the driver and DG
    Provide a stale counter functionality
    Define how the raw data should be mapped into telemetry

Since we are looking at a multi-threaded approach, the raw data area for each interface must be protected by a mutex. As such, access to that data must be controlled. In most cases, all the data from a driver will be reported at the same rate and allocated to TM variables in a block:
    Group driver ( driverStat, driverStale, DetA, DetB, DetC, DetD ) {
      //driver.lock(); // The lock/unlock methods have not been implemented 8/4/09
      driverStale = driver.stale++;
      driverStat = driver.data.status;
      DetA = driver.data.DetA;
      DetB = driver.data.DetB;
      DetC = driver.data.DetC;
      DetD = driver.data.DetD;
      //driver.unlock(); // The lock/unlock methods have not been implemented 8/4/09
      driver.synch();
    }

Sometimes we want to report at different rates or report a single value at a different rate. Would be nice to have get functions:
    DetA = driver.get_DetA;
    DetA = driver.get(driver.data.DetA); or something
It may be possible to automate this via member function templates or something</t>
<t tx="ntallen.20080624104326.2">Want to define a driver super class that encapsulates the usual stuff:
    Method for receiving data
    Method for synchronization
    Method for initialization (call library to set up the mountpoint, etc.)

This can be sub-classed with the specific data structures to be passed</t>
<t tx="ntallen.20080624104326.3">Options for driver synchronization</t>
<t tx="ntallen.20080624104326.4">Data from the write is immediately made available to collection, but the writer is blocked until an appropriate synchronization point (after the data is read into the TM frame, for example)</t>
<t tx="ntallen.20080624104326.5">If O_NONBLOCK is specified, the writer unblocks immediately. ionotify/select requests are honored, and will fire at the same synchronization point.
</t>
<t tx="ntallen.20080625152707">All DGs will use the resource manager interface to adopt
/dev/huarp/$Experiment/DG/cmd
More than one writer is fine. Reading from this interface is not defined.
I don't see any reason to support ionotify or iounblock on this interface, as we will
not enqueue requests.

###In addition, the DGs will attempt to read from /dev/huarp/$Experiment/cmd/DG if it exists.
###Data read from /dev/huarp/$Experiment/cmd/DG or written to
###/dev/huarp/$Experiment/DG/cmd are treated identically.
###Collection probably cannot read from /dev/huarp/$Experiment/cmd/DG because cmd may likely be sending to collection, so there is a risk of deadlock. Probably should dispense with that approach for the DG.

Use message_connect(dpp) to create a connection to the device's channel.</t>
<t tx="ntallen.20080625171218">One per process:
    dispatch_t *dpp = dispatch_create(); // dispatch handle
    dispatch_context_t or thread pool
    control loop
One per thread:
    dispatch_context_t* ctp = dispatch_context_alloc(dpp);
One per device or per device-type or per process, it depends:
    resmgr_connect_funcs_t connect_funcs;
    resmgr_io_funcs_t io_funcs;
One per device:
    resmgr_attr_t
    iofunc_attr_t attr;
One per open:
    iofunc_ocb_t ocb;
    
To support notify, it is necessary to expand IOFUNC_ATTR_T to include an iofunc_notify_t notify[3] element.

I think I should:
    Create a dispatch object that handles dpp and ctp
    Create a device base class to handle resmgr_attach/detach and quit processing
    Create a cmd module that handles all the command stuff
    Create a data module to handle all the driver interface stuff</t>
<t tx="ntallen.20080626163820">resmgr_attach requires a dispatch_t, so we need to instantiate the dispatch object before the devices
each device family will provide its own io_funcs and connect_funcs, but only one per family
each device that is instantiated will have an iofunc_attr_t, unique name, and call resmgr_attach()
  may want to customize nparts_max and msg_max_size</t>
<t tx="ntallen.20080627131220"></t>
<t tx="ntallen.20080627131220.1">QNX Foundation Classes--on Foundry 27
  looks to be an exhaustive C++ framework. As such, it may not be that helpful
  documentation is sketchy: mostly auto-generated using doxygen</t>
<t tx="ntallen.20080627131220.2">Subversion and also Eclipse plugin installation don't work under Neutrino due to current lack of SSL support in the JVM.
Plugins can reportedly be downloaded manually and dumped into the installation hierarchy
</t>
<t tx="ntallen.20080627131220.3">Documentation system. May be worth looking into, but may be a royal pain to build because of all the dependencies.
Then again, it's a cygwin package, so could try it out there...</t>
<t tx="ntallen.20080627131220.4">Framework for packaging and building portable source code across multiple operating systems. From NetBSD.
I used it to build a lot of tools after latest install (see Install above)</t>
<t tx="ntallen.20080630113952">This class encapsulates the main dispatch functionality at the heart of the resource manager framework. It allocates a dispatch handle via dispatch_create() and also is responsible for the main event loop. As such, it either allocates a dispatch context (the current implementation) or sets up the thread pool for a multi-threaded resource.

Any module or object that needs to be part of the main event loop (and ultimately that means any useful part of the program!) needs to hook into the dispatch handle using message_attach(), pulse_attach(), resmgr_attach() or select_attach(). In order to have an orderly shutdown, these objects also need to hook into the quit processing.

A DG_dispatch_client will provide this functionality. When the application is ready to quit (end of input, quit request received, etc.) a quit request is sent to the DG_dispatch object. It will pass the request on to each of its clients until it has no more clients, at which point, it will break out of the event loop and terminate.</t>
<t tx="ntallen.20080707135523">Standard oui processing, including initialization hooks
Initialize the interfaces
  needs some sort of hook for adding driver interfaces
Initialize connection to TMbfr
Initialize read and write semaphores
Initialize the read and write threads
main loop {
  monitor:
      timing pulses:
          calls dg-&gt;service_row_timer();
          playback: if (time-blocked) post to read_sem
      incoming commands:
          telemetry start:
              collection or playback: start timing
              extraction (or fast forward): Set mode and post to read_sem
}
</t>
<t tx="ntallen.20080707135523.1">The Read thread reads from the DataQueue and writes to TMbfr
The reader can either be time-blocked or data-blocked. In collection, the reader is always data-blocked, since the writer thread handles the timing. In all the other flavors of DG, it can be either.

ReaderModes:
    timed: block on read_sem and wait for pulse from timer
    untimed: block on read_sem when no data is available

untimed mode applies during collection, fast-forward, or extraction.
timed applies during playback at any regulated speed.

These modes can loosely be thought of as determining which thread we are waiting for (control or writer), but control can always throw in a post to indicate a change in operating mode. For example, if we're data-blocked and a quit command comes through, control will change the operating mode and post to read_sem to unblock the reader. The reader will see that there is still no data, check the operating mode and close the connection to TMbfr

We need to keep track of the selected_mode and the current_mode. The selected_mode is how we want it to work. The current_mode is how it is working at this moment. This is to address underflow during playback or relay operations. If a timing pulse arrives and there is no data available, we want to suspend timing, switch the current_mode to untimed and block again on read_sem. When data arrives, the write thread will see that we are data blocked, so it will post to the read_sem. The read threading then will resume timing

Actually, the read thread should probably initialize the timing at the beginning of playback. The control thread

On init, opens connection to TMbfr and writes initialization, then blocks on the DataQueue. Even in timed modes, the reader thread should immediately become data-blocked. When the first data arrives, if we are in a timed mode, the reader thread should then enable the timer.

In playback mode, the reader blocks on the read_sem, waiting for a timing pulse that tells it another row should go out. If the pulse arrives and there is another row ready to go, it gets shipped and the thread waits again on read_sem. If the pulse arrives and there is no data ready, the timer should be disabled and the thread switched to data-blocked. When data is available, re-enable the timer and switch back to time-blocked

When the data arrives (DQ commit_rows), if the read thread is data-blocked, post to read_sem.

There should never be multiple posts pending on the read_sem.
In playback mode, it gets timing pulses via the read_sem unless there is no data available
In collect mode, the read_sem is controlled by the writer</t>
<t tx="ntallen.20080708133047">In collection, we begin command-blocked. In other modes, we begin data-blocked</t>
<t tx="ntallen.20080708155309"></t>
<t tx="ntallen.20080708155309.1">   This structure type can be used when entire minor frames are
   being transmitted. This is true iff nrows is a multiple
   of nrowminf and the first row transmitted is the first row
   (row 0) of the minor frame. MFCtr and Synch can be extracted
   from the data that follows. data consists of n_rows * nbrow
   bytes.
   
   TMbfr will only output TMTYPE_DATA_T1 records when
   nrowminf == 1.

Applies whenever T3 or T2 do not, i.e. whenever nrowminf==1 &amp;&amp; ( mfc_lsb!=0 or mfc_msb!=1)</t>
<t tx="ntallen.20080708155309.2">   This structure type can be used to transmit rows even
   when the whole minor frame is not present since the
   mfctr and rownum of the first row are included in
   the header. Subsequent rows are guaranteed to be
   consecutive. data consists of n_rows * nbrow bytes.
   
   For practical implementation reasons, TMTYPE_DATA_T2
   will be legal only when nrowminf &gt; 1.

Applies whenever nrowminf &gt; 1
</t>
<t tx="ntallen.20080708155309.3">   This structure type can be used only in the case where
   nrowminf=1, mfc_lsb=0 and mfc_msb=1. data is compressed
   by stripping off the leading mfctr and trailing synch
   from each minor frame. Hence data consists of
   n_rows * (nbrow-4) bytes. All rows are guaranteed to
   be sequential (since there is no way to determine
   their sequence without the mfctr).

Applies whenever nrowminf=1, mfc_lsb=0 and mfc_msb=1</t>
<t tx="ntallen.20080708155309.4">   This structure type can be used under the same conditions
   as tm_data_t3_t. The difference is the inclusion of a
   cksum dword which can be used to verify the data.
   The algorithm for calculating the cksum has yet to be
   defined.
   
The T3 format lacks the synch word and MFCtr that otherwise provide a sanity check on validity of the frame. The T4 format provides a more robust validity check at a lower storage cost.
</t>
<t tx="ntallen.20080708165645">The rest of the siblings of this node are concerned with performing arbitrary translations from one tm_type to another. Most of the complexity can be eliminated by requiring that data generators always use the "right" output format. That of course pushes the complexity into e.g. a legacy rdr app, but that's probably where it belongs.</t>
<t tx="ntallen.20080708165645.1">My initial reaction is "no". The writer threads will need to be aware of the output_tm_type when they fill in the structures. The writer threads will need to do the work if necessary.</t>
<t tx="ntallen.20080709115758">
Somewhere the DG needs to define the data frame (tm_info stuff) to determine the output format.
The DG is required to produce output in the "correct" format:
    
    if (nrowminf &gt; 2) output = T2
    else if ( mfc_lsb==0 &amp;&amp; mfc_msb==1 ) output = T3
    else output = T1

Wherever input is coming from, it is the DG writer's job to make sure the output is in the correct format. This should only be an issue for legacy rdr implementations and/or QNX4 Inetin.</t>
<t tx="ntallen.20080710162929">class data_queue { // base class:
    Supports event/dispatch loop
    attaches tm_dev_name("DG/cmd");
    reads from tm_dev_name("cmd/DG");
    provides timer functionality for regulated output {
      default functionality:
      regulated: transmit one row per timer pulse
    }
    provides data queue with writer and reader functions
    provides regulated and unregulated output to TMbfr {
      transmit_data( int single_row )
      if single_row is non-zero, one row will be sent if there
      is any data in the queue. If single_row is zero, then all
      the data available in the queue will be sent. If any limits
      are set (advance to time) they are checked and may stop
      telemetry.
    }
    subclasses are charged with filling the queue
}
class collection : public data_queue {
    operation is always regulated
    time base is invariant
    communication with TMbfr is non-blocking
    output to TMbfr should be essentially unregulated {
      by which I mean the output stage should output whatever
      is in the queue. The regulation is on the input side
      of the queue.
    }
    on each timer pulse {
      get_data (collect a row)
      flush DQ to TMbfr
    }
}

class extraction : public data_queue {
    three thread implementation
    output may be regulated
    time base may be variable
    communication with TMbfr can block
    service_timer() {
   }
    create a data thread {
      unregulated operation: create a separate thread to loop:
        check for commands
        get data
        flush DQ to TMbfr
      regulated operation: create a separate thread with a semaphore
        on each timer pulse, sem_post
        On each semaphore:
            check for commands
            transmit one row
            if below low water mark, get data
      Communication from control to subthread can be synchronized via the semaphore
      Communication from subthreads to control will require a pulse (see DG_tmr)
      This is specifically required in the case of subthread termination (e.g. EOF)
      Could piggyback on the timer pulse (or not)
    }
}
</t>
<t tx="ntallen.20080710162929.1">To begin with, the control options:
    regulation_optional boolean
    rate_adjustable boolean (probably assume true if regulation_optional)
    regulated  boolean
    row_rate   rows per second
TM start:
    Set start condition
    If regulated, program timer
    else stop timer
    if ext_stop, signal handlers
TM end/stop
    Set stop condition
    stop timer
    if ext_time, signal handlers
Quit
    Set stop and quit conditions
    stop timer
    if ext_stop or ext_time, signal handlers
TM play
    if regulation_optional
      set regulated
      set row_rate to default
      if stopped, do start
      else reprogram timer
TM fast forward
    if regulation_optional
      stop timer
      set unregulated
      if stopped, do start
      else if ext_time, signal handlers
TM faster
    if regulation_optional
      if stopped
        do play
      else if regulated
        increase row_rate
        program timer
</t>
<t tx="ntallen.20080710162929.2">Not necessarily a separate thread: override service_timer() {
  get_data(); // Collect one row
  transmit_data(0);
}
</t>
<t tx="ntallen.20080710162929.3">extraction_thread() {
  for (;;) {
    lock();
    if ( quit ) {
      unlock();
      break;
    }
    if ( ! started ) {
      ot_stopped = true; // Is this necessary?
      unlock();
      sem_wait(&amp;ot_sem);
    } else {
      ot_stopped = false;
    if ( regulated ) {
      // timed loop
      ot_stopped = false;
      for (;;) {
        ot_time_blocked = 1;
        unlock();
        sem_wait(&amp;ot_sem);
        lock();
        int breakout = !started || !regulated;
        unlock();
        if (breakout) break;
        transmit_data(1); // only one row
        if (low on data) get_data();
        lock();
      }
    } else {
      // untimed loop
      for (;;) {
        int breakout = !started || regulated;
        unlock();
        if (breakout) break;
        get_data();
        transmit_data(0); // everything. Include checks for time limits?
        lock();
      }
    }
  }
  signal parent thread that we are quitting
}
</t>
<t tx="ntallen.20080715165457">Always define ROLLOVER (check the definition!)
Always define INVSYNCH (as 0 or 1) (made)
Figure out how to handle home row definition for T3 encoding
  simplest strategy is probably to adjust the pointer to point two chars ahead of the row
  need to guarantee that MFCtr and Synch are actually not written.
  Alternately, could reformulate place_home to start at offset 2
  
  place.c if TM_Output_Type == 3, start at offset 2.
  
  Should consider elminating definition of Synch in the home_row. Although we won't reference it, it is wrong.

Always generate collector::tminitfunc();
</t>
<t tx="ntallen.20080716155154">Base class for DGs and DCs. TMbfr uses a more complicated queueing structure
</t>
<t tx="ntallen.20080716155154.1">Derived from data_queue, supports data generators
All DGs:
    attach /dev/huarp/$Experiment/DG/cmd and accept commands written thereto
    open /dev/huarp/$Experiment/TM/DG and write the data stream to it</t>
<t tx="ntallen.20080716155154.2">Derived from data_generator, supports collection.</t>
<t tx="ntallen.20080716155154.3">Derived from data_generator, supports non-collection DGs (rdr, Inetin, etc.)</t>
<t tx="ntallen.20080716155154.4">Derived from data_queue? supports data clients that read from TMbfr.

Needs to read from TMbfr
For running with Photon:
    phtable produces #include "tablelib.h"
    We can test below via #ifdef TABLELIB_H
    Need a different control loop if running with Photon. Actually just tap into Photon's
    Also need to call phinitfunc(): That really needs to be generated by tmc ala tminitfunc()
        It just needs to call PtInit() and each of the &lt;table&gt;_init() functions
Otherwise
    Simply read from TMbfr until we have a block big enough to write into the queue, then
    write it. Is there any advantage in using the data_queue at all in this case? TMbfr will
    have determined the proper placement of timestamps, etc. Of course it's possible we
    might have missed some data, so local handling of that might be a good idea. What
    else could a local data_queue do for us?
    
    lgr could benefit from a local data_queue, because it does some repackaging, so it
    would like to accumulate rows until it has enough to write to disk. The data_queue
    would help determine exactly when a new dqd is required, and hence when a new header
    is required in the output file.
    
    However, in a generic client, you cannot instantiate the data_queue until your know
    the frame dimensions</t>
<t tx="ntallen.20080716230618">Existing algorithm does not do the right thing in certain odd cases.
If the data rate is n/d mf/sec and there are M minor frames per major frame
and n does not divide M, we could run into trouble.
If we choose our rollover point R to be a multiple of both M and n, that
will also work. That would be a multiple of lcm(M,n), ideally the
largest multiple less than 2^16. R = a*lcm(M,n) &lt; 2^16 so choose
a = floor(2^16/lcm(M,n)) or
R = floor(2^16/lcm(M,n))*lcm(M,n)
Then R is a multiple of M and n, and Rd = a*n*d
which is a multiple of n and hence an even number of seconds.

Since we have traditional stuck to powers of 2 (4 Hz, 8 Hz, etc.)
this hasn't been an issue.

In the truly rare case that lcm(M,n) &gt;&gt; M or n, we could gain more
flexibility by not insisting that the timestamp reference MFCtr value
start at zero. This approach is:

    Normal implicit timestamp update without wrapping. In this case,
    we don't want to change m (the current MFCtr), we just want to
    update the timestamp, (t1,m1), such that the calculated time
    does not change over the transition. Hence
      t = (m-m0)*d/n + t0 = (m-m1)*d/n + t1
      nt = d(m-m0) +n*t0 = d(m-m1) + n*t1
      d(m1-m0) = n(t1-t0)
    Since n divides the right hand side, it also divides the left
    hand side, and since n and d are relatively prime, n|(m1-m0).
    Hence if n|m0, then n|m1:
         q = floor((m-m0)/n)
        m1 = m0+q*n
        t1 = d*(m1-m0)/n = d*q
    
    Normal implicit timestamp with wrapping: Same conditions apply,
    but now we are in fact modifying m to m*. Need to preserve Major
    frame phase [ m%M = m*%M] as well as time phase [(m-m0)%n = (m*-m1)%n]
    
    Suppose we choose to always wrap at 2^16:

    Simple approach is to choose m* = (2^16)%lcm(M,n). This will preserve
    both phases. Under this approach, the timestamp MFCtr references will
    always be divisible by n, and we can easily reset m1 = 0 on wrap:
        m* = (2^16)%lcm(M,n)
        m1 = 0
        t1 = t0 + d(2^16 - m* - m0)/n

    In the truly rare case where lcm(M,n) is much larger than M or n (where
    M and n are both large and relatively prime) are more complex approach
    may be desirable that does not require the MFCtr references to be
    divisible by n. I will not bother to implement this scheme.
    choose m** = 2^16%M. This satisfies the first condition.
    Now dm = (2^16 - m0)%n. This is our time phase. If dm &lt;= m**, we can choose
    m1 = m*-dm, otherwise we need to increase m* by multiples of M until it is
    &gt;= dm
    
    Need m**+a*M &gt;= dm  hence a*M &gt;= dm-m** so
    
    if ( dm &lt;= m**) {
      a = floor((dm-m**)/M)
      m* = m**+a*M (new next_minor_frame)
    } else m* = m**
    m1 = m*-dm (new timestamp reference)
    t1 = t0 + d*(2^16-m* + m1 - m0)/n
    </t>
<t tx="ntallen.20080720213239">Simply read from TMbfr into a large buffer and operate on what arrives

Provide a largish buffer
Function to read into the buffer and dispatch service functions when complete records are received
Different event loops can

basic_read() {
  read(bfr_fd)
  if complete, call appropriate processing function
  if leftover, move it to the front of the buffer
}

basic_loop() {
  while (!quit) {
    basic_read();
  }
}

It isn't clear to me whether a triggered read needs to read until nothing is available or what.
If we were using ionotify directly, we would call ionotify after the read and it would tell us
if there was more data ready. I guess that must be how they do it. In that case, we can do
a single read and be done.
triggered_read() {
  basic_read();
}
</t>
<t tx="ntallen.20080720213239.1">Ties into Photon's event loop. Uses ionotify to get pulses signaling data ready from TMbfr.
After that, very similar to the basic client

</t>
<t tx="ntallen.20080720213239.2">Use ionotify to read from both TMbfr and command server (lgr?)
Since the lgr has much more complicated data processing, it will probably
require it's own stuff.
</t>
<t tx="ntallen.20080724120806">In current practice under QNX4, we use da_cache (originally implemented to cache write-only values of D/A devices) as a cheap means of communicating data values between applications. Since the cache had established a presence in one locations, neither client needed to go through the hassle of becoming a server. There was a bit of a kluge involved because the addressing was arbitrary and was a little tricky to communicate between the clients.

The question at hand is how best to serve the needs of cache clients in QNX6.
Cache clients include:
    Command server (for communicating SW status values)
    Device drivers (for communicating status values and possibly retrieving control values)
    Collection (for retrieving status values to be reported)

Because the general nature of the QNX6 architecture discourages the old send/receive/reply approach, it isn't obvious how a similar cache might be implemented, so that begs the question of whether it should be implemented. There are many options:
    A: Use resmgr to establish the name, but use non-standard messaging to implement the old protocol
    B: Use resmgr to establish a single name. Writes would be encoded as before (address, length, data). Reads would deliver the entire address space every time, or could implement seek and use combine messages...
    C: Use resmgr, read a config that associates names with regions of specific sizes. Writes write the entire subregion, Reads read the entire subregion. In addition, could wait for updates and provide signals as necessary.

All of these approaches assume cache is useful and would require not only implementation, but also modifications to the Collector and/or tmc. Also to consider not using cache. For starters, all device drivers would use the standard TM Receive libary, but that leaves open the question of how the Command Server should communicate with Collection:
    D: Command server use TM Receive, but that requires we keep the current architecture where commands to DG are handled differently (via a write to DG) from commands to everyone else (handled as reads from cmd)
    E: Command server uses standard interface for DG and extends it to include data
        Downside is this would require more interpretation on the collection side, plus agreement on the names
    F: Command server uses standard interface for DG, additional (standard) interfaces for data channels. Requires tmc to be modified to recognize a different flavor of TM Receive.

I think the simplest approach is to go with D for now and consider extending to F in the long run.
</t>
<t tx="ntallen.20080724120806.1">Associates a name with a range of data
Create an object name_dev which includes all the info we need for handling interactions
object should be defined statically so modifications can be made during other initializations
create tm_dev_name(DG/data/name) as writable
option to support synchronization. If not, we'll just take writes whenever, return immediately and ionotify will always report ready. If we opt for synchronization, we must also provide an indication of the synch point. Blocking writes will take effect immediately but block until the synch point. Non-blocking writes will take effect immediately, but will not statisfy the ionotify conditions until the next synch point.
</t>
<t tx="ntallen.20080724120806.2">#include "collect.h"
send_id Col_send_init(const char *name, void *data, unsigned short size);
int Col_send(send_id sender);
int Col_send_reset(send_id sender);

For non-blocking synchronization, it's a little trickier.
 Can use select if we're just monitoring fds.
 If we're running an event loop (dispatch, photon) do what is necessary in that case.
 Those libraries provide convenience functions that do most of the work.
</t>
<t tx="ntallen.20080724120806.3"></t>
<t tx="ntallen.20080729145409">hart driver
radflt TM
BMXS driver

GSE install kit

2nd Pass:
    memo: add additional tricks, use msg() library
    tmcalgo: need some form of runtime verbosity (nl_cons stuff)
</t>
<t tx="ntallen.20080908205900">Three threads encapsulated in DG_rdr class:
    Control thread:
        uses basic DG_col operation
    Input thread:
        uses DC_rdr class to read, then blocks while allocating rows
    Output thread:
        invokes transmit_data()

DG_rdr additional attributes
  These are set by the output thread to indicate what it's waiting for. They should
  be cleared by the thread that is resetting the condition. Only one should be
  set at any time.
    #define OT_BLOCKED_STOPPED 1
    #define OT_BLOCKED_TIME 2
    #define OT_BLOCKED_DATA 3
    int ot_blocked;
    #define IT_BLOCKED_DATA 1
    bool it_data_blocked;
    sem_t ot_sem;
    sem_t it_sem;</t>
<t tx="ntallen.20080909114112">Process command line options:
    autostart/regulated (playback)
    autostart/unregulated (extraction)
        perhaps autostart should just mean autostart/unregulated, since you can interactively start otherwise
    starting time
    ending time

Startup Input and Output threads

Process incoming commands and feedback from I/O threads:
    Main loop is DG_Resmgr dispatch loop, so in order to get anything back from subthreads,
    we'll need to send a pulse.
    
    To use a pulse in this case we will hook into the dispatch loop as a DG_dispatch_client.
    
    Alternately, we could simply open a connection to the command interface and send the quit command.
    
    Telemetry Start

Review functionality in 'Commands' above.

override event()
  switch (evt) {
    case dg_event_start:
      lock();
      if (ot_blocked) {
        ot_blocked = 0;
        post(&amp;output_sem);
      unlock();
      break;
    </t>
<t tx="ntallen.20080909114112.1">Invokes DC's operate loop. Overrides:
    In the operate loop, check for quit.
    
    process_tstamp() {
      invoke commit_tstamp() if it's actually new
    }
    process_data() {
      allocate_rows(); block if zero
      commit_rows();
    }
    process_eof() {
      get the next file.
    }</t>
<t tx="ntallen.20090202133816"></t>
<t tx="ntallen.20090202133816.1">We currently have a hand-crafted doit script for tilde. It is based on the old QNX4 script, and has a certain amount of configurability built in, but it has only been utilized for tilde.</t>
<t tx="ntallen.20090202133816.2">In this configuration, we assume the experiment runs on a dedicated node. This means that the startup is configured to automatically log in as the data acquisition user ('flight'). This user should be configured to run /usr/local/sbin/flight.sh as the login shell (set in /etc/passwd).

When doit runs, we may expect to find the experiment in any one of several states:
    Idle: No sign of parent or cmdsrvr. May actually be powered off.
    Transitional: parent but no cmdsrvr
    Operational: parent and cmdsrvr


The experiment status is determined by the presence of the parent and/or cmdsrvr device interfaces (/dev/huarp/$Experiment/cmd/server). Of course there are many other components of the experiment that could be running, but without the cmdsrvr, we don't have normal basic control, so we'll consider that state 'transitional' or 'damaged'. Usually the only thing we want to do if we find the experiment in the transitional state is to shut it down completely so we can start afresh.

The basic idea of the dedicated node is that parent is essentially always running. In order to start the experiment, it is necessary to terminate the currently running parent so it will be automatically replaced by a new invocation. This is in contrast to the development node model where there is usually no parent running, and we need to start one up in order to start up the experiment.

The basic doit commands are:
    not: shut down a damaged experiment tree or prevent a booting system from starting up a new tree
    start: start up a new experiment tree and client functionality
    stop: execute an orderly shutdown of a running experiment
    wait: start up client functionality only after locating an existing experiment tree

not:
    If instrument is operational, do nothing and complain
    wait for parent
    take action to prevent the instrument from restarting
    signal current parent to quit

start:
    wait for parent
    If instrument is not running:
        take action to start up right
        signal current parent to quit
    wait for cmdsrvr, then start the rest of the client software

stop:
    If instrument is running, send "Quit" to cmdsrvr
    else complain
</t>
<t tx="ntallen.20090202133816.3">In this configuration, we assume the experiment can run on the current node and that there is no login dedicated to data acquisition.

When doit runs, we may expect to find the experiment in any one of several states:
    Idle: No sign of parent or cmdsrvr
    Transitional: parent but no cmdsrvr
    Operational: parent and cmdsrvr

The basic doit commands are:
    not: shut down a transitional tree, otherwise do nothing
    start: start up a new experiment tree and client functionality
    stop: execute an orderly shutdown of an operational experiment
    wait: start up client functionality only after locating an existing experiment tree

not:
    If instrument is running, do nothing and complain
    If parent is not running, do nothing and complain
    take action to prevent the instrument from restarting (probably unnecessary)
    signal current parent to quit

start:
    # wait for parent
    switch (state)
      Idle:
          take action to start up right
          start up flight.sh:
              If system is running photon, then pterm is probably the trick
              else try some flavor of 'on'
          start client stuff
      Transitional:
          complain and die
      Operational:
          Just start client stuff

stop:
    If instrument is operational, send "Quit" to cmdsrvr
    else complain
</t>
<t tx="ntallen.20090203160910">Priorities:
    Auto Update
    Support for multiple windows, multiple SSPs
    Hide some lines
    Axis labeling
    Zoom (ability to fix scaling)
    FFT
    Detrend

SSP data comes in matrices, e.g. 1024 x 2 or 1024 x 3. By default, when you display SSP1, you get all three channels on top of each other. What we want to do is be able to deselect specific lines.</t>
<t tx="ntallen.20090203160910.1">variable
plot_obj
  figure
  axes
  line (rename to 'data')
  polyline (rename to 'line')

plot_obj's can form an arbitrary tree hierarchy, but there are some rules.
The root of a hierarchy should be a figure
Axes are the only allowed as direct children of figure, but that could be augmented
with other containers, such as panels.
Axes have one or more line children
Lines have one or more polyline children
polylines have one or more polyline widgets

Extensions:
    line object contains x,y for a single variable (may include multiple lines of same length)
    currently does not include a variable name
    currently does not allow display on more than one set of axes
    
    inasmuch as a line is associate with graphing, we can expect that it will come to include
    information about how to graph the line (line type, symbol type, whether to suppress display
     of an individual column) and this should be different if the data is displayed in more
     than one set of axes, there should be a separation. Actually, most of that info should
     live in the polyline objects, but the line still refers to the axes pair where the data
     is displayed, so I think ...

plot_obj : polymorphic superclass
    Attributes:
        type  (po_figure, po_axes, po_line, po_poly, po_text, po_zoom, po_max)
        first, last, next: children
    Methods:
        add_child
        plot(x,y)
        virtual plot(y)
        virtual render()
        virtual callback()

figure : public plot_obj
  A figure is a window which may contain one or more axes. Creating a figure currently
  creates a new window. If you already have a window and you want to add axes to it,
  or begin with a non-standard size, you'd have to extend the constructor.
    Attributes:
        window
        size
        current_axes
    Methods:
        figure();
        figaxes() creates default axes
        plot(), render(), callback()

axes : public plot_obj
  axes define the graphing area for the data points. The initial default is for the axes to
  take up the entire figure area, which is the entire window. This definition should be
  refined so that the axes area includes area required by the labels and a graphing
  area should be carved out of that. Axis labels might be sub-objects or might just be
  attributes of the axes.
  
  axes have line children
  
    Attributes:
        fig; parent figure
        area; location of axes within figure
        xscale, yscale
    Methods:
        plot(), callback(), [render()]
        zoom()

line : public plot_obj
  A line actually supports multiple lines as specified by one or two matrix objects (matlab-style).
  As such, it has one or more polyline objects as children
    Attributes:
        Axes
        xdata
        ydata

polyline : public plot_obj
  Polyline object supports a single graphical line, but it may be implemented by patching together
  multiple polyline widgets if necessary.</t>
<t tx="ntallen.20090203160910.2">1. Single XY axis pair.

2. Overlaying multiple axes in the same space
    We want the graphing area to end up the same, and perhaps we want either the x or y axes
    to be synched together. In this case, we would want to reserve space for axis tick marks
    and/or labels but not actually draw them.
</t>
<t tx="ntallen.20090203162108">Parent is a Window Pane
Axes currently fill their parent's area which is currently a figure which corresponds directly to a window widget.
Since any non-trivial application will require additional controls on the window, it makes sense to allow axes to use a subset of the parent's area. Possible approaches include:
    1. axes can be created with their (fixed) outer box specified (i.e. on a TM data display)
    2. axes can be created inside a panel object, which could be resized independently of the window</t>
<t tx="ntallen.20090203162108.1">Current design is missing many dynamic features.
Objects are created and displayed, but never destroyed, erased or redrawn.
When does some sort of redraw need to take place?
    When new "active" data arrives (data that is being displayed)
    When some user interaction requires a change in display
        Window/axes resize
        Zoom/change in scaling
        Select/Deselect what is displayed
        Change in color, line style

What needs to be done in order to redraw?
    Cause: Change in data
</t>
<t tx="ntallen.20090204093154">Take 2:
    Data feed defines a variable, not any graphics.
    We may use drag &amp; drop to establish certain data feeds, particularly for trend plots, but for right now and SSP, I will read from the standard command interface. Command format could be:
        MLF_File &lt;varname&gt; &lt;path&gt; &lt;n&gt;
    The window configuration, etc. is handled interactively and/or via a configuration file.

    http://www.qnx.com/developers/docs/6.3.2/photon/prog_guide/ipc.html#OtherIOMechanisms
</t>
<t tx="ntallen.20090210131028"></t>
<t tx="ntallen.20090210131028.1">On startup, open the console window:
    Empty Variables and Windows trees
    When a variable is defined, it will appear in the variable tree.
    Then it can be selected and a graph created via the menus

Console and Dialogs *could* be panes of a single window, either optionally minimized

Note that graphs, console and dialogs cannot have a window/subwindow relationship. They must be independent.

PtTree/PtDivider/PtButton
  Anchor flags apparently need to be 0 or strange things happen to the last button when the PtTree is resized
PtDivider/PtPane
  Anchor flags can be 0. left_left, right_right, top_top, bottom_bottom also works

From within PhAB, Console should be the base window. New graph windows should be created with:
    ApModuleParent(ABM_Graph, AB_NO_PARENT, NULL);
    ApCreateModule(ABM_Graph, NULL, NULL);

However, it may not make sense to use PhAB at all for the graphing windows. The graph window will consist of:
    Base Window
      PtDivider
        PtPane+

I will need to directly identify the PtPane widgets. I could play games by walking the widget hierarchy, but the fact is, I will need to explicitly create other PtPanes and other graph windows, so the only work I would save would be creating the PtDivider.
</t>
<t tx="ntallen.20090210131028.10">Separate dialog windows for:
    Window properties
    Axes properties
    Line properties
    </t>
<t tx="ntallen.20090210131028.11">lock x (to lock all x-axes)
Window location and size (set by dragging, but will need to record for stored configuration)
  win_x
  win_y
  win_dx
  win_dy
</t>
<t tx="ntallen.20090210131028.12">This set applies to X and Y independently:
    Draw axis
    Draw ticks
    Draw tick Labels
    Label axis
    Reserve tick space
    Reserve label space
    Axis color
    Tick Label Style (precision, font, size, color)
    Axis Label Style (precision, font, size, color)
    Major Tick Length (positive is outward, negative inward)
    Minor Tick Length (i.e. unlabeled ticks. Same units)
    Label Length (same units. Label is vertically centered in the space?)
    Label
    autoscale [on|off]
    min
    max
    log [on|off]
    grid [on|off]
    tickmode [auto|manual]
    ticks
    lock scale to overlapping axes [on|off]
    weight (used to decide how to </t>
<t tx="ntallen.20090210131028.13">Display [on|off]
Line Color
Line Thickness
Marker
Marker Color
Marker Size</t>
<t tx="ntallen.20090210131028.2">What about controls?
  Zoom on/x/y/off
  Detrend
  FFT
These can be handled via menus, either on the window or context menus.</t>
<t tx="ntallen.20090210131028.3">Console consists of several tabs covering all the properties
Actual tabs will be:
    Variables
    Graphs
    Window
    X (includes Pane Properties, data properties?)
    Y (includes Pane Properties, data properties?)
    Line

Pt_CB_PG_PANEL_SWITCHING
  Update new panel with current selection values
  Prevent switching to panels that are not relevant
Pt_ARG_PG_FLAGS-&gt;Pt_PG_DND
  Allow dragging panels to new windows! Love it. A little buggy. Should probably
  submit a note to the forums. If I drag a tab within the current PanelGroup, it
  sometimes disappears. As such, I might need to provide a View menu to
  re-enable the missing dialogs.

Keep track of current variable
Use menu to select where a new graph goes
How to specify which?
    Menus:
        graph current variable in new window
        graph current variable in new pane of current window
        graph current variable overlaying current axes
        graph current variable on selected axes
    Drag and Drop:
        Use ctrl, alt, shift on drop to indicate what to do?

Properties dialog has tabs for:
    Window
    Pane
    Axes(maybe X,Y separately?)
    Data
    Line

Adding variable to window creates a new pane
Adding variable to pane creates new axes overlaying existing axes with independent Y (and/or X)
Adding variable to axes uses the same scale

Should probably develop icons for:
    Variables
        Variable
    Windows
        Window
        Axes
        Data
        Line

Top Level Create items 'Variables' and 'Windows'
Top level items should not have 'visible' or 'properties' image displayed
Also can override the color scheme so these items don't change when selected
  That probably means I need both an image selector function and a
  column selector function. image selector returns -1 for the top
  level items, 0 or 1 for the 'Visible' column, 0 for Properties
  
  Column selector needs to actually take action on visibility changes
  and properties requests
</t>
<t tx="ntallen.20090210131028.4"></t>
<t tx="ntallen.20090210131028.5">On startup without preconfiguration, the console will open.

If an existing configuration is stored, it will be read in, and the necessary graphs will be created.
</t>
<t tx="ntallen.20090210131028.6">This should happen behind the scenes via IPC. A data source will connect to the application and identify the data it has to offer. I could have some internal variables available (cpu usage, disk space) or I could write separate utilities to provide these via the usual mechanism. The latter probably makes sense.</t>
<t tx="ntallen.20090210131028.7">By command on the console. New Windows are created with one pair of axes</t>
<t tx="ntallen.20090210131028.8">Drag and Drop from variable list to an axes pair.
Use ctrl-drop or something to indicate that you want new disjoint axes created.
Use something to indicate you want new overlapping axes created (defaulting to locked x-axes, separately scaled y-axes)
</t>
<t tx="ntallen.20090210131028.9">Either overlapping the current axes or underneath.
There is an obvious concept of current axes. Axes can be selected by clicking inside the axes or select the axes in the console. (selecting in the graph should select in the console)
</t>
<t tx="ntallen.20090211110324"></t>
<t tx="ntallen.20090211110324.1">Figure out how to control PtDivider from code and UI
Specifically:
    How can I set the dimensions of PtDivider children from a stored configuration?
        Try setting dimensions of child panes
    How can I override the results of a window resize?
        Default appears to have resize affect only last child. I would like something more proportional
        Test program should record the order of resize callbacks for:
            PtWindow
            PtDivider
            PtPane

Pt_CB_DIVIDER_DRAG
    Gets called with subtype 0 (Ph_EV_DRAG_INIT? Ph_EV_DRAG_START?)
    Gets called with subtype 1 (ph_EV_DRAG_MOVE? Ph_EV_DRAG_MOTION_EVENT?)
    Gets called with subtype 2 at the end</t>
<t tx="ntallen.20090211110418">Just figure out how it works</t>
<t tx="ntallen.20090211110418.1">Try out intra and interprocess drag and drop.</t>
<t tx="ntallen.20090218161257.1">aka graph window
Options include:
    Name: String
    Display_Menu: Boolean
    Visible: Boolean
    Display_Name: Boolean
    [other window display functions: allow resize, minimize, maximize]

</t>
<t tx="ntallen.20090218161257.2"></t>
<t tx="ntallen.20090218163512">Data that comes into phrtg should come in with either a timestamp or an implicit x-coordinate (e.g. sample number)
The x unit options are:
    sample number
    unix time

Hence a variable can be an NxM matrix with an optional Nx1 x-coordinate

We can have display options for unix time such as:
    seconds since midnight
    seconds before now (for trending)
    etc.
[but that information belongs elsewhere.]

Will need a list of Data objects that reference this variable. When
the data changes, the Data objects need to be notified.

Variables will be stored in a hierarchical structure mirroring the tree structure in the Variables Window
There will be a virtual base class RTG_Variable which will define what is necessary for that structure.
sub classes will include:
    RTG_Variable_Node: hierarchical element with no data but children
    RTG_Variable_Data: a node that includes data 
    RTG_Variable_MLF: MLF-File data
    RTG_Variable_Trend: Trend Data

It *may* be useful to derive from the RTG_plot_obj class, but probably not.
The root of the variable structure will be an RTG_Variable_Node

RTG_Variable_Data should include a list of Data plot objects that link to his variable
  It should also include a list of RTG_Variable_Data objects derived from this object
  (e.g. FFT)

#include &lt;photon/PtTree.h&gt;
#include &lt;list&gt;

class RTG_Variable {
  public:
    RTG_Variable(char *name);
    ~RTG_Variable();
    virtual int is_leaf();
  protected:
    RTG_Variable *Parent;
    char *name;
    PtTreeItem_t *TreeItem;
};

class RTG_Variable_Node : public RTG_Variable {
  public:
    RTG_Variable_Node(char *name);
    ~RTG_Variable_Node();
    int is_leaf() { return 0; }
    Add_Child(RTG_Variable *child);
  private:
    RTG_Variable *First;
    RTG_Variable *Next;
};

class RTG_Variable_Data : public RTG_Variable {
  public:
    int is_leaf() { return 1; }
}

class RTG_Variable_MLF : public RTG_Variable_Data {
  public:
    RTG_Variable_MLF( char *name, char *path );
};

int RTG_Variable::Find_Insert( const char *name, RTG_Variable *parent&amp;, RTG_Variable *sib&amp;, RTG_Variable *node&amp;, char *lastnode_text&amp; );
    Checks name for length and syntax
    Searches the tree and inserts internal nodes as necessary, but does not insert the leaf node,
      since that is type-dependent.
    Returns success if the named variable already exists (node points to existing variable) or if
      it can be inserted as the first child of parent (sib is NULL) or the sibling of sib.
    Will fail if:
        Name is invalid (invalid characters in nodes, length limits exceeded)
        An internal node of name conflicts with an existing variable
        The variable name conflicts with an existing internal node
</t>
<t tx="ntallen.20090218163512.1">Graph associates variable data with axes.
The new implementation will store the data in variable objects.
The plot_graph object will provide the mapping between the variables and the axes.
One variable can be displayed in one or more plot_graph objects in one or more axes.

The simplest data objects will display a single variable using the variable's x-coordinate.
    Updates to the variable will trigger updates to the data object.

Other options:
    X/Y plots with two variables
    Detrending
    FFT
    Arbitrary Functions of arbitrary variables?
</t>
<t tx="ntallen.20090218164400">aka graph window
</t>
<t tx="ntallen.20090218164400.1">Line has a Data object as parent and displays on the parent's axes.
Scaling is defined in the axes.

Actually display only if parent line is visible and Line_Visible or Symbol_Visible</t>
<t tx="ntallen.20090219084511">Options include:
    Name: String
    *Display_Name: Boolean
    Visible: Boolean
    Area: x,y,height,width (controlled by dragging, not dialog, but should be saved with configuration)
    [Pane Orientation: Vertical]
    [other window display functions: allow resize, minimize, maximize]
    [[*Background_Color: Color Should be a Pane Property]]
</t>
<t tx="ntallen.20090219084511.1">Immediate child of Window
Parent of Axes
At least one Pane per Window</t>
<t tx="ntallen.20090219084511.2">Could probably be incorporated into the Axes properties

The Title belongs with the Pane, since we can't display two titles for overlayed axes.
We may default to not displaying the pane title, instead displaying the window title.

Pane Properties:
    Synch_Axis_Range([XY]): Boolean
    Background_Color: PtColorWell (or some other selector)
    *Axes_Background_Color: PtColorWell
    Height: Maintained via drag, but needs to be recorded in saved config

    Pane_Title: The actual text (for listing on console) default to first variable name
    *Pane_Title_Height: Space to allocate (hide for now.)
    *Pane_Title_Font_Settings: whatever
    *Reserve_Pane_Title_Height: Boolean
    *Display_Pane_Title: Boolean

*May never want to display pane title on the graph</t>
<t tx="ntallen.20090219084511.3">
Axes Properties:
    Axes_Name: String Just for graphs tab. Default to first variable name. Part of plot_obj base
    Axes_Visible: Boolean

Axis Properties:
    Draw axis(0,1): Boolean
    Reserve axis tick space(0,1): Boolean
    Draw axis ticks(0,1): Boolean
    Reserve axis tick label space(0,1): Boolean
    Draw axis tick Labels(0,1): Boolean
    Label:
      *Reserve axis label space(0,1): Boolean
      *Draw axis label(0,1): Boolean
    
    *Axis color: color
    *Axis Tick Label Style: *use defaults for now
    *Axis Label Style: *use defaults for now
    *Axis Major Tick Length: int (positive is outward, negative inward)
    *Axis Minor Tick Length: int (i.e. unlabeled ticks. Same units)
    *Axis Label Height: int (same units. Label is vertically centered in the space?)
    Axis_Limit_Auto: Boolean
    Axis_Limits: float[2] min, max
    Axis_Log: Boolean (Logarithmic Scale)
    *Axis_Reverse: Boolean (Reverse the direction)

(0,1) indicates either (left,right) or (bottom,top)
    This representation allows for left, right, or both positioning of axis labels and ticks.
    In practice, a subset of options would probably apply. For example, I could decide that
    if you are going to draw one axis, you draw both. If you add tick marks, you add them
    to both. Or I could support drawing axis and tick marks together with tick labels or on
    both axes, but not say only on the opposite axis. Decoupling the 'Reserve Space' options
    from the 'Draw' options allows support for overlays, but it is probably reasonable to
    require that we only draw ticks and labels if we have reserved space for them.
</t>
<t tx="ntallen.20090219084511.4">Data Options:
    Variable: (should be fixed, defined at creation)
    Name: Default to variable's name, but may be changed
    Visible: Boolean

Other data processing possibilities may be properties of the data object
    Detrend: Boolean
    FFT (need to define the source range, probably using the current x limits)
    XY (this needs to be defined at creation somehow)
</t>
<t tx="ntallen.20090219084511.5">
Options:
    Line_Color: color (default via algorithm)
    Symbol: char? int?
    Symbol_Color: color (default via algorithm, same as Line_Color)
    Symbol_Size: int?
    Line_Visible: boolean
    Symbol_Visible: boolean
</t>
<t tx="ntallen.20090219084511.6">May not require a separate tab for these. They could be hidden inside axes properties.
</t>
<t tx="ntallen.20090219085744">Tab could be disabled if a graph is not selected
Alternately, this dialog could include a selection box to indicate which graph to edit
In which case, selecting a graph should change the selection in the console as well</t>
<t tx="ntallen.20090219085744.1">Tab could be disabled if a graph is not selected
Alternately, this dialog could include a selection box to indicate which line to edit
In which case, selecting a line should change the selection in the console as well


Options:
    Visible: boolean (inhibits display while saving configuration)
    Line_Style: select from list including none, solid [, dashed, dotted]
    Line_Color: PtColorWell color (default via algorithm)
    *Symbol: select from list including none, ., *, +
    *Symbol_Color: color (default via algorithm, same as Line_Color)
    *Symbol_Size: int?
</t>
<t tx="ntallen.20090223110548">Menus:
    graph current variable in new window
    graph current variable in new pane of current window
    graph current variable overlaying current axes
    graph current variable on selected axes
    Drag and Drop:
        Use ctrl, alt, shift on drop to indicate what to do?
    
    Once I define all the data types and have a Cur_Window, Cur_Axes, Cur_Pane, etc.,
    I will need a menu setup function to decide which menu items to enable.

  Zoom
    on Excl_Toggle
    x
    y
    off

  Data
    Detrend  toggle
    FFT      toggle
</t>
<t tx="ntallen.20090224102255">PtTree of variables
Hierarchy created by the connecting source
Plan is to use this tab to select current variable for creating graphs,
ultimately using drag and drop

Pt_CB_TREE_SELECTION
  Update current variable
</t>
<t tx="ntallen.20090224102255.1">PtTree
  PtDivider
    PtButton Name
    PtButton Visibility

Window_name
  Pane_name
    axes_name
      data_name
        line_name

We maintain:
    current_window
    current_pane
    current_axes
    current_data
    current_line

Selecting an item updates the entire hierarchy
    ancestors are unambiguous
    select first child for all descendants

Visibility keyed off one of the status bits: Pt_LIST_ITEM_FLAG_USER1
Pt_CB_TREE_COLUMN_SEL function
  If visibility is selected, notify whoever needs notifying
  If name is selected, update the list of current objects:
      set ancestors
      clear descendent types unless there is only a single child


Advanced Feature: Do this later...
Hide intermediate levels if only one child: e.g.
    Windows
      SSP1
        SSP1(:,1)
        SSP1(:,2)
        SSP1(:,3)
        
Selecting Properties for SSP1 brings up tabbed dialog with access to
all the ancestry. But how do I specify where I want a new graph to
be created?
    Dropping variable on 'Windows' creates a new window
    Dropping variable on top of SSP1 could:
        Create a new pane
        Create new axes overlay in existing pane
        Add to existing axes
        
</t>
<t tx="ntallen.20090224110843">I think these will be identical, possibly using the same container
Each Panel in the PtPanelGroup contains a PtPane. The PtPane's title is the tab's label
Try using PtReparentWidget() to switch.
Embed a second PtPane inside one of these tabs and reparent it when X or Y is selected

Pane Properties
    Pane_Title: String (for Window tab, default to first variable)
    Visible: Boolean
    Background_Color: PtColorWell (or some other selector)
    Synch_Axis_Range([XY]): Boolean
    [Height: Maintained via drag, but needs to be recorded in saved config]
    *Axes_Background_Color: PtColorWell

Axes Properties:
    Axes_Name: String Just for graphs tab. Default to first variable name
    Axes_Visible: Boolean

Axis Properties:
    Draw axis(0,1): Boolean
    Reserve axis tick space(0,1): Boolean
    Draw axis ticks(0,1): Boolean
    Reserve axis tick label space(0,1): Boolean
    Draw axis tick Labels(0,1): Boolean
    Label:
      *Reserve axis label space(0,1): Boolean
      *Draw axis label(0,1): Boolean
    
    *Axis color: color
    *Axis Tick Label Style: *use defaults for now
    *Axis Label Style: *use defaults for now
    *Axis Major Tick Length: int (positive is outward, negative inward)
    *Axis Minor Tick Length: int (i.e. unlabeled ticks. Same units)
    *Axis Label Height: int (same units. Label is vertically centered in the space?)
    Axis_Limit_Auto: Boolean
    Axis_Limits: float[2] min, max
    Axis_Log: Boolean (Logarithmic Scale)
    *Axis_Reverse: Boolean (Reverse the direction)

Data Properties: These should probably only apply to the y-axis
    Detrend: Boolean
    FFT: Boolean (need to define the source range, probably using the current x limits)
        FFT_X_Range: float[2]
</t>
<t tx="ntallen.20090224121203">    
How does dnd work for lists?
Can I drag a list item to another app?
    I think what I'll need to do is create a widget that will be the actual drag item
</t>
<t tx="ntallen.20090225110248">How is hostname handled? In /etc/net.cfg (usually via the network config tool)
/etc/system/sysinit also looks in /etc/HOSTNAME

Following pkgsrc instruction to install openssh
http://community.qnx.com/sf/wiki/do/viewPage/projects.pkgsrc/wiki/BinaryPackages

downloaded pkgsrc bootstrap bootstrap.tar.gz and installed

Installed:
    openssh
    sudo
    autoconf
      m4
      perl_5.8.8
    automake
    libtool (complaints about installing libtool-info
      libtool-base
      libiconv
      gettext-lib
    gtexinfo
    libtool-info
    
    nortutil
    nortlib
    cmdgen
    oui
    QNX6/tmlib   (TM library)
    QNX6/tmphlib (need for display programs and keyboard client programs)
    QNX6/tmpplib (C++ interface for TM) Need to eliminate CXX=cc spec
    QNX6/displib (needed for display programs generated via phtable) eliminate CXX=cc spec
    QNX6/tmutil
    QNX6/memo

    *QNX6/tmc
    *QNX6/lgr
    *QNX6/rdr
    *QNX6/tmcalgo
    *QNX6/qcliutil
    *snafu

    eli compiler tools (required for table, qclicomp?)
    
    *table
    *qclicomp (or qclicompsrc?)

    Try installing Leo, what the heck!    </t>
<t tx="ntallen.20090226163758">Upon receiving the following for the first time:
    MLF_File &lt;varname&gt; &lt;path&gt; &lt;n&gt;
The application will:
    Create a new variable of the specified name and type (MLF_File in this case)
        Update the variables hierarchy and ultimately update the display
        Name can be hierarchical
    Mark the variable as requiring a reload, but don't actually load the file

</t>
<t tx="ntallen.20090227092327">I can probably get away without using any, but:
    The default PhAB options conflict with my usual command line set.
    It would be nice if there was a simple way to work around that.

AB_OPTIONS "s:x:y:h:w:S:"

msg_init_options claims to use -s, but it's a no-op in QNX6, since there is no sound interface.
I should remove that from the msg interface.

I will have to do the command line processing manually (not via oui) just because I don't know
how to plug in tools to the QNX windows-hosted IDE.
</t>
<t tx="ntallen.20090227131711">Use PtExit(0) to quit
Do whatever cleanup we need to do in the Destroyed callback for the console window.
</t>
<t tx="ntallen.20090227133851">Handle closing of the command channel
Recognize EOF from command channel and close it down
Close the connection explicitly during destruction

Start interpreting commands:
    MLF_File &lt;varname&gt; &lt;n&gt;
    Build the Variable structure, tied in to the variable tree.

Need to define current variable in order to support graph create commands
    Use Pt_CB_TREE_SELECTION callback:
        Should I mark internal nodes as not selectable? There does not
        appear to be such an option, so I can accept selection of
        non-variables, clear the current variable, then optionally
        call PtTreeUnselect() to show it as not selected.
        
        This works OK, and can probably stay for awhile, but I think
        there is also a GenTree option to not select... Currently the
        node is selected until after you click, which is a little
        annoying. Hmm. I don't see that option. I'll stick with this
        for now.</t>
<t tx="ntallen.20090302125256">tmlib is listing warnings.</t>
<t tx="ntallen.20090316133552"></t>
<t tx="ntallen.20090316133552.1">PtWindow
  PtDivider anchored 0x5a0
    PtPane
    PtPane

Realized
Drag the divider as the very first action,
then resize the window (larger)
PtDivider does not resize until you drag the divider again.

Resolution:
    Set Pane anchor flags to zero
    realize new pane before resizing
    set divider's anchor offsets to zero
    resize panes</t>
<t tx="ntallen.20090316133552.2">I think I have pane creation down:
    realize new pane
    reset divider's offset anchors
    resize each pane to total less than divider's size
    set each pane's minimum dimensions and window's minimum dimensions
    set dividers Cascade option so dragging handle doesn't squash panes below minimum
    record each pane's minumum height and current height

Current assumption:
    divider height matches window height (guaranteed by setting anchor offsets to zero)
    divider height equals sum of pane heights plus twice the bevel width:
        This one is proving false. When I let the divider do it's thing, the
        sum of the heights of the panes is coming out greater than the size
        of the divider. Cannot replicate in PhAB

Resizing: Two cases:
    1: drag handle
        Just want to record the change (and update scaling, etc.)
    2: Resize of window
        Go through and set pane sizes proportionally
        If new height is less than old height allocate space proportional to the sizes above minimum
        If new height is greater than old height, allocate space proportional to total size
</t>
<t tx="ntallen.20090323135341">+Select elements
+Delete elements
+Provide destructors
+figure out how to safely delete either from multiple points in the program
+e.g. closing a window will trigger deletion of the figure hierarchy, but deleting
+the figure hierarchy will trigger deletion of the window. Which comes first?

+Add a delete window command and find out whether the destroyed callback occurs.
</t>
<t tx="ntallen.20090323135341.1"></t>
<t tx="ntallen.20090325170837">Will need:
    plot_axes
    plot_data
    plot_line

Each should:
    mark self as destroying
    delete children
    remove self from parent's list of children
    set associated widget's data pointer to NULL
    save widget pointer and set widget pointer to NULL
    Clear tree node's data pointer (just to be anal)
    if parent is not destroying
      destroy associated widget if not already marked for destruction
      delete associated tree node:
        PtTreeRemoveItem()
    (else the parent will delete the widget hierarchy and the subtree)

Widget destroyed function should:
    store plot_obj
    if plot_obj != NULL:
        set data pointer to NULL
        delete plot_obj--would like to tell plot_obj that the widget is already destroyed, but that may not be possible

Deleting a pane:
    May need to do some resizing after the fact
Deleting a figure:
Deleting axes:
Deleting data:
Deleting Lines: not allowed--context_menu_setup should disable the delete option
        </t>
<t tx="ntallen.20090331140856.1">May want to include current_child pointers in each plot_obj.

When an object gets selected in the graphs tab, we call got_focus() to select it.

When a widget (currently only window or pane) gets focus, pt_got_focus gets called on the widget, and it in turn calls got_focus() for the associated plot_obj. We want to highlight the corresponding tree item in the graphs tab, but this is complicated a bit by the fact that both the window and the pane get focus. To get around this, we will only make changes if the current object is not the current object of its type (e.g. the plot_pane is not Current::Pane) For this to work, when plot_pane::got_focus() is called, it must set Current::Pane and also Current::Figure (for its parent) Assuming Photon calls pt_got_focus from the most deeply nested widget first, the plot_pane will get called first, and when the plot_figure::got_focus() is called, it will already be Current::Figure, so it will not take further action.

plot_axes, plot_data and plot_line may not have user-selectable widgets associated with them, so they may only be selected via the graphs tab. If I select axes2 in figure2, then select figure1, axes2 remains the Current::Axes, which is a little counterintuitive.

Suppose I make got_focus() take an argument with three possible values: { gf_from_user, gf_from_parent, gf_from_child }

if (this == Current::Thingy) return; // child will have already updated my current_child pointer
// This block can be handled by plot_obj::got_focus()
// Need to create a parent_obj and current_child pointers
if (whence == gf_from_user) {
  select TreeItem if not already selected
}
if (parent_obj &amp;&amp; (whence == gf_from_user || whence == gf_from_child)) {
  parent_obj-&gt;current_child = this;
  parent_obj-&gt;got_focus(gf_from_child);
}
if (whence == gf_from_user || whence == gf_from_parent) {
  if (current_child) current_child-&gt;got_focus(gf_from_parent);
  else Current::none(type);
}
Current::Thingy = this;
Update any dialogs that might need it.

This approach has a shortcoming if one object has no children and hence no current child. If a window is selected with no panes, then Current::Pane, Current::Axes, Current::Graph and Current::Line should all be set to NULL, otherwise counterintuitive results will happen when "create graph in current pane"

Current::none(plot_obj_type type) {
  switch (type) {
    case po_figure:
      Current::Pane = NULL;
    case po_pane:
      Current::Axes = NULL;
    case po_axes:
      Current::Graph = NULL;
    case po_data:
      Current::Line = NULL;
    default:
      break;
  }
}
    </t>
<t tx="ntallen.20090331165341">Baseline render routine will recurse through the entire plot_obj hierarchy looking for work
Each call into the hierarchy should perform a single non-trivial operation and return
an indication of whether there is more work to be done.

May want to make a po_root object (except it does not have representatives in the graphs tab)

  </t>
<t tx="ntallen.20090331165341.1">Render each pane</t>
<t tx="ntallen.20090331165341.2">render each axes

When pane is resized, axes need to be redrawn, scales recalculated and lines redrawn
</t>
<t tx="ntallen.20090331165341.3">Flags:
    check limits
    recalculate scale
    redraw axes

If check limits and autoscale, check em

If axes need to be redrawn, delete the old ones and create new ones
Render each Graph
</t>
<t tx="ntallen.20090331165341.4">Flags:
    reload data
    recalculate range
    redraw

If recalculate range required, do so and mark axes as needing to recheck limits
(re)Render each line that needs redraw
If a line needs to be redrawn, unrealize it immediately to avoid redraws by Photon

When data changes (new file):
    a) Once we have started to draw a variable (loaded, etc.), do not reload it
    until all the graphs have been rendered. For MLF variables, maintain a 'next'
    number, and update that as variables come in. Once all the graphs have been
    updated, check to see if the next number has changed.

    If limits are auto, mark recalculate range
    mark [visible] lines as needing redraw
</t>
<t tx="ntallen.20090331165341.5">translate data into polylines and realize each
</t>
<t tx="ntallen.20090401102408.1">This is the virtual base class for all plot objects. Each of the real objects is derived from this.
A plot_obj is basically:

class plot_obj {
  public:
	plot_obj_type type;
	char *name;
    PtTreeItem_t *TreeItem;
    plot_obj *parent_obj;
    plot_obj *current_child;
    bool destroying;
	plot_obj( plot_obj_type po_type, const char *name_in);
	virtual ~plot_obj();
	virtual void got_focus(focus_source whence);
	void TreeAllocItem();
	const char *typetext();
};

</t>
<t tx="ntallen.20090401155216">NOTE: The current plot_obj::render_all() is actually the inner loop of root-&gt;render() depicted here
so some juggling needs to be done.

flags
  flush_required

plot_obj::render_all() {
  if (rendering) return;
  rendering = true;
  while (render_each())
    PtBkgdHandlerProcess();
  root-&gt;rendering = false;
}

int plot_obj::render_each() {
  if (RTG_Variable::reload_all()) return true;
  if (render_figures()) return true;
  if (flush_required) {
    PtFlush();
    flush_required = false;
    return true;
  }
  return plot_obj::check_vars_for_updates();
}
</t>
<t tx="ntallen.20090403102636">For trends, we can have 2 dequeues, one for current data, one for new data
When data arrives, we add it to the new dequeue and set the new_data_available flag.
On load, we transfer all the new data onto the current dequeue and optionally trim the front

As with all variables, on load, we will mark all graphs as data_changed.</t>
<t tx="ntallen.20090403102636.1"></t>
<t tx="ntallen.20090413114310">I think I want to delete widgets when objects are made invisible
Widgets involved are:
    module, PtWindow
    PtPane
    PtPolygon

This is a bit complicated when marking a figure as invisible

plot_figure:
    need to refactor the initialization where the module is created

plot_pane:
    probably need to refactor the initialization

plot_axes:
    If the axes is invisible, does that mean all the graphs are
    invisible as well? That's what I have been assuming.

plot_line:
    The creation of widgets is already handled in render, so no
    change required there.</t>
<t tx="ntallen.20090422102356.1">Makes scripting easier if creating a window does not automatically create a pane of the same name.
</t>
<t tx="ntallen.20090422102356.2">Will probably have to go to the forums again.</t>
<t tx="ntallen.20090422104622">Marking a line as visible does not redraw if data has been updated while invisible.
</t>
<t tx="ntallen.20090422110349">The plot_obj::rename() functions need to update the dialogs, but only if:
    a) The dialog is currently being displayed
    b) This plot_obj is "current"
    c) The rename originated from a source other than a callback for this field (i.e. scripting)

Same strategy for other widgets.
I've handled text widgets and color widgets.
Still need to handle:
    check boxes
    numeric (column number, limits)
    

Text callbacks are handled through Pt_CB_MODIFY_NOTIFY callback to Modify_Notify@callbacks.cc
Modify_Notify() calls Update_Text(), which can also be called from scripting tools

Color callbacks are handled through Pt_CB_CS_COLOR_CHANGED callback to Color_Changed@callbacks.cc
Color_Changed() calls Update_Color(), which can also be called from scripting tools

Checkboxes are handled through Pt_CB_ACTIVATE callback to Toggle_Activate@callbacks.cc
Toggle_Activate() calls Update_Toggle(), which can also be called from scripting tools

WORKING HERE:
Numerics are handled through Pt_CB_NUMERIC_CHANGED callback to Numeric_Changed@callbacks.cc
Numeric_Changed() calls Update_Numeric(), which can also be called from scripting tools
    That's OK for column number. For limits, back out this change and us an
    'Apply' button.
  Limits still aren't quite right.
  When auto limits are updated, need to update the tab
</t>
<t tx="ntallen.20090428171747">Still trying to sort out a rational approach for handling dialogs when creating and deleting objects

Whenever an object gets focus, the appropriate dialog needs to be updated if active

Whenever an object gets deleted, we can
  find an appropriate replacement object
  close the relevant dialog
  clear the relevant dialog

The trick comes from the fact that if we are deleting one object, we are deleting it's children as well, and there's no point in the children looking for a replacement. That should be done at the highest level of deletion. That really means that if an object is being deleted because its parent is being deleted, it should take no action with respect to the dialogs because the parent will handle it. For the top level object being deleted, this could be handled either in the descructor or in the parent's Remove_Child method. Something like

    if (current_child == child) {
      current_child = NULL;
    } else {
      nl_assert(Current::XXX != child);
    }
    remove(child);
    if (!destroying) {
      PtDestroyWidget(child-&gt;widget);
      Adjust_Panes( - child-&gt;min_height );  
      if (current_child == NULL) {
        current_child = default_child();
        if (Current::XXX == child) {
          if (current_child == NULL) Current::none(type);
          else current_child-&gt;got_focus(focus_from_parent);
        }
      }
    }

Handle the following in Current::none() {
  If no current Figure, shift away from Window, Tab_X, Tab_Y or Tab_Line
  If no current Pane, then shift away from Tab_X or Tab_Y or Tab_Line
  If no current Axes, clear the axes portions of Tab_X or Tab_Y, shift away from Tab_Line
  If no current Graph, shift away from Tab_Line
  If no current Line, shift away from Tab_Line
}
</t>
<t tx="ntallen.20090429153442"></t>
<t tx="ntallen.20090429153442.1">Had to move that code out of Current::none() into the plot_data::check_limits() where we actually read the data from the file.</t>
<t tx="ntallen.20090429164601"></t>
<t tx="ntallen.20090429164601.1">Needed to hack common.mk to include definitions for a couple things
PROJECT_ROOT
BUILDNAME=phrtg_G

Also the extra include paths are set to $QNX_TARGET/usr/local/include &amp; lib,
which works under windows. Need to add a soft link on nto
Also needed to specify additional libs: ph Ap m. Not sure why they aren't included
Would like to figure out a way to do this unobtrusively.
</t>
<t tx="ntallen.20090430095233"></t>
<t tx="ntallen.20090430131154">Linking and/or Compiling

I've been ducking this problem for awhile, but I think I can't outrun it anymore.

I'm having trouble linking a C++ application with several libraries.

I am building on Neutrino 6.4.0 (because I have additional QNX-based tools in my toolchain)

With no IDE, the build is a standard Makefile

The libraries were developed using autoconf/automake/libtool. By default, libtool seems to invoke g++ to compile C++ files. This caused me some trouble under 6.3.2, and the hack that worked there was for me to define CXX=cc in my Makefile.am. This is not working in 6.4.0 apparently because libtool is generating a command line with options that are incompatible with cc.

So, bottom line, the C++ libraries are compiled with g++

The application is compiled using cc. cc -V tells me the default target is 4.2.4,gcc_ntox86.

libcpp is Dinkum. Alternative is libstdc++

SOLUTION: ./configure CC=qcc CXX=QCC -I/usr/local/include
</t>
<t tx="ntallen.20090505113338">After installing from the rtkit disk, need to get the network started. Try:
[Make sure to set up VM bridged networking]
[On radflt, I had to tweak the enumeration file /etc/system/enum/common to add enumerate(pci)]
  /etc/net.cfg
    version v1.2
    
    [global]
    hostname nortflt
    domain arp.harvard.edu
    
    [en0]
    type ethernet
    mode dhcp
    
  touch /etc/system/config/useqnet
  reboot
  
    sec_copy &lt;node&gt; # update security files. Run from source node
        /etc/passwd
        /etc/shadow
        /etc/group
        /usr/pkg/etc/sudoers
        /etc/profile.d/pkg.sh
        /etc/profile.d/pkg.ksh

/sbin/tinit is launched by /etc/rc.d/rc.sysinit
It reads /etc/config/ttys
  con1 "/bin/login" qansi-m on
  con2 "/bin/login" qansi-m on
  ...

I no doubt want to change that to invoke /bin/login -f flight
That in turn requires that /home/flight exists, etc.
</t>
<t tx="ntallen.20090505142020"></t>
<t tx="ntallen.20090505142020.1"></t>
<t tx="ntallen.20090505142020.2">Anchors: Left/Left, Right/Right, Top/Top, Bottom/Bottom
Divider Flags: RESIZE_BOTH, CASCADE
Orientation: Vertical
Separator Type: Drag Handle
Bevel Width: 1
Flags: Highlighted, Gets_Focus
Resize_Flags: 0

Callbacks:
    Divider Drag: plot_figure::divider_drag@figure.cc
    Resize: plot_figure::divider_resized@figure.cc</t>
<t tx="ntallen.20090508132540">Axes has a flag indicating whether detrended or not
Data has a flag indicating whether detrended or not
In Data, if axes is detrended and we are not
  Create a detrend variable referencing our X-Axis, this graph and the appropriate variable
if axes is not detrended and we are
  find the undetrended variable
  remove us from the detrended variable
  point to the undetrended variable

In Detrend Variable
  On RemoveGraph:
      if caller is destroying, call RemoveGraph on undetrended variable
      if this is the last graph, self-destruct

Could treat this like proposal for FFT where detrended data appears in a new window</t>
<t tx="ntallen.20090508132540.1">delete all associated graphs (but not by explicitly removing them from the list. The graphs should remove themselves during their own deletion routine.)
</t>
<t tx="ntallen.20090508132540.2">Like detrend, but performs FFT. Two things missing:
    You have to store the X-limits, since the X scale changes
    Need to find a way to enter the sample frequency: or not. Assume sample frequency = 1.

Unlike detrend, what we really want is to take a graph, and then request an FFT on a particular line.
This should create a derived variable using the x limits of the current graph, and then create a new
graph in a new window to display the FFT. Hence there is no "derived" distinction in the resulting
graph. New variable has a defined X range and can be associated with multiple graphs with whatever
limits they deem appropriate.

Derived variable name could be:
    FFT/&lt;variable&gt;/&lt;col&gt;/&lt;orig&gt;/&lt;npts&gt;
</t>
<t tx="ntallen.20090508182157">Is there a justification for having a separate hierarchy for derived?
What I'm talking about here are "checkbox derivatives" which have the following in common:
    Can be turned on or off via a checkbox on the Y-Axis tab
    [References the originating axes for the purpose of matching the X-limits]
        Alternately could refer to the axes of the first graph, or just store
        the initial limits. Can switch off to change the limits, then switch back
        This is complicated in the case of FFT. When you select FFT, both the X and Y scales change,
        so you can't use the current X-limits to define the input range
    References a single source variable
    Automatically self-destructs on RemoveGraph() or RemoveDerived() if none left.
    Will implicitly self-destruct if the source variable is deleted, since that will delete the
    graphs, which will leave the derived with no graphs, and hence trigger destruction.

I'm going to make the derived variable types vector-oriented rather than matrix, i.e. they will
pertain to a single column of an underlying matrix (multi-column) variable. This allows us to
save the space allocated for unplotted columns as well as the work of detrending a column that
won't be displayed.

OK, now I've tried that and realize that from the user standpoint, this becomes bizarre when we've
been referring to a specific column (e.g. column 2), and then it becomes a single-column variable.
Instead, there should be communication from the graphs to the variables regarding which columns are
required.

RTG_Variable_Data needs to maintain a list of variables derived from this one. If the variable
is deleted, all the derived variables must be deleted.

Note: I am treating Detrend or FFT as a property of the axes, but it will actually be applied
to a graph, and individually to each line.

When detrend is checked, walk through each graph and create a new derived variable that refers
to the original. Point the graph to the derived variable, without removing it from the original
variable's list.

FFT is not really a "checkbox derivative" at all. It should probably be a button on the line
tab that creates a new variable and a graph in a new window (best default, since the x axis
is guaranteed to be different. User can always create another graph in a pane.)


------------------
As an actual variable, showing up on the Variable tab, it will be possible to create a new graph based on that variable. When this happens:
    The new graph must have the same checkbox selection
    The new graph must be added to the source variable's list of graphs
    The new graph must be added to the derived variable's list of graphs
This makes it impossible to apply multiple derivations, which is probably fine.
----------------
Wait, I think this is an unnecessary restriction, requires unnecessary complexity and little value.
If the user chooses to do something complicated by selecting a derived variable, let them.

Deleting a derived variable should not delete the graphs. Instead, it should uncheck the box on the parent axis.
To be precise, interactively deleting a derived variable should do this. The actual destructor needs to be more direct, and probably should just delete the graphs if any exist.
-----------------
Again, too much complexity for little value. If the user explicitly deletes the derived variable, do what usually happens and delete the graphs.
</t>
<t tx="ntallen.20090514103050">MLF:
    Implicit Linear Scale
    Zero origin
    Slope 1 (i.e. X[i] = i;
    Range [0,nrows-1]
FFT:
    Implicit Linear Scale
    Zero origin
    Slope .5/(nrows-1) (i.e. X[nrows-1] = .5)
    Range [0,.5] (where 1 == sample frequency)
Trend Data:
    X explicit, but normalized to latest recorded time

Detrend:
    Subset of Source's range, but it isn't reasonable for the derived channel to know the source's scaling.
    Hence:
        Store the X values explicitly in the derived channel
        Provide a method to translate an X range into a row range</t>
<t tx="ntallen.20090514140929">Variables:
    (new_data_available is a deferred version of reload_required. It does not
    trigger a reload until the current output cycle is completed)
    new_data_available =&gt; reload_required (Variable_Data::check_for_updates())
    reload_required =&gt; graph-&gt;new_data

Figure:

Pane:
    
Axis:
    data_range_updated =&gt; axis_range_update (axes::check_limits())
    axis_range_updated =&gt; axis_limits_updated (axis::check_limits())
    axis_limits_updated =&gt; graph-&gt;axes_rescaled (check_limits)
    axis_limits_updated =&gt; redraw (axes::render())

Graph:
    new_data =&gt; lines-&gt;new_data, redraw_required (check_limits)
    axes_rescaled =&gt; redraw_required, lines-&gt;redraw_required (render)
    redraw_required =&gt; lines-&gt;render() (render)

Line:
    new_data =&gt; axis::data_range_updated, redraw_required (check_limits)
</t>
<t tx="ntallen.20090515141753">plot_obj::render_each {
  load any new data
  render the data
  plot_obj::check_for_updates(); // Handle visibility changes and check to see if there is new data available to plot
}

After any significant work, this will return true. Ordinarily, no new data should be loaded until you've gotten all the way through the rendering phase and done check_for_updates

plot_obj::check_for_updates() {
  foreach figure, figure-&gt;check_for_updates();
}

plot_figure::check_for_updates() {
  foreach pane, pane-&gt;check_for_updates();
}

plot_pane::check_for_updates() {
  foreach axes, axes-&gt;check_for_updates();
}

plot_axes::check_for_updates() {
  for each graph, graph-&gt;check_for_updates();
}

plot_data::check_for_updates() {
  foreach line, line-&gt;check_for_updates();
  variable-&gt;check_for_updates();
}

Variables are only checked if they are referenced from a visible graph
</t>
<t tx="ntallen.20090519153418">Needed to hack common.mk to add:
    
    ifndef PROJECT_ROOT
    PROJECT_ROOT=/home/nort/IDE/phrtg
    endif
    ifndef BUILDNAME
    BUILDNAME=phrtg_g
    endif

Which apparently weren't defined in the old IDE.

This will cease to be an issue once we upgrade.
</t>
<t tx="ntallen.20090529113129">Configuration will be saved to a text file
A default location will be used, or a command line option to override
Configuration will be saved automatically on exit and at other critical times
Configuration can be saved to another file, but that is only as a backup
Configuration can be restored from another file:
    then it will immediately be written out to the standard configuration file
When loading a configuration file, we'll need to decide whether or not to clear the current configuration:
    It's probably the right thing to do, but certain things like variables
    which may be holding current realtime data should probably be preserved.

The idea is to preserve as much of the current state as is reasonable:
    Names of variables, etc. is reasonable
    Data for those variables probably isn't

Basic strategy is to tie into the functions used by the GUI for updates and where possible
tie into that logic. Controls in the GUI have unique names which identify the control,
and it applies to Current objects. Hence when reading and writing configurations, we
need to carry through on that approach and manipulate the Current objects so the controls
will apply to the correct objects.

There are some controls which are implicit in the GUI, like window size and position.</t>
<t tx="ntallen.20090529113129.1">I will create an EBNF specification for the file format, but my intention is to keep it very simple so the parser can be correspondingly simple.
The file will consist entirely of statements which will fit on a single line
Each statement will start with a keyword and then have appropriate arguments.
Keywords will be coordinated with the ABN_* namespace:
    Where applicable, a keyword 'X' will map to ABN_X
    Some ABN_X will not require a keyword
    Some keywords will not map to ABN_


Top Level

Handle:
    End File

Delegate:
    Console_Pos
    Console_State?
    MLF
    Detrend
    Figure
</t>
<t tx="ntallen.20090529113129.2">Will need to specify position and/or state (minimized, etc.)
Also which tab is selected

Handle:
    Console_Pos &lt;PhPoint_t:pos&gt;
    Console_State?

</t>
<t tx="ntallen.20090529113129.3">A Figure is a plot_figure object which includes:
    a Figure module instantiated from ABM_Figure including
    a PtWindow widget

By default, the window definition command will create a new window
new plot_figure(name) requires only the name, so this command should take a single name argument:

Figure &lt;string:name&gt;
    This creates the new figure and makes it the Current::Figure

Figure_Select &lt;string:name&gt;
    This does not create a new figure. If a figure of the matching name does not exist, Current::Figure is undefined.

End Figure
    This undefines Current::Figure and triggers delayed actions including resizing.

Figure properties:
    These should be tolerant of Current::Figure being undefined.
    
    Figure_Name &lt;string:name&gt; would be redundant in configuration, but could be useful interactively
    Figure_Visible &lt;bool:vis&gt;
    Figure_Area &lt;PhArea_t:area&gt; (PhPoint_t (short x,y) pos, PhDim_t (unsigned short w,h) size)
    Figure_State? (see notes on Pt_Arg_Window_State in PtWindow doc)
    [Figure_ShowName &lt;bool:showname&gt;] (look at Pt_ARG_WINDOW_RENDER_FLAGS)
    [Figure_ShowMenu &lt;bool:showmenu&gt;]

Invocation:
    Figure &lt;string:name&gt; &lt;action:act&gt;
        action: create*, select, delete

Handle:
    Figure_Name &lt;string:name&gt;
    Figure_Visible &lt;bool:vis&gt;
    Figure_Area &lt;PhArea_t:area&gt;
    Figure_State? (see above)
    End Figure

Delegate:
    Pane
</t>
<t tx="ntallen.20090529113129.4">If I handle configuration file data the same way I handle data feed commands, it would be possible to manipulate the data display via the interactive command line. For example:
    if there are multiple modes of instrument operation, switching between modes
    could trigger switches between configurations.
    Starting a scanning sequence could automatically create a new graph window to display the scan.
There are certainly issues to work out:
    Since the command stream is unidirectional, we would probably need some sort of conditional execution:
        don't create that window if it already exists, and don't mess with it's definition.
</t>
<t tx="ntallen.20090529113129.5">This topic applies to all windows and panes and maybe certain things yet to be defined.

When sizes are changed via the GUI, the application usually just needs to take notice.
When sizes are changed via configuration, we actually need to manipulate the GUI.
This means the functions won't be exactly identical.
As always, we need to make sure we don't get in a loop where resizing triggers resizing.
</t>
<t tx="ntallen.20090529122349">We need to define variables before we can define graphs that reference them

Currently I recognize:
    MLF varpath index

Need to define derivatives:
    Detrend src_varpath detrend_varpath x_min x_max

Variables currently have no other properties
</t>
<t tx="ntallen.20090529132820">Invocation:
    Pane

Handle:
    Pane &lt;string:name&gt; &lt;action:act&gt;
        action: create*, select, delete
    Pane_Name &lt;string:name&gt;
    Pane_Visible &lt;bool:vis&gt;
    Pane_Color &lt;color:color&gt;

Delegate:
    Axes

End Pane
</t>
<t tx="ntallen.20090529132820.1">Handle:
    Axes &lt;string:name&gt; &lt;action:act&gt;
        action: create*, select, delete

    Axes_Name &lt;string:name&gt; (usually redundant)
    Detrend &lt;bool:detrend&gt; [&lt;bool:act:false&gt;]
        If not present, act defaults to false
        act determines whether this command should actually simulate selecting or deselecting
        the detrend toggle or simply record the selection. For use in the configuration file,
        act should be false, since the appropriate variable will already be recorded.
        This option can be added much later when there is an actual need for this functionality.
    End Axes

Delegate:
    Axis
    Graph
</t>
<t tx="ntallen.20090529132820.2">Axis &lt;AxisXY:xy&gt;

Auto_Scale &lt;bool:autoscale&gt;
Limit_Min &lt;scalar_t:lim_min&gt;
Limit_Max &lt;scalar_t:lim_max&gt;
</t>
<t tx="ntallen.20090529132820.3">Graph varpath
Graph_Select varpath

Graph_Visible &lt;bool:graph_vis&gt; (currently no GUI equivalent)
</t>
<t tx="ntallen.20090529132820.4">Line &lt;unsigned:column&gt;
Line_Name &lt;string:line_name&gt;
Line_Visible &lt;bool:line_visible&gt;
Line_Color &lt;color:color&gt;
</t>
<t tx="ntallen.20090602153925">Open configuration file

parser = new RTG_Parser(char *filename);
while ( parser-&gt;newline() ) {
  switch (parser-&gt;keyword) {
    case CFG_Console_Pos:
    case CFG_Console_State?:
        Console_Config(parser);
        break;
    case CFG_MLF:
        RTG_Variable_MLF::cfg_load(parser);
        break;
    case CFG_Detrend:
        RTG_Variable_Detrend::cfg_load(parser);
        break;
    case CFG_Figure:
        plot_figure::cfg_load(parser);
        break;
  }
</t>
<t tx="ntallen.20090602154813">    MLF varpath index


RTG_Variable_MLF::cfg_load(parser) {
  varpath vp;
  unsigned long mlfno;
  if ( parser-&gt;varpath(vp) &amp;&amp; parser-&gt;ulong(mlfno) ) {
    Incoming(vp, mlfno);
  }
}
</t>
<t tx="ntallen.20090602162607">clase RTG_Serializer {
  public:
    File *fp;
    RTG_Serializer(char *filename);
    keyword(int code);
    varpath(RTG_Variable *var);
    static void cfg_save(char *filename);
}
</t>
<t tx="ntallen.20090804144000">IntServ is required due to the interrupt-sharing architecture of the subbus.
BUT the indexer is currently our only interrupt device, and in most configurations,
we'll only have a single indexer board in a stack, so we aren't even sharing interrupts.
In any event, I can probably subsume this function into the indexer driver.

Need to know what IRQ the interrupt is connected to.

Register a board
    int IntSrv_Int_attach( char *cardID, unsigned short address,
    						int region, pid_t Proxy );
    int IntSrv_Int_detach( char *cardID );
    IntSrv_Pulse
    IntSrv_PulseReceived()

We will use a pulse to communicate the interrupt to the thread, but that goes for all
interrupts. We don't need to use a board-specific pulse. It's probably sufficient to
call a general interrupt processing routine with the board ID

Initialization involves writing the interrupt config to the board's base address.
On interrupt, we will receive a pulse, then the intserv handler will read from
the interrupt acknowledge address to determine the source of the interrupt.
Then the appropriate routine will be called.
</t>
<t tx="ntallen.20090810133013">If IntServ needed to be in a separate process (because interrupts from different types of boards were required)
we would need the driver to communicate the parameters of IntSrv_Int_attach() to IntServ, then configure to
be notified when the interrupt arrives. It would probably make sense to do this as a resource manager,
write only, where you would write the control information, then set up for ionotify().</t>
<t tx="ntallen.20090818124956"></t>
<t tx="ntallen.20090818124956.1"></t>
<t tx="ntallen.20090818124956.2"></t>
<t tx="ntallen.20090818124956.3"></t>
<t tx="ntallen.20090818124956.4">Or alternately, come up with a script to configure and build the list in the correct order.
QNX6/utils/FullBuild now works on the vast majority of project directories as detailed
in the "Install 6.4.1" node above. I have a TopFullBuild placeholder which should visit
all the projects in sequence, doing a FullBuild in each.
</t>
<t tx="ntallen.20090824101208">Set hostname
  How is hostname handled? In /etc/net.cfg (usually via the network config tool)
  /etc/system/sysinit also looks in /etc/HOSTNAME

Remove non-x86 targets from /usr/qnx641/target/qnx6

Adapted from pkgsrc instructions:
  http://community.qnx.com/sf/wiki/do/viewPage/projects.pkgsrc/wiki/BinaryPackages

  Edit /etc/profile to add /usr/pkg/bin and /usr/pkg/sbin to PATH
  Add to /etc/rc.d/rc.local:
    setconf CS_LIBPATH $(getconf CS_LIBPATH):/usr/pkg/lib
  mkdir /var/tmp
  download pkgsrc bootstrap bootstrap.tar.gz and unpack in /
    ftp://ftp.netbsd.org/pub/pkgsrc/packages/QNX/i386/6.4.1_head_20090724/bootstrap.tar.gz
  Set PKG_PATH in /root/.profile:
    export PKG_PATH=ftp://ftp.NetBSD.org/pub/pkgsrc/packages/QNX/&lt;arch&gt;/&lt;vers&gt;/All
    &lt;arch&gt; is i386
    &lt;vers&gt; is 6.4.1_head_20090724

Installed:
    # openssh # Included in 6.4.1
    perl-5.10.0nb6
    sudo-1.7.1
    m4-1.4.13
    autoconf-2.63
    automake-1.10
    gtexinfo 4-12nb1
    libtool-1.5.26

Setup to use qnet
  Make sure hostname is set
  mount -T io-pkt lsm-qnet.so # This is a change from 6.3.2, which used io-net
  touch /etc/system/config/useqnet # to get it boot up running qnet, referenced from /etc/system/sysinit
  
Copy and/or Edit password files from network
Copy sudoers from network

Install cdrtools from QNX downloads third party page

### Good to here
    
    +QNX6/utils  includes a config.site
    +nortutil (only os-independent: select binaries and select install tool)
      make sure /usr/bin/perl points to perl (/usr/pkg/bin/perl)
    +nortlib[2]                FullBuild with internal sudo, stop on error
    +cmdgen       (lex/yacc)   FullBuild with internal sudo, stop on error
    +oui          (lex/yacc)   FullBuild with internal sudo, stop on error
    +QNX6/tmlib   (TM library)  FullBuild with internal sudo, stop on error
    +QNX6/tmphlib (need for display programs and keyboard client programs) FullBuild+
    +QNX6/tmpplib (C++ interface for TM) FullBuild+
    +QNX6/displib (needed for display programs generated via phtable) FullBuild+ Did not specify CC=qcc CXX=QCC
    +QNX6/tmutil  (checks path of sudo. no configure, make, make install) installed

    +QNX6/tmc (no configure, make, make install)
    +QNX6/TMbfr/resmgr (no configure, make, make install)
    +QNX6/lgr (no configure, make, make install)
    +QNX6/rdr (no configure, make, make install)
    +QNX6/memo (no configure, make, make install)
    +QNX6/phrtg-native (make, make install)
    +tmcalgo (no configure, make, make install)
    +QNX6/qcliutil (no configure, make, make install)
    +snafu  FullBuild
    
    +QNX6/dccc
    +QNX6/diagnost (minus scdebug)
    +QNX6/Diagsuite
    +QNX6/ssp_driver
    +QNX6/idx64

    +eli compiler tools (required for table, qclicomp?)
    
    +phtable (provide Makefile to invoke eli)
    +qclicomp (or qclicompsrc?)(provide Makefile to invoke eli)

    Try installing Leo, what the heck!    </t>
<t tx="ntallen.20090824123722">This procedure is documented in an OS Technote on the QNX website for 6.4.1
I am creating tools mkrtkit in QNX6/mkrtkit
Need to install cdrtools binaries available on the QNX Downloads page under
Third Party.
</t>
<t tx="ntallen.20090910171038">I'm trying to find the right balance of compile and link.
Using cc to compile c++ code seems to tie into the Plauger libraries
Linking then needs to be done using cc -lang-c++ or there are unresolved symbols

If instead I compile c++ code with CXX=g++, I apparently need to link with g++
or I have similar problems.

All my libraries are compiled with g++. Not clear if that presents a problem or not.

Programs compiled using the IDE use cc stuff.
</t>
<t tx="ntallen.20090911120219">phrtg was designed and built using the windows IDE. To compile under
neutrino requires some hacking.

  [I believe I should be able to compile under the windows IDE using
  my libraries that were compiled using gcc. My linking complications
  seem to be focused on C++ libraries, not C libraries, and -lnort and
  -ltm are C only.]

Created a separate module called phrtg-native which sets paths for
native compileation. I did not need to override CXX because I am
not linking with any of my C++ libs. I no longer need to hack common.mk.

Also the extra include paths are set to $QNX_TARGET/usr/local/include &amp; lib,
which works under windows. Need to add a soft link on nto

This is all in native.mk now</t>
<t tx="ntallen.20090930220540">Need to remember to run symlinks after checkout
Make sure Eli/configure is remade and does not include ELI_PROG_WC

Still observing Odin hangs in QNX6, but ctrl-C and restart does the right thing.
Should be able to debug using eli -s</t>
<t tx="ntallen.20091015133220">There are two command protocols: The verbose format that we use in cmdgen and the terse version used to communicate directly with the driver. The translation takes place in idx64.cmd, which will go into /usr/local/share/huarp</t>
<t tx="ntallen.20091022143321">Many of the options of mkdoit2 are console-specific, so not-applicable
But now I need to support some console-specific stuff as well
First challenge, come up with a good doit script:
    FlightNode
        Defined: dedicated hardware, must invoke flight.sh from tinit
        Undefined: run on local machine
            /net/nortvm650/home/nort/test/demo/doit now handles these two cases pretty well
            starts flight.sh using on -t $tty in order to get it in a separate session, allowing
            the parent -qt3 to not terminate it in the case of an exit command.
        Playback : don't need a separate flight tree, just start rdr, possibly passing in options
            probably use a different client as well
    Commands
        stop
        not
        start (default)
        wait
    Modes
        Photon w/ photon apps
            Just run the apps
            Launch flight.sh with on -t $tty pterm
            Launch less with pterm
        Photon, pterm w/ ncurses apps
            Invoke pterm /usr/local/sbin/getcon to allocate ttys, then
            run the apps with explicit args specifying the tty
            Launch flight.sh with on -t $tty [pterm]
            Launch less with on -t ? pterm
                These last two are a little problematic: I/O works OK, but ^C does not
        console (or pterm), screen w/ ncurses apps
            Create screen config file to run getcon on multiple ttys and
            re-run the doit within screen</t>
<t tx="ntallen.20091022143321.1">By this I mean all the algorithm status information that was incorporated into the data display in QNX4.
Did I just punt on this?
Do I have a grand plan?

We could route algo status through the cmdserver:
    disp programs would read from both TMbfr and command server
    algo would get another commandline flag to produce status information:
        next command/status
        time until next command
        current state
        time in current state
        holding...
    This doesn't have to go to disp, it could go to a standalone status utility</t>
<t tx="ntallen.20091030133630"></t>
<t tx="ntallen.20091104124904.1987"></t>
<t tx="ntallen.20091104124904.1988">Trick is to figure out what we need to copy over.

Lots of /usr/bin stuff:
    /usr/bin
    /usr/qnx641/host/qnx6/x86/usr/bin
    /usr/qnx641/target/qnx6/usr/bin
    /usr/qnx641/target/qnx6/x86/usr/bin
    /usr/pkg/bin

A lot of the files in /usr/bin are also in one of the other directories
    (can check using dircompare | grep identical)
A lot of files from /usr/qnx641/target/qnx6 and qnx6/x86 were installed
  into /usr/bin already as part of qnx-6.4.1
We can use some of this stuff, but we don't need all of it 

For the packages installed via pkgadd, we already have manifests in /var/db/pkg,
so it probably makes sense to simply write a script to duplicate a package
on another machine. pkg_copy: Add this to utils

I should really break these up into smaller packages:
    sudo  pkg_copy
    perl  pkg_copy
    gcc
    anything else?

I need something like pkg_copy for gcc, etc., which lives under /usr/qnx641
I need a heuristic for deciding what files to include:
    find /usr/qnx641 ! -type d | sed -f gse_select.sed

gse_select.sed
    Avoid everything for arm|mips|ppc|sh
    Avoid all of target/qnx6/x86, assuming it's already in qnx-6.4.1, but should check</t>
<t tx="ntallen.20091109122106.1991">After install, login as root (no password) and start Photon ("ph" command)
If Photon doesn't start, you may need to edit the screen configuration file
    /etc/system/config/display.conf
In Photon, run the network configuration tool to set hostname and enable dhcp
In /etc/system/config:
    rm -f nophoton
    touch useqnet
reboot

    # pkg_copy &lt;node&gt; sudo perl (no longer necessary)
    # dev_copy is now obsolete.
    sec_copy &lt;node&gt; # update security files. Run from source node
        /etc/passwd
        /etc/shadow
        /etc/group
        /usr/pkg/etc/sudoers
        /etc/profile.d/pkg.sh
        /etc/profile.d/pkg.ksh

create my home dir and copy over # I have a script... where is it?
    /home/nort
    /home/nort/.profile
    /home/nort/.ssh/*
    /home/nort/.elvis/elvis.ini</t>
<t tx="ntallen.20091112115242.1993"></t>
<t tx="ntallen.20091112115242.1994">Need to rework the gpib232 functions to be more robust, use readcond() instead of getc(), etc.
</t>
<t tx="ntallen.20091112115242.1995">gpib232_init()
    Should open the device and query the GPIB232 using the id function
    Set up the timeout interval to 5 seconds
    Complain if it gets no response
    </t>
<t tx="ntallen.20091112115242.1996">gpib232_cmd( const char *cmd)</t>
<t tx="ntallen.20091112115242.1997">int nb = gpib232_cmd_read( const char *cmd, char *repbuf, int nb_rep )
    calls gpib232_cmd(cmd), then reads up to nb_rep from the device</t>
<t tx="ntallen.20091112115242.1998">gpib232_write( addr, cmd )
    Writes the specified command to the device at the specified addr.
    Formats the command using GPIB232 format "wrt %d\n%s\r\n"
    and invokes gpib232_cmd()</t>
<t tx="ntallen.20091112115242.1999">gpib232_write_read( addr, cmd, rep, nb)
    Writes the specified command to the device at the specified addr
    and reads the response.
    Formats the command using GPIB232 format "wrt %d\n%s\r\nrd #%d %d\r\n"
    and invokes gpib232_cmd_read(fcmd, rep, nb+5),

reply buffer (rep) must be long enough to hold nb+5 characters.
I will verify that the resulting data is NUL-terminated.</t>
<t tx="ntallen.20100720160700.2021">pkg_copy is handy, but it seems like we should be able to include the package in the install CD as well, and thereby skip the pkg_copy step on a new install.

dev_copy has been tweaked to produce MANIFEST for new installation, so is now obsolete

sec_copy is something to leave until after the install.</t>
<t tx="ntallen.20100723121747.2023">Copying procedure from 6.4.1 to annotate here.

Set hostname
  How is hostname handled? In /etc/net.cfg (usually via the network config tool)
  /etc/system/sysinit also looks in /etc/HOSTNAME

Setup to use qnet
  Make sure hostname is set
  mount -T io-pkt lsm-qnet.so # This is a change from 6.3.2, which used io-net
  touch /etc/system/config/useqnet # to get it boot up running qnet, referenced from /etc/system/sysinit
  
Make sure time is set:
    sudo on -f nodename date -u `date -u +%Y%m%d%H%M.%S`
    sudo on -f nodename rtc -s hw
    # This should of course be done with settime/flttime
    
Copy and/or Edit password files from network
Copy sudoers from network
  /usr/local/sbin/sec_copy &lt;newhost&gt;

Nort has a dup_homedir script to run as well.

#This really only applies to runtime systems, though not good reason to keep
#them on the development platform either unless we target another processor
# Remove non-x86 targets from /usr/qnx641/target/qnx6

Bootstrap pkgsrc
Adapted from pkgsrc instructions:
  http://community.qnx.com/sf/wiki/do/viewPage/projects.pkgsrc/wiki/BinaryPackages

  Edit /etc/profile to add /usr/pkg/bin and /usr/pkg/sbin to PATH
  Add to /etc/rc.d/rc.local:
    setconf CS_LIBPATH $(getconf CS_LIBPATH):/usr/pkg/lib
  mkdir /var/tmp
  download pkgsrc bootstrap bootstrap.tar.gz and unpack in /
    ftp://ftp.netbsd.org/pub/pkgsrc/packages/QNX/i386/6.5.0_head_20100424/bootstrap.tar.gz
  Set PKG_PATH in /root/.profile:
    export PKG_PATH=ftp://ftp.NetBSD.org/pub/pkgsrc/packages/QNX/&lt;arch&gt;/&lt;vers&gt;/All
    &lt;arch&gt; is i386
    &lt;vers&gt; is 6.5.0_head_20100424

Install: These packages need to be identified individually by going to the site and
  seeing what the current version is. These are accurate as of 101124.
    # openssh # Included in 6.4.1
    perl-5.10.1nb1
    sudo-1.7.2p6
    m4-1.4.14
    autoconf-2.65nb1
    automake-1.11.1
    gtexinfo 4-13
    libtool-2.2.6b

Install cdrtools from QNX downloads third party page:
    This is a version compiled for 6.3.2, but hopefully still works.
    Interesting to know if this will be rebuilt.

### Good to here
For FullBuild to work reliabily, we need to allow some environment variables
through sudo:
    
    Defaults env_keep = "QNX_HOST QNX_TARGET MAKEFLAGS PATH"
    root  ALL=(ALL) SETENV: ALL
    nort  ALL=(ALL) SETENV: ALL

We will also want to grant sudo NOPASSWD to group flight for several utilities:
    
    %flight ALL= NOPASSWD: \
        /usr/local/bin/fixdisk, \
        /usr/local/sbin/promote, \
        /usr/local/sbin/signal_parent, \
        /usr/local/bin/distribute

These should be in the sudoers file that is copied over.

For FullTopBuild, first need to check out a bunch of things
  # make sure CVS_RSH is defined
  export CVS_RSH=ssh
  set CVSROOT=:ext:forge.abcd.harvard.edu:/cvsroot/arp-das
  cvs checkout QNX6Build
  cd QNX6Build
  QNX6/utils/FullTopBuild
  
    
    +QNX6/utils  includes a config.site
    +nortutil (only os-independent: select binaries and select install tool)
      make sure /usr/bin/perl points to perl (/usr/pkg/bin/perl)
    +nortlib[2]                FullBuild with internal sudo, stop on error
    +cmdgen       (lex/yacc)   FullBuild with internal sudo, stop on error
    +oui          (lex/yacc)   FullBuild with internal sudo, stop on error
    +QNX6/tmlib   (TM library)  FullBuild with internal sudo, stop on error
    +QNX6/tmphlib (need for display programs and keyboard client programs) FullBuild+
    +QNX6/tmpplib (C++ interface for TM) FullBuild+
    +QNX6/displib (needed for display programs generated via phtable) FullBuild+ Did not specify CC=qcc CXX=QCC
    +QNX6/tmutil  (checks path of sudo. no configure, make, make install) installed

    +QNX6/tmc (no configure, make, make install)
    +QNX6/TMbfr/resmgr (no configure, make, make install)
    +QNX6/lgr (no configure, make, make install)
    +QNX6/rdr (no configure, make, make install)
    +QNX6/memo (no configure, make, make install)
    +QNX6/phrtg-native (make, make install)
    +tmcalgo (no configure, make, make install)
    +QNX6/qcliutil (no configure, make, make install)
    +snafu  FullBuild
    
    +QNX6/dccc
    +QNX6/diagnost (minus scdebug)
    +QNX6/Diagsuite
    +QNX6/ssp_driver
    +QNX6/idx64

    +eli compiler tools (required for table, qclicomp?)
    
    +phtable (provide Makefile to invoke eli)
    +qclicomp (or qclicompsrc?)(provide Makefile to invoke eli)

    Try installing Leo, what the heck!    </t>
<t tx="ntallen.20100726093122.2025">Done: using pkg2pkg, which simply generates a huarp package def from a pkgsrc def

Assumptions (which will be shown false eventually):
    The packages we wish to install have no dependencies (sudo, perl)
    The packages we wish to install have simple installations (no setup scripts)

Plan would be to extend the mkrtkit Header Requires line to accept:
    pkg:sudo pkg:perl

mkrtkitarch would locate the package and do the processing that pkg_copy does in order to include the files in the archive.

A smarter approach would be to install pkg_add and the pkg archives, then run it to install the packages. Running pkg_add during the copying stage would be problematic since the target disk is not /, so I'd need to hook into the post-install stuff.</t>
<t tx="ntallen.20100726093122.2026">This has been done, but the methodology may be useful when updating to a new version of QNX.

This requires reviewing the logic of dev_copy in order to generate a package containing the GPL compiler tools.

find /usr/qnx641 ! -type d | sed -f dev_copy.sed &gt;MANIFEST

</t>
<t tx="ntallen.20100729115515.2029">Will need a library and a driver. Driver's job is simply to arbitrate access to the device.

Where we are really dealing with send/reply interface, it might make sense to use custom messages as opposed to making separate write/read calls</t>
<t tx="ntallen.20100810122935.2031">Restricting file range:
    By file/number
    By time

On initialization, rdr should determine the starting and ending file numbers so process_eof() will know
whether to keep trying. If they aren't passed in as parameters, rdr could invoke mlf_find itself.

This approach requires rdr to read all the data. It would be nice to have a method to find the time
more quickly, but that might best be handled by an external app.</t>
<t tx="ntallen.20100927130121.2033">Library extending data_client for operation under ncurses.
</t>
<t tx="ntallen.20100927130121.2034">Library extending data_client for operation under Photon.</t>
<t tx="ntallen.20100927130121.2035">dispnclib ala displib (and possibly in the same source directory)
  class nc_data_client : public data_client {
  }

C Support routines in tmnclib ala tmphlib (and possibly in the same source directory)
  Provide for:
      initializing windows
      displaying data
        override operate to flush after each read()
      cleanup on termination
  prototype currently in
    /net/nortvm650/home/nort/test/nc

For handling multiple terminals, call newterm() instead of initscr() as per
http://invisible-island.net/ncurses/ncurses-intro.html#functions

Need to write a test app (or test apps)
    Use pterm to allocate additional screens
      pterm -N3 3&gt;pterm.dev &amp;
      # device is written to pterm.dev. Probably a race condition...
    Invoke one app to display on all screens but one
    Invoke another app to listen on all screens, display on one.
    
    Actually, for the purpose of the test, all this can be done in a single app.
    Take as args list of devices. fopen all for writing and pass to newterm
    as ofp. open all for reading and set up a select() loop.
    
    Having some trouble getting the screen reset to default modes.

    </t>
<t tx="ntallen.20100927130121.2037">Instead of generating FLD file, generate something more like the current tbl.tmc from phtable.
</t>
<t tx="ntallen.20100927130121.2038">Depending on target, decide whether to run $(TABLE) or $(NCTABLE)
Alternately, we could generate both types of clients and decide which to run depending on term type?</t>
<t tx="ntallen.20101124082052.2043">tmpplib choked because paths were missing from library search path.
Will try soft-linking /opt/qnx650 -&gt; /usr/qnx650. No good
Need:
    $(QNX_TARGET)/x86/lib
    $(QNX_TARGET)/x86/usr/lib
    $(QNX_TARGET)/x86/lib/gcc/4.4.2</t>
<t tx="ntallen.20101129134921.2045">cvs -d:pserver:anonymous@eli-project.cvs.sourceforge.net:/cvsroot/eli-project login
# empty password
cvs -z3 -d:pserver:anonymous@eli-project.cvs.sourceforge.net:/cvsroot/eli-project co -P Elidistrib
unset ODIN_LOCALIPC # default is supposed to be TCP/IP
cd Elidistrib
./symlinks # need to do this once after checkout. Runs autoconf
./configure --prefix=/usr/local --without-XView --without-Xaw --without-tcltk
./BUILD [-nobrowsers]
</t>
<t tx="ntallen.20101206091106.2047">Document how to generate manifests for a new version of the operating system.

Start by reviewing the rtkit technote in the standard QNX Documentation set:
    QNX Neutrino Realtime Operating System:
        Technical Notes:
            How to create a Runtime Kit from the QNX Software Development Platform

The rtkit files are located on the QNX install CD under /rtkit, including
various example file lists. The modules in 6.5.0 listed include:
    650-os.txt # basic OS files
    650-fsys.txt #  mass storage
    650-net.txt # networking
    650-gpl.txt # GPL stuff
    650-graphics.txt # core graphics: not what we need?
    650-internat.txt # asian languages
    650-ap.txt # adaptive partioning
    650-complete.txt # A complete list

There are things in complete that are not in any of the others, including most of photon.

I have recombined these into pkgs:
    qnx-  # basic OS files
    photon-
    mozilla-

In addition, I have a gcc- pkg, which is not included in complete.
I would like to automate or at least semi-automate the process of going
from the rtkit lists to the pkg lists</t>
<t tx="ntallen.20101206091106.2048">I currently have three packages:
    flight
    gse
    develop

flight and gse are intend as complete installations, pulling in OS packages
as required. gse brings in develop, which brings in flight and gcc.
gse is pure in that it does not include any files of its own.

It might make good sense to split out Eli as a separate package, pulled in
from develop.

It could be useful to have a mechanism or tool for collecting the manifests for
flight and develop from the build. I could include a mkrtkit definition file in
each directory which would define which install files go into which package.

    find QNX6Build -name mkrtkit.cfg | xargs sed -ne 's!^flight: *!!p' mkrtkit.cfg</t>
<t tx="ntallen.20101206091106.2049">The version mechanism I have adopted that includes the version in the directory name is not readily compatible with CVS. To create a new version, you have to duplicate the directory structure. Note that the tools all use the copies installed in /var/huarp/pkg, so keeping the version in the mkrtkit hierarchy naming is counter productive. I will instead add a VERSION specification to the Header and improve the installation process to pull out the version.

Among other things, this will ensure that old versions which will no longer work (e.g. qnx-6.4.1 addresses many files with qnx641 in their path) need not be kept around but can be upgraded instead. They can of course be recovered via CVS, but probably never will be.

It should be reasonable to include a Makefile in a package definition in order to generate some of the manifests. The install would then only copy down the Header and any manifests mentioned. Presumably the MANIFEST_pkg could then be auto generated as well. Of course I would like to do that without requiring a Makefile in every package.

    make -f $MANIFEST_pkg.mk

Install could be handled via make in the same way.

Could include a local Makefile if it exists to handle the case where MANIFEST are built from other targets.


</t>
<t tx="ntallen.20101207141953.2053">Automatically take /rtkit/650-os.txt split into MANIFEST and MANIFEST_x86
Same with 650-fsys.txt and 650-net.txt
Include 650-gpl.txt
Throw in multicore?

Look at complete and figure out what is in there that isn't in the others</t>
<t tx="ntallen.20101207141953.2054">Take list from 650-complete.txt where /usr/photon is listed
Anything else?
</t>
<t tx="ntallen.20101222082748.2057">When should a package's version be incremented?
    When the Header changes, affecting the contents
    When any of the MANIFESTs change
    When any of the source files listed in the MANIFESTs are updated
    
    For an installation CD package, whenever any of the component
    archives is updated.
    
The last rule implies that the installation CD packages should probably not
contain any files, just references to other packages. The gse package is
pretty close to this ideal. The flight package is not, but I could easily
create flight-inst, referencing flight.

I should move the perl kluge out of gse into it's own package.</t>
<t tx="ntallen.20101229203740.2059">Need to allocate ptys for each screen of each display program and for the cmdclt.
The cmdclt needs a pty for output, but can also read from all the display ptys as well
An algo might also use a display

ptys are allocated by running programs on them (getcon). This program has to report
back what pty it is on, and that information has to get back to the programs that
need to use them.

We could allocate all the ptys before invoking the programs, but the trick
is figuring out that we have collected all the information we need.
In the case of screen, all of the getcon programs will be started more
or less simultaneously, so we need to serialize their responses somehow.
Each could write to its own file, but we need a way to know when the writing
is complete.
    could write to an intermediate file, close it, then rename it. Just
    need to wait for the file to exist, then we can read its contents.
So then the idea would be:
    Allocate the ptys by invoking either pterm or screen to run getcon
    on each pty. Each getcon will be given a screen name, and they will
    write their tty name to a file:
        write to pty.ttyname.tmp
        mv pty.ttyname.tmp pty.ttyname
    The startup script will wait for each file in turn and copy its contents.
    Then it can start up the display programs and the kbdclt on the appropriate
    ptys.
    
    For screen, we need to generate a startup script, then invoke screen,
    and have it pick up at the next part of the startup, namely where
    the ttynames are collected and the programs are started up.
    
    Note that this would be less complicated if display programs all
    had only one screen, which is probably a common case. Also if
    I didn't want to have the kbdclt read from all the display ptys,
    but I think those will be very useful options.
    In those cases, I would not need getcon at all, and could just
    start the display programs and the kbdclt on their own ptys.
    
Screen invocation
    doit: same current invocation up until we can contact the cmdsrvr
    then create screen config file which will:
        Invoke less +F $Experiment.log
        Invoke getcon for each display screen
        Re-Invoke doit on what will be the kbdclt pty
            doit will skip to the post-screen section, where it will
            collect all the ttynames for the display screens
            invoke each of the display programs with their screen args
            run kbdclt with all of the display ttynames
            clean up on exit
    
    getcon &lt;windowname&gt;
        Write ttyname to pty.&lt;windowname&gt;.tmp
        rename pty.&lt;windowname&gt;.&lt;sessionID&gt;.tmp pty.&lt;windowname&gt;.&lt;sessionID&gt;
        listen on /dev/huarp/$Experiment/cmd/Quit for quit
        Better yet, listen on .../cmd/getcon for either quit (empty message)
          or our session ID. That would allow mutiple sessions to run and
          only one to clean up on exit
    
    for each display
        waitfor pty.&lt;windowname&gt;.&lt;sessionID&gt;
        &lt;windowname&gt;_pty=`cat pty.&lt;windowname&gt;.&lt;sessionID&gt;`
        rm pty.&lt;windowname&gt;.&lt;sessionID&gt;
        
    There is a potential collision if more than one session is started from the same directory.
    To avoid that, the 'pty' portion should be customized for each session. The simplest
    approach is to use the pid of the launching script, e.g. pty2341534.&lt;windowname&gt;.tmp
    or pty.&lt;windowname&gt;.&lt;pid&gt;.tmp (to alphabetize more neatly). So getcon should take two
    arguments, the &lt;windowname&gt; and the &lt;pid&gt;. They could be passed as one, but this way,
    getcon could conceivably do something else with the name if necessary.
        </t>
<t tx="ntallen.20110102095209.2061">Need documentation for the new interface keywords and the associated library function, cis_turf() in cis.c.
</t>
<t tx="ntallen.20110106130520.2063">Much of the display stuff is identical to instrument operation.
The main difference is that we don't invoke flight.sh or access
a remote flight stack. Instead we create our own local stack
using Experiment=$Experiment.PB.$NODE.$$

The local stack consists of:
    memo
    TMbfr
    pbcmdsrvr
    rdr

The pbcmdclt will replace the application's own client
The two will support commands relevant to the rdr,
e.g. fast forward, search, etc.

For InetIn, the same is true, but replace rdr with InetIn</t>
<t tx="ntallen.20110106130520.2064">start is implicit if no other command is given
another command: screen &lt;session&gt; is used internally in doit -s

-s use ncurses display and client programs and invoke screen
-n use ncurses display and client programs and use pterms
otherwise use photon apps

-s could be the default if tty is a virtual terminal.
-n is really only for testing the ncurses implementations without screen.

-p run Playback mode
-i src InetIn
otherwise realtime data acquisition

-p and -i both create a local command and control structure, so they
will need to redefine Experiment</t>
<t tx="ntallen.20110110214655.2067">display abcdisp abc [options]
    Lists the names of each screen. Must match order and number in .spec file
    Can append 'nc' to disp executable to get ncurses version
client abcclt [options]
    Can append 'nc' to clt executable to get ncurses version
algorithm abcalgo
    Not currently supported for QNX6
extraction abcext [options]
    Only for real extractions: specify extra options to display directly
memo [&lt;logfilename&gt;]
    Display less +F. Default log file is $Experiment.log
batchfile &lt;batchfilename&gt;
phrtg
autostart
    Or should this be a command line option?</t>
<t tx="ntallen.20110110214655.2068">    Could we extract that information instead?
    What if the screen names collided?
        The screen name is derived from the input .tbl file, hence the only
        possible collision is if two disp programs contain the same screen
        Listing names in the .doit allows us to rename and can enforce uniqueness</t>
<t tx="ntallen.20110111074722.2071">./doit -p 110112.1
    Where do I look?
    run=110112.1
    for base in . $FltNd$HomeDir; do
      $base/$run
      $base/raw/$run
      for cat in Flight Cal Data Junk; do
        $base/raw/$cat/$run
      done
    done
</t>
<t tx="ntallen.20110113085104.2073">mkdoit3 -M -o &lt;doit_name&gt; &lt;sourcename&gt;
mkdoit3 [-o &lt;doit_name&gt;] &lt;sourcename&gt;

  -M output make dependencies to &lt;doit_name&gt;.dep
  -o &lt;doit_name&gt; specifies the name of the doit script.
     Not really optional for -M, since the name of the script
     is crucial to spelling the dependencies.

Syntax supported:
    display demodisp [options]
    client democlt [options]
    # extraction &lt;name&gt; [options]
    # algorithm &lt;name&gt; [options]
    batchfile &lt;name&gt;
    phrtg [options]
    memo [logfilename]</t>
<t tx="ntallen.20110113085104.2075">mkdoit3 -M -o doit demo.doit

will produce output like the following:
    
    doit : demo.doit demodispnc.cc demo2dispnc.cc

appgen will produce output like:
    
    Makefile : demo.spec
    doit : demo.doit
        mkdoit3 -o doit demo.doit
    doit.dep : demo.doit
        mkdoit3 -M -o doit demo.doit
    include doit.dep
    OBJ += doit.dep
    </t>
<t tx="ntallen.20110117144243.2077">For a general-purpose driver, we generally will want to support both cmds and telemetry. There are a variety of configurations, depending on whether the telemetry interface is synchronous or asynchronous and what other I/O the driver needs to support. However it seems as though a standard, simple framework for handling the multiple interfaces might be worth some effort.

For apps that can stick to read/write, a select interface would work. For apps that need to respond to interrupts, e.g. via pulses, the same general approach could work, but we'd need to use ionotify instead of select and process the various pulses.

tm_event_add_fd( fd, O_RDONLY, read_event );
tm_event_add_send_id( send_id, TM_event );
tm_event_add_fd( fd, O_WRONLY, write_event );
tm_event_add_irq(...);

tm_event_loop() {
  copy operate() from idx64
  when a pulse arrives, look it up in the table, call the relevant
  routine, then rearm.
}</t>
<t tx="ntallen.20110131090023.2079">The subbus architecture has been reworked to provide the proper level of
abstraction and modularity. Programs will link with a library, which will
access a resident driver via resource manager semantics. Different hardware
will require different drivers. At present, we require support for DACS and
SYSCON/104, so there will be two drivers:
    subbusd_serusb
    subbusd_sc104
</t>
<t tx="ntallen.20110131090023.2080"></t>
<t tx="ntallen.20110131090023.2081"></t>
<t tx="ntallen.20110131090023.2082">The documentation for the serial protocol is located in the arp-fpga
project.</t>
<t tx="ntallen.20110131090023.2083"></t>
<t tx="ntallen.20110211111845.2089"></t>
<t tx="ntallen.20110211111845.2090">The mkrtkit module is the start of a packaging scheme that should keep track of
the files that need to be installed on GSE systems or flight systems. Each
package identifies the files it requires and what other packages it requires.</t>
<t tx="ntallen.20110211111845.2091">In general, a package's version number should be incremented:
    Whenever the list of files required changes
    Whenever any of the listed files is updated
    Whenever a required package is updated

Therefore I should have a utility to check these conditions.
The package install script should never overwrite an existing
installed package. If the version is the same as an installed
package, then it should compare the file lists and check the
files for modification or change times. If any are newer than
the existing tar file, then an error should be reported, and
the user should manually increment the version number of the
package.

This requires that the packages be checked in the reverse
order of their dependency, so a directed acyclic graph of
all the packages needs to be constructed to make sure the
dependent packages are installed first.

Implicit is the fact that the tar archives should be
created during the install step, not during mkrtkitarch,
and hence the package tar files will already exist during
an invocation of mkrtkit.
</t>
<t tx="ntallen.20110215130743.2095"></t>
<t tx="ntallen.20110215130743.2096"></t>
<t tx="ntallen.20110215130743.2097">DG and DCCC are examples of other programs which need to receive commands
but would probably rather not read directly from the command server.
Instead, they may wish the command server to write to them.
These programs must set up their own device interface.
Within cmdgen, these could be treated the same as Readers with the
tweak of the interface:
    %INTERFACE &lt;DG:DG/cmd&gt;
where the part after the colon is a relative path to the device.
cis_turf could still refer to if_DG, and would do the right thing.

Programs other than the command server could talk directly to these
devices, bypassing the command server's overhead.

Note the implicit limitation that this type of interface addresses
at most one other process whereas the read interfaces may address
multiple readers.
</t>
<t tx="ntallen.20110216082835.2101"></t>
<t tx="ntallen.20110216082835.2102">Since Soldrv needs to talk to DCCC frequently and can use low-level encoding,
it makes sense to provide a direct route not going through cmdsrvr. That
quickly leads me to the idea of generalizing that type of interface, which
would benefit the implementation of DG/cmd as well.</t>
<t tx="ntallen.20110216082835.2103">%INTERFACE &lt;node:path&gt;

Consider output to C++, then the interfaces can be separate classes, and cis_turf could be
overridden for each class.

investigate difficulty.

cis_turf would have to move to one of the C++ libs...

    </t>
<t tx="ntallen.20110216082835.2104">Remove old cis_turf() interface.
</t>
<t tx="ntallen.20110216082835.2105">These will have a common API on the command server end using cis_turf
and the %INTERFACE syntax.

Initialization of these interfaces can occur at startup. This requires that
we order the startup script to ensure the necessary interfaces exist before
Cmd is started.</t>
<t tx="ntallen.20110216082835.2106"></t>
<t tx="ntallen.20110216082835.2107"></t>
<t tx="ntallen.20110216082835.2108"></t>
<t tx="ntallen.20110216082835.2110">Currently, the SW Status interface is a kluge that needs a special file before root.cmd
and a special hook after quit to cleanup. If the TM connection were just another interface,
then it could get cleaned up like all the rest.

%INTERFACE &lt;SWStat:DG/data&gt;

This is the same syntax as the write interface, but:
    DG/data is not the complete relative path (should be DG/data/SWStat)
    DG/data marks this as a TM data channel and invokes
    
    send_id if_SWStat;
    if_SWStat.TM_id = Col_send_init("SWStat", &amp;SWStat, sizeof(SWStat), 0);
    
We don't use cis_turf, since that assumes ASCII encoding. Could manually
invoke Col_send(if_SWStat.TM_id);

Or could use if_SWStat-&gt;turf() to invoke Col_send().</t>
<t tx="ntallen.20110218102714.2117">%INTERFACE &lt;SUBBUS&gt; special case that should not support turf(), but will support setup() (no args) and reset().</t>
<t tx="ntallen.20110218102714.2118">cmdgen/cmdalgo.h
  Define classes for each interface type
    cmd_if cmdsrvr owns the interface path. Device reads from /dev/huarp/$Exp/cmd/&lt;if&gt;
    dev_if device owns the interface path. cmdsrvr writes to path
    data_if writing to DG/data/* turf()
    subbus_if dev_if with fixed path and no turf()
    
Basically I want to create a group of classes each supporting some of the following:
    Setup();
        Establishes the interface and may initiate a connection.
        Different classes may require different appropriate arguments.
    turf();
        Transmit a command (or data) to the client or clients. I don't use 'Send'
        in order to avoid confusion with the underlying mechanisms used.
        Different classes may require different appropriate arguments.
        (some may take no arguments)
    Shutdown();
        Transmit a quit command and close the connection.

    
  change cis_turf() prototype.
  Add cis_interfaces_close() prototype
  
cis.c

    cis_turf();

        Check type of the interface.

    cis_interfaces_close(); call during quit</t>
<t tx="ntallen.20110218102714.2119">Recognize zero-length write as a quit request.
</t>
<t tx="ntallen.20110220101447.2123">The %INTERFACE keyword is used to define how to communicate with another process.
In general, an %INTERFACE definition can address three main issues:
    Initialization: May establish a connection to another process or make
      an interface available for other processes to connect to.
    Communication: May provide a common syntax for IPC via turf() method.
    Shutdown: Communicates "Quit" to all interfaces and closes the connections.

There are several different types of interfaces, and not all will implement
all of these features.</t>
<t tx="ntallen.20110220101447.2124">%INTERFACE &lt;SUBBUS&gt;

Subbus initialization is handled by oui.
Subbus communication is handled by the subbus lib.
Subbus termination is the only reason for including this interface definition.

The simplest implementation of this interface will not define a class at all.
It will output #include "subbus.h" at the definition and subbus_quit() in the
shutdown list.
</t>
<t tx="ntallen.20110421132300.2127"></t>
<t tx="ntallen.20110421132300.2128">Raw data is maintained in runs. Each run is categorized as one of junk, data, cal, preflight or flight data.
Runs are fingerprinted, copied off of instrument data systems and distributed to various archives.
The challenge is in keeping track of where each run is stored and when data can safely be deleted.

Ideally, we would maintain a database of runs and archive locations. This is complicated by
the need have the information handy when disconnected from the network. That means the database needs to be
cached locally with any updates queued for application when reconnected to the net.</t>
<t tx="ntallen.20110421132300.2129">saverun: creation of a run. Good time to assess the size of the run, copy the saverun.log, etc.
reduce/copy: creating a copy of the run
backup: note that a particular site has been backed up
verify: verify a copy of a run via dircksum: results should be reported to database
delete: free up space


</t>
<t tx="ntallen.20110421132300.2130">Experiment:
    Exp_ID: #
    Exp_Mnc: HWV
    Exp_Desc:
    
Run:
    Run_ID: #
    Run: YYMMDD.RRR
    Run_Date: date
    Exp_ID: #
    Type: Junk/Data/Cal/Preflight/Flight
    Size: KB
    Log: (contents of saverun.log)
    Dircksum: y/n
    
Location:
    Loc_ID: #
    Loc_Name:
    Loc_Desc:

Repository:
    Repo_ID: #
    Repo_Name: hwvgse, hwv, fldqnx6, bottesini, cd
    Repo_Type: disk/CD/server
    Loc_ID: #

Copy:
    Copy_ID: #
    Run_ID: #
    Loc_ID: #
    Copy_Date: date
    Verify_Date: date
</t>
<t tx="ntallen.20110421132300.2131">List runs on hwv that have not been copied
List runs on hwv with more than 2 copies, sorting by size or n_copies
</t>
<t tx="ntallen.20110609114734.2137"></t>
<t tx="ntallen.20110609114734.2138"></t>
<t tx="ntallen.20110609114734.2139"></t>
<t tx="ntallen.20110609114734.2140"></t>
<t tx="ntallen.20110609114734.2141"></t>
<t tx="ntallen.20110609114734.2142"></t>
<t tx="ntallen.20110609114734.2143"></t>
<t tx="ntallen.20110609114734.2144">Checking "detrend" marks every graph on the axes to be detrended:
    Mark axis as detrended
    For each graph:
        Create a derived variable with the current var as source
        Point graph to the derived variable
        Remove the graph from the source var's list of graphs
        Add the graph to the derived var's list of graphs

This means the source variable itself is no longer being graphed.
This is a shorthand. I have not created a new plot_graph or new plot_lines,
and I have not changed the name of the line, graph, axes, pane or figure.

If I now add a new variable to the axes, what happens?
    Right now it comes in undetrended, even though the axes are checked
    as detrended. If I undetrend, the new var is not affected. The old
    one is undetrended. Then checking detrend detrends both vars.
    
    Other possibilities:
        We now have a mixed graph, so clear the detrend checkbox
        and rename the previously detrended graphs accordingly
        
        Always rename graphs when deriving. Provide logic to go both
        directions (derive and underive) (or just store the underived
        name when generating the derived name). If all graphs reference
        variables of the same derived type (e.g. Var_Detrend) then
        check that box.
        
        But do I rename the lines as well as the graph?
            Currently, there is no means to manually change the graph name,
            It is the name of the source variable.
            We can manually rename the individual lines.
            So if we perform a derivation, we could:
                derive new name for the variable
                derive new names for the lines based on the old names
            If we underive, then what?
                We could cache the original name, but we'd need a stack
                in the event of multiple derivations:
                    Plot SSP(:,1:3)
                    Limit x range to SSP(50:1000,1:3)
                    rename first line to bkgrnd
                    Detrend: rename graph to detrend(SSP(50:1000,:))
                    rename lines to detrend(SSP(50:1000,1))
                    and detrend(bkgrnd)
                    rename first line to det_bkgrnd
                    Undetrend:
                        should be able to canonically rename graph
                        should be able to canonically rename lines
                          unless renamed manually
                        If canonical rename fails, just keep the current name.
        
        When stacking derivations, follow the same logic:
            check detrend: detrend box checked
            check psd: psd box checked, detrend box unchecked
            check detrend would then go one deeper
            unchecking psd would pop back to the detrended plot,
            and hence mark the axes as detrended.

The fact that the plot_line objects remain means the idea of constraining the detrend in both row and column
might need to be reworked. In that case, the instead of swapping variables, we might want to swap graphs.
In other words:
    
Checking "detrend" marks every graph on the axes to be detrended:
    Mark axis as detrended
    For each graph:
        Create a derived variable with the current var as source
        Create a derived graph pointing to the derived var
        Remove the graph from the plot_axes' list of graphs
        Add the derived graph to the plot_axes' list of graphs
        Where do I find the old graph? It would have to be saved in the
          derived graph, but I'd also have to deal with the case where
          a derived variable is graphed off of the variable tab. In that
          case, there would be no original graph, so when undetrending,
          the new graph would have to be created.

Alternately, create a new plot_graph for the derived plot and delete the old.
Reverse the process on undetrend. This allows us to recover the space required
for the line and widget objects.

This may be unnecessary work, since the derivation should only be performed
on visible columns, so although some memory is used, no extra processing
is required. But the choice of implementations can depend on the derivation.

Summary:
    
When adding or subtracting graphs from axes, re-evaluate detrend status (and status of all other derivations).
Probably don't need to explicitly invoke plot_axes::Update_Axis_Pane(), because that will be handled by
got_focus(), which is called after the graph is created or destroyed.

Open question: should I rename graphs and lines when performing a derivation? If so, how?</t>
</tnodes>
</leo_file>
