ICOSWave Compilation {
  Summary output {
    ICOS Waveform <name> {
	                  specified  actual
	  SampleRate
	  NetSamples
	  Iz
	  dI/dt
	  Cycle Length
	  Stepsize
	  Ramp {
	    Istart
		Istop
		Tramp
	  }
	  Tz:Time RawSamples/NetSamples
	}
	Add Nsteps to summary
  }
  Figure out sampling first {
    Nsample = number of (net) samples specified in the ramp
	NetRate = samples/sec
	RawRate = samples/sec
	
    Could have either specified Nsample or SampleRate
	In either case, Nsample is assumed to be adjustable.
	if ( Nsample is specified ) {
	  SampleRate = Nsample/Tramp /sec/1;
    }
	if (SampleRate is not legal) {
	  if (it was specified) complain;
	  pick the next higher sample rate
	}
	Nsamplep = SampleRate * Tramp;
	
  }
  Determine Tz, Trecycle
  Decide on a resolution {
    GCD of Tz and Tramp(s) is a good place to start,
	but when these aren't set explicitly, chances are
	there won't be an exact answer that fits.
	
	Suppose we establish a criteria of accuracy in time
	of 1% of the total specified cycle length meaning
	we will tolerate the actual Tz or Tramp being longer
	by up to 1% of the total specified cycle length.
	The largest step size possible would then be
	min(Tz,Tramp(s)) + .01*Tcycle
	
	Let Ti be all of the time lengths we're trying to hit
	ordered from smallest to largest. Let dT be our
	tolerance.
	n divisor of T0 to determine the stepsize
	i index into Ti
	m multiplier of stepsize to hit Ti
	
	for ( n = 1; n < 100; n++ ) {
	  maxstep = floor((T0 + dT)/n);
	  minstep = ceil((T0 - dT)/n);
	  minmult = 1;
	  maxmult = 100;
	  for ( i = 1; minstep < maxstep && i < NT; i++ ) {
	    min_m = ceil(Ti/(T0+dT));
		max_m = floor((Ti+dT)/T0);
		minminstep = maxstep;
		maxmaxstep = minstep;
		for ( m = min_m; m <= max_m; m++ ) {
		  myminstep = ceil(Ti/m);
		  if ( myminstep < minminstep ) minminstep = myminstep;
		  mymaxstep = floor((Ti+dT)/m);
		  if ( mymaxstep > maxmaxstep ) maxmaxstep = mymaxstep;
		}
		if ( minminstep > minstep ) minstep = minminstep;
		if ( maxmaxstep < maxstep ) maxstep = maxmaxstep;
	  }
	  if ( minstep <= maxstep ) {
	    anything in this range will apparently work
	  }
	}
	
    but what is really going to be driving resolution
    is how short we want Trecycle to be. If we define
    resolution to be the number of steps in a compiled
    waveform, then resolution will be greater than or
    equal to Tcycle/min(Tz,Tramp,Trecycle). Presumably
    we will want Trecycle to be the shortest here, and
    if we want it to be less than 1%, say, then resolution
    will need to be greater than 100.

    If Trecycle were specified, then we could just use
    gcd(Tz,Tramp,Trecycle), but as a free parameter it
    gets trickier. We can start with gcd(Tz,Tramp). If
    that gives a resolution below 100, we need to look
    for a divisor that gets us into the right range.
    If that doesn't work, we need to arbitrarily choose
    a resolution in the right range.
    What's the right range? 100-300? Whatever.

	stepsize = 0;
	Tcycle = Tz + sum(Tramp);
	step = gcd(Tz,Tramp);
	nsteps = Tcycle/step;
	if ( nsteps < nstepsmin ) {
	  /* The perfect answer has too few steps (Trecycle is too long)
		look for a divisor of step between
		ceil( nstepsmin/nsteps ) and floor( nstepsmax/nsteps )
		which yields a number of steps closest to nstepsopt
		in a logarithmic sense. */
      divmin = ceil( nstepsmin/nsteps );
	  divmax = floor( nstepsmax/nsteps );
	  logdivopt = log(((double)nstepsopt)/nsteps);
	  logdiverr = -1;
	  for ( divisor = divmin; divisor <= divmax; divisor++ ) {
	    if ( step % divisor == 0 ) {
		  mylogdiverr = fabs( log(divisor) - logdivopt );
		  if ( logdiverr < 0 || mylogdiverr < logdiverr  ) {
		    logdiverr = mylogdiverr;
			bestdiv = divisor;
		  } else if ( logdiverr >= 0 && mylogdiverr > logdiverr ) {
		    break;
		  }
		}
	  }
	  if (logdiverr >= 0) {
	    stepsize = step / divisor;
	  } else {
	    /* A nice, simple divisor exists, but it requires
		   Trecycle to be unacceptably large. Will have to
		   approximate. */
	  }
	} else if ( nsteps <= nstepsmax ) {
	  /* All set! */
	  stepsize = step;
	} else {
	  /* The perfect answer has way too many steps */
	}
	if ( stepsize == 0 ) {
	  /* Could not find a perfect answer. Go for a nstepsopt
		resolution.
		If the resolution isn't exact, we need to increase
		Tz & Tramp to a resolution boundary. Changing Tramp
		requires adjust Istop as well. */
	  step = ceil(Tcycle/nstepsopt);
	  Tzsteps = ceil(Tz/step);
	  Tzp = step * Tzsteps;
	  Trampsteps = ceil(Tramp/step);
	  Trampp = step * Trampsteps;
	  Istopp = Istart + dIdt*Trampp;
	}

  }
  Determine Trecycle {
    if raw samples are less than 16384, we
    can recycle quicker, say 5 usecs. Otherwise, we need to allow
	time for interrupt latency, which might be more like 100
	usecs, but TBD.
  }
  Allocate D/A channels {
    Allocate a D/A "state" for Iz and each Ramp
	After allocation, optimize to determine how each state
	will be implemented.
	Iz holds ramp in reset and out of the loop
	Ramp states may or may not be preceeded by a reset {
	  If reset, current during the preceeding reset should
	  be Istart for the ramp.
	  First ramp doesn't really have a reset option {
	    it is always preceeded by a reset, but the current
		during that reset should be Iz, not Istart
	  }
	  Difference could be codified by creating a state for
	  each transition: {
		Iz trigger reset
		Iz trigger reset
		Istart0 trigger !reset ramp
		Istart0 trigger !reset ramp
	  }
	}
  }
}
