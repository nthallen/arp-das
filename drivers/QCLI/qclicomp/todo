ICOSWave Compilation {
  Decide on a resolution {
    GCD of Tz and Tramp(s) is a good place to start,
    but what is really going to be driving resolution
    is how short we want Trecycle to be. If we define
    resolution to be the number of steps in a compiled
    waveform, then resolution will be greater than or
    equal to Tcycle/min(Tz,Tramp,Trecycle). Presumably
    we will want Trecycle to be the shortest here, and
    if we want it to be less than 1%, say, then resolution
    will need to be greater than 100.

    If Trecycle were specified, then we could just use
    gcd(Tz,Tramp,Trecycle), but as a free parameter it
    gets trickier. We can start with gcd(Tz,Tramp). If
    that gives a resolution below 100, we need to look
    for a divisor that gets us into the right range.
    If that doesn't work, we need to arbitrarily choose
    a resolution in the right range.
    What's the right range? 100-300? Whatever.

	stepsize = 0;
	Tcycle = Tz + sum(Tramp);
	step = gcd(Tz,Tramp);
	nsteps = Tcycle/step;
	if ( nsteps < nstepsmin ) {
	  /* The perfect answer has too few steps (Trecycle is too long)
		look for a divisor of step between
		ceil( nstepsmin/nsteps ) and floor( nstepsmax/nsteps )
		which yields a number of steps closest to nstepsopt
		in a logarithmic sense. */
      divmin = ceil( nstepsmin/nsteps );
	  divmax = floor( nstepsmax/nsteps );
	  logdivopt = log(((double)nstepsopt)/nsteps);
	  logdiverr = -1;
	  for ( divisor = divmin; divisor <= divmax; divisor++ ) {
	    if ( step % divisor == 0 ) {
		  mylogdiverr = fabs( log(divisor) - logdivopt );
		  if ( logdiverr < 0 || mylogdiverr < logdiverr  ) {
		    logdiverr = mylogdiverr;
			bestdiv = divisor;
		  } else if ( logdiverr >= 0 && mylogdiverr > logdiverr ) {
		    break;
		  }
		}
	  }
	  if (logdiverr >= 0) {
	    stepsize = step / divisor;
	  } else {
	    /* A nice, simple divisor exists, but it requires
		   Trecycle to be unacceptably large. Will have to
		   approximate. */
	  }
	} else if ( nsteps <= nstepsmax ) {
	  /* All set! */
	  stepsize = step;
	} else {
	  /* The perfect answer has way too many steps */
	}
	if ( stepsize == 0 ) {
	  /* Could not find a perfect answer. Go for a nstepsopt
		resolution.
		If the resolution isn't exact, we need to increase
		Tz & Tramp to a resolution boundary. Changing Tramp
		requires adjust Istop as well. */
	  step = ceil(Tcycle/nstepsopt);
	  Tzsteps = ceil(Tz/step);
	  Tzp = step * Tzsteps;
	  Trampsteps = ceil(Tramp/step);
	  Trampp = step * Trampsteps;
	  Istopp = Istart + dIdt*Trampp;
	}

  }
  Now figure out the sampling {
    Could have either specified Nsample or SampleRate
	In either case, Nsample is assumed to be adjustable.
	if ( Nsample is specified ) {
	  SampleRate = Nsample/Tcycle;
    }
	if (SampleRate is not legal) {
	  if (it was specified) complain;
	  pick a nearby sample rate instead
	}
	Nsamplep = SampleRate * Tcycle;
  }
}
