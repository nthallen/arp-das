/* Definition of waveform names. */
ATTR Key : DefTableKey;
ATTR Sym : int;
RULE: ICOSWave ::= 'ICOS' 'Waveform' DefIdent '{' ICOSCmds '}' END;
RULE: DefIdent ::= Ident COMPUTE DefIdent.Sym = Ident; END;
SYMBOL DefIdent INHERITS IdDefScope, Unique COMPUTE
  IF (NOT (THIS.Unique),
	  message (ERROR, CatStrInd ("Waveform is multiply defined: ", THIS.Sym),
			   0, COORDREF));
END;

SYMBOL Wave COMPUTE
  SYNT.Key = CONSTITUENT DefIdent.Key;
  SYNT.Sym = CONSTITUENT DefIdent.Sym;
END;

/*-----------------------------------------------*/
/* Make sure only one Tz is defined per waveform */
/*-----------------------------------------------*/
SYMBOL TzDef INHERITS TzUnique COMPUTE
  INH.Key = INCLUDING Wave.Key; 
  IF (NOT (THIS.TzUnique),
	  message (ERROR, "Tz is multiply defined", 0, COORDREF));
END;

/*-----------------------------------------------*/
/* Make sure only one Iz is defined per waveform */
/*-----------------------------------------------*/
SYMBOL IzDef INHERITS IzUnique COMPUTE
  INH.Key = INCLUDING Wave.Key; 
  IF (NOT (THIS.IzUnique),
	  message (ERROR, "Iz is multiply defined", 0, COORDREF));
END;

/*---------------------------------------------------*/
/* Make sure only one Ncoadd is defined per waveform */
/*---------------------------------------------------*/
SYMBOL NcoaddDef INHERITS NcoaddUnique COMPUTE
  INH.Key = INCLUDING Wave.Key; 
  IF (NOT (THIS.NcoaddUnique),
	  message (ERROR, "Ncoadd is multiply defined", 0, COORDREF));
END;

/*---------------------------------------------------*/
/* Make sure only one Sample is defined per waveform */
/*---------------------------------------------------*/
SYMBOL NsampleDef INHERITS SampleUnique END;
SYMBOL RateDef INHERITS SampleUnique END;
CLASS SYMBOL SampleUnique COMPUTE
  INH.Key = INCLUDING Wave.Key; 
  IF (NOT (THIS.SampleUnique),
	  message (ERROR,
	   "Only one definition of Nsample or SampleRate is allowed",
	    0, COORDREF));
END;

/*--------------------------*/
/* Units                    */
/*--------------------------*/
ATTR Value: double;
RULE: Current ::= FloatVal CurrentUnit COMPUTE
  Current.Value = MUL(FloatVal.Value,CurrentUnit.Value);
END;
RULE: Time ::= FloatVal TimeUnit COMPUTE
  Time.Value = MUL(FloatVal.Value,TimeUnit.Value);
END;
RULE: CurrentUnit ::= 'A' COMPUTE CurrentUnit.Value = 1; END;
RULE: CurrentUnit ::= 'mA' COMPUTE CurrentUnit.Value = 0.001; END;
RULE: CurrentUnit ::= 'uA' COMPUTE CurrentUnit.Value = 0.000001; END;
RULE: TimeUnit ::= 'sec' COMPUTE TimeUnit.Value = 1; END;
RULE: TimeUnit ::= 'msec' COMPUTE TimeUnit.Value = 0.001; END;
RULE: TimeUnit ::= 'usec' COMPUTE TimeUnit.Value = 0.000001; END;
RULE: FloatVal ::= Integer COMPUTE FloatVal.Value = CAST(double,Integer); END;
RULE: FloatVal ::= Float COMPUTE FloatVal.Value = atof(StringTable(Float)); END;
SYMBOL Percent COMPUTE
  SYNT.Value = DIV( CONSTITUENT FloatVal.Value, 100. );
END;
SYMBOL Istart COMPUTE SYNT.Value = CONSTITUENT Current.Value; END;
SYMBOL Istop COMPUTE SYNT.Value = CONSTITUENT Current.Value; END;
SYMBOL PrepTime COMPUTE SYNT.Value = CONSTITUENT Time.Value; END;

/*-------------------------------------------------*/
/* Make sure only one dIdt is defined per waveform */
/*-------------------------------------------------*/
ATTR dIdtAssessed: VOID;
RULE: dIdt ::= 'dI' '/' 'dt' '=' Current '/' TimeUnit COMPUTE
  dIdt.Value = DIV(Current.Value,TimeUnit.Value);
END;
SYMBOL dIdt COMPUTE
  INH.Key = INCLUDING Wave.Key; 
  SYNT.dIdtAssessed = ORDER(
	SetdIdtDefined(THIS.Key,1,2),
	ResetdIdt(THIS.Key, THIS.Value ));
  IF(EQ(GetdIdtDefined(THIS.Key,0),2),
	  message (ERROR, "dI/dt is multiply defined", 0, COORDREF))
	    <- INCLUDING ICOSWave.dIdtAssessed;
END;

SYMBOL ICOSWave COMPUTE
  INH.Key = INCLUDING Wave.Key;
  SYNT.dIdtAssessed = CONSTITUENTS ( ICOSRamp.dIdtAssessed, dIdt.dIdtAssessed );
  IF(EQ(GetdIdtDefined(THIS.Key,0),0),
    message(ERROR, "dI/dt undefined", 0, COORDREF))
      <- THIS.dIdtAssessed;
  SYNT.dIdt = GetdIdt(THIS.Key, 1.) <- THIS.dIdtAssessed;
END;

/*-------------------------------------------------------------------*/
/* Istart, Istop and Tramp */
/*-------------------------------------------------------------------*/
ATTR dIdt, Istart, Istop, Tramp: double;
ATTR Iramp, Istart1, Istop1: double; /* Final values */
ATTR WaveKey : DefTableKey;

SYMBOL ICOSRamp COMPUTE
  SYNT.Key = NewKey();
  INH.WaveKey = INCLUDING Wave.Key;
  INH.dIdt = GetdIdt(THIS.WaveKey, 1.) <- INCLUDING ICOSWave.dIdtAssessed;
END;
RULE: ICOSRamp ::= 'Ramp' Istart Istop PrepTime COMPUTE
  ICOSRamp.dIdtAssessed = ORDER(
	SetdIdtDefined(ICOSRamp.WaveKey,1,2),
	ResetdIdt(ICOSRamp.WaveKey,DIV(SUB(Istop.Value,Istart.Value),PrepTime.Value)));
  IF(EQ(GetdIdtDefined(ICOSRamp.WaveKey,0),2),
	  message (ERROR, "dI/dt is multiply defined", 0, COORDREF))
	    <- INCLUDING ICOSWave.dIdtAssessed;
  ICOSRamp.Istart = Istart.Value;
  ICOSRamp.Istop = Istop.Value;
  ICOSRamp.Tramp = PrepTime.Value;

  ICOSRamp.Istart1 = ICOSRamp.Istart;
  ICOSRamp.Istop1 = ADD(ICOSRamp.Istart,ICOSRamp.Iramp);
END;
RULE: ICOSRamp ::= 'Ramp' Istart Istop COMPUTE
  ICOSRamp.dIdtAssessed = 1;
  ICOSRamp.Istart = Istart.Value;
  ICOSRamp.Istop = Istop.Value;
  ICOSRamp.Tramp = DIV(SUB(Istop.Value,Istart.Value),ICOSRamp.dIdt);

  ICOSRamp.Istart1 = ICOSRamp.Istart;
  ICOSRamp.Istop1 = ADD(ICOSRamp.Istart,ICOSRamp.Iramp);
END;
RULE: ICOSRamp ::= 'Ramp' Istart PrepTime COMPUTE
  ICOSRamp.dIdtAssessed = 1;
  ICOSRamp.Istart = Istart.Value;
  ICOSRamp.Istop = ADD(Istart.Value,MUL(PrepTime.Value,ICOSRamp.dIdt));
  ICOSRamp.Tramp = PrepTime.Value;

  ICOSRamp.Istart1 = ICOSRamp.Istart;
  ICOSRamp.Istop1 = ADD(ICOSRamp.Istart,ICOSRamp.Iramp);
END;
RULE: ICOSRamp ::= 'Ramp' Istop PrepTime COMPUTE
  ICOSRamp.dIdtAssessed = 1;
  ICOSRamp.Istart = SUB(Istop.Value,MUL(PrepTime.Value,ICOSRamp.dIdt));
  ICOSRamp.Istop = Istop.Value;
  ICOSRamp.Tramp = PrepTime.Value;

  ICOSRamp.Istop1 = ICOSRamp.Istop;
  ICOSRamp.Istart1 = SUB(ICOSRamp.Istop,ICOSRamp.Iramp);
END;

/*---------------------*/
/* Figure out sampling */
/*---------------------*/
ATTR Tramps: double;
SYMBOL ICOSWave COMPUTE
  SYNT.Tramps = CONSTITUENTS ICOSRamp.Tramp
	WITH( double, ADD, IDENTICAL, ZERO );
END;

ATTR Naverage: int;
RULE: Naverage ::= COMPUTE Naverage.Naverage = 1; END;
RULE: Naverage ::= '/' Integer COMPUTE
  Naverage.Naverage = Integer;
END;

ATTR RawRate, NetRate: double;
ATTR Nsample: long;
ATTR RateDef: RateDefP;

RULE: NsampleDef ::= 'Nsample' '=' Integer COMPUTE
  NsampleDef.Nsample = Integer;
  NsampleDef.RateDef =
    NewRateDefPtr( DIV( NsampleDef.Nsample, INCLUDING ICOSWave.Tramps ), 1,
					0, COORDREF );
END;
RULE: RateDef ::= 'SampleRate' '=' Integer '/' TimeUnit Naverage COMPUTE
  RateDef.RawRate = DIV(Integer,TimeUnit.Value);
  RateDef.Naverage = Naverage.Naverage;
  RateDef.RateDef =
    NewRateDefPtr( RateDef.RawRate, Naverage.Naverage,
					1, COORDREF );
END;
SYMBOL ICOSWave COMPUTE
  SYNT.RateDef =
    CONSTITUENTS ( NsampleDef.RateDef, RateDef.RateDef )
	WITH ( RateDefP, PICKRATE, IDENTICAL, NULLRATE );
  SYNT.RawRate = PTRSELECT(THIS.RateDef,samples);
  SYNT.Naverage = PTRSELECT(THIS.RateDef, naverage);
  SYNT.NetRate = DIV(THIS.RawRate, THIS.Naverage );
END;

/*----------------*/
/* Figure out Tz  */
/*----------------*/
ATTR Tz: double;
SYMBOL TzSpec COMPUTE
  INH.RawRate = INCLUDING ICOSWave.RawRate;
END;
RULE: TzSpec ::= TzTime COMPUTE
  TzSpec.Tz = CONSTITUENT Time.Value;
END;
RULE: TzTime ::= Time END;
RULE: TzSpec ::= Percent COMPUTE
  TzSpec.Tz = MUL(INCLUDING ICOSWave.Tramps, Percent.Value);
END;
SYMBOL SampleSpec COMPUTE
  INH.Naverage = INCLUDING ICOSWave.Naverage;
END;
RULE: SampleSpec ::= Integer 'Raw' 'Samples' COMPUTE
  SampleSpec.Nsample =
    MUL( DIV_UP( Integer, SampleSpec.Naverage ),
	  SampleSpec.Naverage );
END;
RULE: SampleSpec ::= Integer 'Samples' COMPUTE
  SampleSpec.Nsample =
    MUL(Integer, INCLUDING ICOSWave.Naverage);
END;
RULE: TzSpec ::= SampleSpec COMPUTE
  IF( EQ( TzSpec.RawRate, 0. ),
	  message (ERROR, "Tz specified in samples, but rate is zero", 0, COORDREF));
  TzSpec.Tz = IF( GT(TzSpec.RawRate, 0. ),
    DIV( SampleSpec.Nsample, TzSpec.RawRate ), 0. );
END;
SYMBOL ICOSWave COMPUTE
  SYNT.Tz = CONSTITUENTS TzSpec.Tz
    WITH ( double, ADD, IDENTICAL, ZERO );
END;

/*-----------------------*/
/* Determine Resolution  */
/*-----------------------*/
CHAIN rcnt: int;
CHAIN rvals: longP;
ATTR Stepsize: long;
SYMBOL ICOSWave COMPUTE
  CHAINSTART HEAD.rcnt = 0;
  CHAINSTART HEAD.rvals = malloc(MUL(sizeof(long),TAIL.rcnt));
  SYNT.Stepsize = PickRes( TAIL.rcnt, TAIL.rvals );
END;
SYMBOL TzSpec COMPUTE
  THIS.rcnt = ADD( THIS.rcnt, IF( GT( THIS.Tz, 0. ), 2, 0 ) );
  THIS.rvals = IF( GT(THIS.Tz, 0.),
    ORDER( Set_rval( THIS.rvals, THIS.rcnt, THIS.Tz ),
		   Set_rval( THIS.rvals, ADD(THIS.rcnt,1), THIS.Tz )),
	THIS.rvals );
END;
SYMBOL ICOSRamp COMPUTE
  THIS.rcnt = ADD( THIS.rcnt, 1 );
  THIS.rvals = Set_rval( THIS.rvals, THIS.rcnt, THIS.Tramp );
END;

/*-------------------------------------------*/
/* Calculate actual durations given Stepsize */
/*-------------------------------------------*/
 /* usecs in Iz, single ramp and full cycle0 */ 
ATTR Tzi, Trampi, Tcyc0: long;
 /* Steps (of Stepsize) in Iz, single ramp, cycle0 */
ATTR Szi, Srampi, Scyc0: int;
 /* Final secs in Iz, single ramp and all ramps: */
ATTR Tz1, Tramp1, Tramps1: double;
SYMBOL ICOSRamp COMPUTE
  SYNT.Srampi = DIV_UP( usecs(THIS.Tramp),
						INCLUDING ICOSWave.Stepsize );
  SYNT.Trampi = MUL( THIS.Srampi, INCLUDING ICOSWave.Stepsize );
  SYNT.Tramp1 = DIV( THIS.Trampi, 1000000. );
  SYNT.Iramp = MUL( THIS.Tramp1, THIS.dIdt );
END;
SYMBOL ICOSWave COMPUTE
  SYNT.Szi = DIV_UP( usecs(THIS.Tz), THIS.Stepsize );
  SYNT.Tzi = MUL( THIS.Szi, THIS.Stepsize );
  SYNT.Scyc0 = ADD( MUL( 2, THIS.Szi ),
    CONSTITUENTS ICOSRamp.Srampi
	WITH ( long, ADD, IDENTICAL, ZERO ) );
  SYNT.Tcyc0 = MUL( THIS.Scyc0, THIS.Stepsize );
  SYNT.Tramps1 =
    CONSTITUENTS ICOSRamp.Tramp1
	WITH ( double, ADD, IDENTICAL, ZERO );
  SYNT.Tz1 = DIV( THIS.Tzi, 1000000. );
END;

/*--------------------*/
/* Determine Trecycle */
/*--------------------*/
ATTR EstSamples: long; /* Estimated number of raw samples */
ATTR Trcymin: long; /* Minimum length of Trigger Off time in usecs */
ATTR Trcy: long; /* Extra time added to the cycle for Trigger Off */
ATTR Srcy: long; /* Steps of Stepsize added for Trigger Off */
ATTR Trcypre: long; /* Time stolen from cycle for Trigger off */
ATTR Ttrigger: long; /* Length of trigger in usecs */
ATTR Scycle: int; /* Steps of Stepsize in full cycle */
ATTR Tcycle: long; /* Length of total cycle in usecs */
ATTR SplitCycle: int;
ATTR Toff, Ton: long;
ATTR ProgLen: int;
SYMBOL ICOSWave COMPUTE
  SYNT.EstSamples =
	IF( GT( THIS.RawRate, 0. ),
	  CAST(long, floor(
		DIV( MUL( THIS.Tcyc0, THIS.RawRate ),
			 1000000. ))),
	  0 );
  SYNT.Trcymin =
    IF ( GE(THIS.EstSamples, 16384), 200, 10 );
  SYNT.SplitCycle = LT( MUL(4,THIS.Trcymin), THIS.Stepsize );
  SYNT.Trcypre = IF( THIS.SplitCycle, THIS.Trcymin, 0 );
  SYNT.Srcy = IF( THIS.SplitCycle, 0,
				  DIV_UP(THIS.Trcymin, THIS.Stepsize));
  SYNT.Trcy = MUL( THIS.Stepsize, THIS.Srcy );
  SYNT.Toff = IF( THIS.SplitCycle, THIS.Trcymin, THIS.Stepsize );
  SYNT.Ton  = IF( THIS.SplitCycle,
				  SUB(THIS.Stepsize, THIS.Toff),
				  THIS.Toff );
  SYNT.Ttrigger = SUB( THIS.Tcyc0, THIS.Trcypre );
  SYNT.Scycle = ADD( THIS.Scyc0, THIS.Srcy );
  SYNT.Tcycle = ADD( THIS.Tcyc0, THIS.Trcy );
  SYNT.ProgLen = MUL( IF( THIS.SplitCycle, 2, 1), THIS.Scycle );
END;

/*------------------------------------*/
/* Determine actual number of samples */
/*------------------------------------*/
ATTR RawSamples, NetSamples: long; /* Total Raw and net samples */
ATTR RampSamples:long; /* Net samples over ramps */
ATTR TzSamples, TzRawSamples: long; /* Net and raw samples in Tz */
SYMBOL ICOSWave COMPUTE
  SYNT.NetSamples =
	IF( GT( THIS.NetRate, 0. ),
	  CAST(long, floor(
		DIV( MUL( THIS.Ttrigger, THIS.NetRate ),
			 1000000. ))),
	  0 );
  SYNT.RawSamples = MUL( THIS.NetSamples, THIS.Naverage );
  SYNT.RampSamples =
	IF( GT( THIS.NetRate, 0. ),
	  CAST(long, floor(
		MUL( THIS.Tramps1, THIS.NetRate ))),
	  0 );
  SYNT.TzSamples =
	IF( GT( THIS.NetRate, 0. ),
	  CAST(long, floor(
		MUL( THIS.Tz1, THIS.NetRate ))),
	  0 );
  SYNT.TzRawSamples = MUL( THIS.TzSamples, THIS.Naverage );
END;

/*--------------*/
/* Assign D/A's */
/*--------------*/
ATTR Iz: double;

SYMBOL IzDef COMPUTE
  SYNT.Iz = CONSTITUENT Current.Value;
END;
SYMBOL ICOSWave COMPUTE
  SYNT.Iz = CONSTITUENTS IzDef.Iz
    WITH( double, ADD, IDENTICAL, ZERO );
END;

/*------------------------------*/
/* Determine Starting Addresses */
/*------------------------------*/
CHAIN WaveAddr: long;
ATTR LoopAddr: long;
SYMBOL SourceFile COMPUTE
  CHAINSTART HEAD.WaveAddr = 128;
  SYNT.ProgLen = TAIL.WaveAddr;
END;
SYMBOL ICOSWave COMPUTE
  SYNT.LoopAddr = ADD( THIS.WaveAddr, 10 );
  THIS.WaveAddr = ADD( THIS.LoopAddr, THIS.ProgLen );
END;

/*------------------------------*/
/* Produce compiled QCLI output */
/*------------------------------*/

/*------------------------------*/
/* Produce compiled .cmd output */
/*------------------------------*/

/*---------------------------*/
/* Print Summary Information */
/*---------------------------*/
ATTR PTG, WaveIndex: PTGNode;
SYMBOL SourceFile COMPUTE
  SYNT.PTG = PTGFile(
    CONSTITUENTS ICOSWave.WaveIndex
	  WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
    CONSTITUENTS ICOSWave.PTG
	  WITH ( PTGNode, PTGWaves, IDENTICAL, PTGNull ),
	THIS.ProgLen );
  PTGOut( THIS.PTG );
END;
SYMBOL ICOSWave COMPUTE
  SYNT.WaveIndex =
    PTGWaveIndex( PTGId(INCLUDING Wave.Sym), THIS.WaveAddr );
  SYNT.PTG =
    PTGICOSWave( PTGId(INCLUDING Wave.Sym),
	  CONSTITUENTS RateDef.PTG
		WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
	  PTGSampleRate( THIS.RawRate, THIS.Naverage ),
	  CONSTITUENTS NsampleDef.PTG
		WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
	  PTGLong( THIS.RampSamples ),
	  PTGIz( PTGCurrent( MUL(THIS.Iz, 1000.))),
	  PTGdIdt( THIS.dIdt ),
	  PTGTcycle( DIV(THIS.Tcycle,1000.) ),
	  PTGStepsize( THIS.Stepsize ),
	  CONSTITUENTS ICOSRamp.PTG
	    WITH( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
	  CONSTITUENTS (TzTime.PTG, SampleSpec.PTG, Percent.PTG )
	    WITH( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
	  PTGFcycle( DIV(1000000.,THIS.Tcycle) ),
	  PTGTz( PTGTime(MUL(THIS.Tz1,1000.)),
	    THIS.TzRawSamples, THIS.TzSamples,
		MUL( DIV( THIS.Tz1, THIS.Tramps1 ), 100. ) ),
	  PTGTonoff( THIS.Ton, THIS.Toff,
		ADD(THIS.Trcy,THIS.Trcypre)),
	  THIS.Scycle,
	  THIS.ProgLen,
	  THIS.WaveAddr
	);
END;

SYMBOL RateDef COMPUTE
  SYNT.PTG = PTGSpecd(
    PTGSampleRate( THIS.RawRate, THIS.Naverage ) );
END;
SYMBOL NsampleDef COMPUTE
  SYNT.PTG = PTGSpecd( PTGLong( THIS.Nsample ));
END;

SYMBOL ICOSRamp COMPUTE
  SYNT.PTG =
    PTGRamp(
	  CONSTITUENTS Istart.PTG
	    WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
      PTGCurrent( MUL(THIS.Istart1,1000.) ),
	  CONSTITUENTS Istop.PTG
	    WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
      PTGCurrent( MUL(THIS.Istop1,1000.) ),
	  CONSTITUENTS PrepTime.PTG
	    WITH ( PTGNode, PTGSeq, IDENTICAL, PTGNull ),
      PTGTime( MUL(THIS.Tramp1,1000.) ),
	  THIS.Srampi
	);
END;

SYMBOL Istart COMPUTE
  SYNT.PTG = PTGSpecd(PTGCurrent( MUL(THIS.Value,1000.) ));
END;
SYMBOL Istop COMPUTE
  SYNT.PTG = PTGSpecd(PTGCurrent( MUL(THIS.Value,1000.) ));
END;
SYMBOL PrepTime COMPUTE
  SYNT.PTG = PTGSpecd(PTGTime( MUL(THIS.Value,1000.) ));
END;

SYMBOL TzTime COMPUTE
  SYNT.PTG = PTGSpecd(PTGTime(
    MUL( CONSTITUENT Time.Value, 1000. )));
END;
RULE: SampleSpec ::= Integer 'Raw' 'Samples' COMPUTE
  SampleSpec.PTG = PTGSpecd(PTGTzSample( Integer, "Raw " ));
END;
RULE: SampleSpec ::= Integer 'Samples' COMPUTE
  SampleSpec.PTG = PTGSpecd(PTGTzSample( Integer, "" ));
END;
SYMBOL Percent COMPUTE
  SYNT.PTG = PTGSpecd(PTGPercent(MUL(THIS.Value,100.)));
END;
