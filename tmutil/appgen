#! /bin/sh
# appgen Application Generator for the
# tmc/cmdgen/tmcalgo/etc family of compilers
#__USAGE
#%C	[-s] [spec file]
#	-s Do not include subbus support by default
#
#	Generates an application based on the spec_file input
#	If spec file isn't specified, appgen will look for a
#	file of the form *.spec. If there is a unique one, it
#	will be used.
#	appgen automatically overwrites the Makefile, so care
#	should be taken that it is not invoked where it is not
#	used.
#
# Spec_file format:
# # comment line
# prefix = <prefix>  (optional: derived from spec file name)
# tmcbase = <files>
# cmdbase = <files>
# NOSUBBUS
# CLEANDIST - Flag to distribute into the bin hierarchy
# var = substitution (supported vars are SRC TOOL OBJ TGT DISTRIB
#                     SCRIPT (source to be copied to $TGTDIR/bin/$VERSION)
#                     SRCDIST (source to be copied to $TGTDIR/bin/$VERSION/Base)
#                     IDISTRIB (to be copied to $TGTDIR)
#                     MNC (defaults to prefix)
#                     HOMEDIR (defaults to cwd, less node)
#                     TGTNODE TGTDIR
#                     SERVER (defaults if server is generated)
#                     SUBDIRS (passed on to Makefile)
#                     SUBDIRS4 (passed on to Makefile)
#                     NONRCS (backed up as SOURCE, but not RCSed)
# target : <files>
# ...
# %%
# <additional Makefile contents>
#
# The following target types are supported:
#   *algo   TMCBASE  dc usage
#   *col    TMCBASE  dg usage privileged etc.
#   *ext    TMCBASE  dc usage
#   *disp   TMCBASE  dc usage
#   *dispnc TMCBASE  nctable usage
#   *clt    CMDBASE  client usage
#   *cltnc  CMDBASE  nctable client usage
#   *srvr   CMDBASE  privileged
#   *doit
#   *.dccc
#   *.sft
# The following source types are supported:
#   *.edf
#   *.cdf (same as .edf, but csv output)
#   *.cfg
#   *.tbl
#   *.tma
#   *.cyc
#   *.tmc
#	*.tmg
#   *.cmd
#   *.c
#   *.cc
#   *.slp (soldrv proxy) ==> .sol and something else
#   *.oui
#   *.doit
#   *.DR
function nl_error {
  echo appgen: $* >&2
  exit 1
}

typeset subbus=yes cleandist=yes
while getopts "s" option; do
  case $option in
	s) subbus=no;;
	\?) nl_error ;;
	*) nl_error Unsupported option: -$option;;
  esac
done
let sval=$OPTIND-1
shift $sval

typeset ifile
if [ -n "$1" ]; then
  if [ -r $1 ]; then ifile=$1
  else nl_error Cannot find or read input file $1
  fi
else
  for i in *.spec; do
    if [ -r $i ]; then
      if [ -n "$ifile" ]; then
	nl_error More than one .spec file found: *.spec
      else ifile=$i
      fi
    fi
  done
fi

[ -z "$ifile" ] && nl_error No .spec file specified and none found

#----------------------------------------------------------------
# Now redirect standard input and output to process the spec file
#----------------------------------------------------------------
exec <$ifile >Makefile

typeset targets prefix tmcbase cmdbase basetargets usage LINK usefiles
typeset colbase swsbase qclibase ouis
typeset SERVER
typeset SRC TOOL SCRIPT IDISTRIB OBJ TGT MNC HOMEDIR DISTRIB SRCDIST TGTNODE TGTDIR

# is_member setname member
function is_member {
  typeset i set
  eval set=\"\$$1\"
  if [ -n "$set" ]; then
    for i in $set; do
      if [ "$2" = "$i" ]; then return 0; fi
    done
  fi
  return 1
}

# add_member setname member
# returns true (0) if member was not in set
# returns false (1) if member was in set
function add_member {
  if is_member $1 $2; then
    return 1
  else
    eval $1=\"\$$1 \$2\";
  fi
  return 0
}

#----------------------------------------------------------------
# set_depname turns a filename into a shell variable name by mapping
# all [./] to _. If $kluge is the mapped name, n_$kluge is set to
# the actual filename and depname is set to d_$kluge. This is the
# name of the variable which will hold the dependents of this target.
#----------------------------------------------------------------
function set_depname {
  typeset old prefix suffix
  old=$1
  while :; do
    prefix=${old%%[./]*}
    if [ $old = $prefix ]; then break; fi
    eval suffix=\${old#$prefix[./]}
    old=${prefix}_$suffix
  done
  eval prefix=\"\$n_$old\"
  if [ -n "$prefix" ]; then
    [ $prefix != $1 ] &&
      nl_error Name kludge conflict between $1 and $prefix
  else
    eval n_$old=$1
  fi
  depname=d_$old
}

# in_this_dir file
# returns true (0) if file is in this directory
function in_this_dir {
  typeset bname
  case x$1 in
    x-l*) return 1;;
  esac
  bname=`basename $1`
  [ $bname = $1 ] && return 0
  return 1
}

# def_target target dependents
function def_target {
  typeset tgt deps dtdeps
  tgt=$1; shift
  deps="$*"
  in_this_dir $tgt ||
    nl_error Target $tgt is in another directory.
  is_member SRC $tgt &&
    nl_error Target $tgt conflicts with previous source definition
  if add_member targets $tgt; then
    [ -n "$basetargets" ] && OBJ="$OBJ $tgt"
    set_depname $tgt
    eval $depname=\"\$deps\"
  else
    set_depname $tgt
    eval dtdeps=\"\$$depname\"
    if [ "$dtdeps" != "$deps" ]; then
      echo Dependencies for target $tgt conflict with previous definition >&2
      echo First: \"$dtdeps\" >&2
      echo Second: \"$deps\" >&2
      exit 1
    fi
  fi
}

function def_source {
  is_member targets $1 &&
    nl_error Source File $1 previously identified as target.
  in_this_dir $1 && add_member SRC $1
  case $1 in
    *.tbl) add_member SRCDIST $1;;
    *.tma) add_member SRCDIST $1;;
    *.sol) add_member SRCDIST $1;;
  esac
}

add_member IDISTRIB Experiment.config
add_member IDISTRIB VERSION

#----------------------------------------------------------------
# This is where we read in the definitions
#----------------------------------------------------------------
while read tgt mode deps; do
  case "$tgt" in
    \#*) mode=#;;
    NOSUBBUS) subbus=no; mode="";;
    CLEANDIST) cleandist=yes; mode="";;
    swsbase)
      for i in $deps; do
        add_member tmcbase SWData.tmc
        add_member tmcbase SWData.h
        add_member colbase SWData_col.tmc
        add_member cmdbase SWData.cmd
      done;;
    qclibase)
      for i in $deps; do
        j=${i%.qcli}
        add_member tmcbase $j.tmc
        add_member cmdbase $j.cmd
        add_member DISTRIB $j.out
        add_member SRCDIST $j.m $j.qcli
        add_member OBJ $j.cmd
        add_member OBJ $j.out
        add_member OBJ $j.tmc
        add_member OBJ $j.m
        add_member OBJ $j.log
      done;;
    %%) break;;
  esac
  if [ -n "$mode" ]; then
    case "$mode" in
      \#) : ;;
      =) for i in $deps; do add_member $tgt $i; done;;
      :) case $tgt in
	   *algo) deps="$tmcbase $deps";;
	   *col) deps="$tmcbase $colbase $deps";;
	   *ext) deps="$tmcbase $deps";;
	   *disp) deps="$tmcbase $deps";;
	   *dispnc) deps="$tmcbase $deps";;
	   *clt) deps="$cmdbase $deps";;
	   *cltnc) deps="$cmdbase $deps";;
	   *srvr) deps="$cmdbase $deps"; SERVER=$tgt;;
	   *doit) : ;;
	   *.dccc) : ;;
	   *.sft) : ;;
	   *) : ;;
	 esac
	 for i in $deps; do
	   def_source $i
	 done
	 def_target $tgt $deps
	 case $tgt in
	   *disp) def_target ${tgt}nc $deps;;
	   *clt) def_target ${tgt}nc $deps;;
	 esac;;
      *) echo Unknown mode $mode >&2 ;;
    esac
  fi
done

#----------------------------------------------------------------
# If not otherwise defined, the following targets are implicit,
# assuming appropriate source files are supplied in the BASE
# definition
#  ${prefix}clt
#  ${prefix}srvr
#----------------------------------------------------------------
if [ -z "$prefix" ]; then prefix=${ifile%%.*}; fi
if [ -n "$tmcbase" ]; then
  for i in $tmcbase; do add_member SRCDIST $i; done
fi

if [ -n "$cmdbase" ]; then
  is_member targets ${prefix}clt || {
    def_target ${prefix}clt $cmdbase
    def_target ${prefix}cltnc $cmdbase
    for i in $cmdbase; do def_source $i; done
  }
  is_member targets ${prefix}srvr || {
    def_target ${prefix}srvr $cmdbase
    if [ -z "$SERVER" ]; then SERVER=${prefix}srvr; fi
    for i in $cmdbase; do def_source $i; done
  }
fi

if [ -n "$colbase" ]; then
  is_member targets ${prefix}col || {
    def_target ${prefix}col $tmcbase $colbase
    for i in $colbase; do def_source $i; done
  }
fi

#----------------------------------------------------------------
# replace_each from to rule dependents
#   Processes the list of dependents, replacing any ending in
#	the "from" pattern with a new dependent ending in the "to"
#	pattern. Adds the new dependent as a target in its own right
#	with the old dependent as a dependent.
#   Rules starting with '-' are omitted unless the source is in
#   a different directory.
# Returns TRUE if the substitution was applied
#----------------------------------------------------------------
function replace_each {
  typeset from to redeps rei ia new_i replaced hdeps

  replaced=1
  from=$1; to=$2; rule="$3"; shift; shift; shift
  if [ "$1" = "-h" ]; then
    hdeps=$2
    shift; shift
  fi
  for rei in $*; do
    ia=${rei%$from}
    if [ $ia$from = $rei ]; then
      new_i=${ia##*/}$to
      irule=${rule#-}
      if [ "$irule" != "$rule" -a "$new_i" = "$ia$to" ]; then
        irule=""
      fi
      if [ -n "$irule" ]; then
        rei="$rei$hdeps\n\t$irule $rei"
      else
        rei="$rei$hdeps"
      fi
      def_target $new_i " $rei"
      rei=$new_i
      replaced=0
    fi
    redeps="$redeps $rei"
  done
  deps="$redeps"
  return $replaced
}

#----------------------------------------------------------------
# replace_all from to rule dependents
#  replace all files ending in the "from" pattern with a file
#  of the name "to", suffixing the rule to the dependents list
# Returns TRUE if the substitution was applied.
# Redefines global variable deps
#----------------------------------------------------------------
function replace_all {
  typeset from to rule rai ia ra_deps new_deps replaced
  
  replaced=1
  from=$1; to=$2; rule="$3"; shift; shift; shift
  for rai in $*; do
    ia=${rai%$from}
    if [ $ia$from = $rai ]; then
      if [ -z "$ra_deps" ]; then
	new_deps="$new_deps $to"
      fi
      ra_deps="$ra_deps $rai"
    else
      new_deps="$new_deps $rai"
    fi
  done
  if [ -n "$ra_deps" ]; then
    def_target $to "$ra_deps$rule$ra_deps"
    replaced=0
  fi
  deps=$new_deps
  return $replaced
}

#----------------------------------------------------------------
# use_all from to rule dependents
#  use all files ending in the "from" pattern to generate file
#  of the name "to", suffixing the rule to the dependents list
#  in the global variable 'deps'
# Returns TRUE if the substitution was applied.
#----------------------------------------------------------------
function use_all {
  typeset from to rule rai ia ra_deps replaced
  
  replaced=1
  from=$1; to=$2; rule="$3"; shift 3
  for rai in $*; do
    ia=${rai%$from}
    [ $ia$from = $rai ] && ra_deps="$ra_deps $rai"
  done
  if [ -n "$ra_deps" ]; then
    def_target $to "$ra_deps$rule$ra_deps"
    replaced=0
    deps="$deps $to"
  fi
  return $replaced
}

#----------------------------------------------------------------
# Now process the definitions:
#  save the original targets in basetargets
#----------------------------------------------------------------
basetargets="$targets"

for i in $basetargets; do
  unset ouis
  ltmpp='' # will become ' -ltmpp'
  ltmph='' # will become ' -ltmph -lph'
  ldisp='' # will become ' -ldisp -ltmph -lph' or nc equiv
  lssp='' # will become ' -lssp -lmem -lm'
  cxx=''
  add_member TGT $i
  set_depname $i
  eval deps=\"\$$depname\"
  use_all .edf ${i}edf.oui "\n\t\$(EDF2OUI)" $deps
  replace_each .edf ext.tmc "\$(EDF2EXT)" $deps &&
    lssp=' -lssp -lmem -lm'
  use_all .cdf ${i}cdf.oui "\n\t\$(EDF2OUI)" $deps
  replace_each .cdf ext.tmc "\$(EDF2EXT)" $deps
  # replace_each .cfg attr.tmc "\$(DATAATTR)" $deps
  replace_each .cyc cyc.tmc  "\$(CYCLE)" $deps
  case $i in
    *disp)
      # Go for the implicit rule
      replace_each .tbl tbl.tmc "" $deps &&
	ldisp=' -ldisp -ltmph -lph';;
    *dispnc)
      replace_each .tbl tblnc.tmc "" $deps &&
	ldisp=' -ldispnc -ltmnc -lncurses' &&
	add_member ouis nctable;;
    *algo)
      replace_each .sws sws.tma "\$(COMPILE.sws)" $deps;;
  esac
  replace_all .tmg ${i}tmg.tmc "\n\t\$(TMG2TMC)" $deps &&
	add_member ouis tmg
  replace_each .DR ${i}DR.tmc 'DR2tmc >$@' $deps &&
	add_member ouis drext
  if replace_all .tma ${i}a.tmc " $SERVER\n\t\$(SERVER) ./$SERVER\n\t\$(TMCALGO) -V \"\`./$SERVER -R\`\"" $deps
  then
    [ -z "$SERVER" ] &&
      nl_error No command server defined
    add_member ouis tma
  fi
  case $i in
    *col)
      if replace_all .tmc $i.cc "\n\t\$(TMC.col)" $deps; then
	add_member ouis collect
	add_member ouis seteuid
	# [ "$subbus" = "yes" ] && add_member ouis subbus_reqd
	add_member DISTRIB ${i%col}.pcm
	add_member DISTRIB tm.dac
	add_member OBJ ${i%col}.pcm
	add_member OBJ tm.dac
	ltmpp=' -ltmpp'
      fi;;
    *)
      replace_all .tmc $i.cc "\n\t\$(TMC)" $deps &&
	add_member ouis dc && ltmpp=' -ltmpp';;
  esac
  case $i in
    *sft)
      replace_each .slp slp.sol "\$(SLP2SOL)" $deps;;
    *)
      replace_all .slp ${prefix}slp.cmd "\n\t\$(SLP2CMD)" $deps;;
  esac
  if replace_all .cmd ${prefix}cmd.cc "\n\t\$(CMDGEN) -d ${prefix}cmd.dat" $deps
  then
    add_member OBJ ${prefix}cmd.dat
  fi
  case $i in
    *clt)
      if replace_all cmd.cc $i.o "\n\t\$(COMPILE.clt)" $deps; then
	add_member ouis kbdclt
	ltmph=' -ltmph -lph'
	ltmpp=' -ltmpp'
      else
	nl_error Client $i with no cmd.cc files
      fi;;
    *cltnc)
      if replace_all cmd.cc $i.o "\n\t\$(COMPILE.cltnc)" $deps; then
	add_member ouis kbdclt
	add_member ouis nctable
	ltmph=' -ltmnc -lncurses'
	ltmpp=' -ltmpp'
      else
	nl_error Client $i with no cmd.cc files
      fi;;
    *srvr)
      if replace_all cmd.cc $i.o "\n\t\$(COMPILE.srvr)" $deps
      then
	add_member ouis cis
	add_member ouis seteuid
	ltmpp=' -ltmpp'
	# [ "$subbus" = "yes" ] && add_member ouis subbus_opt
      else
	nl_error Server $i with no cmd.cc files
      fi;;
  esac
  is_member deps -lsubbus && add_member ouis subbus

  #----------------------------------------------------------------
  # We'll delay handling the rest of the .c files (and the .oui files)
  # until we decide if these are really executable.
  #----------------------------------------------------------------

  unset LINK
  case $i in
    *col)   LINK=priv;;
    *clt)   LINK=norm; cxx=CXX;;
    *cltnc) LINK=norm; cxx=CXX;;
    *srvr)  LINK=priv; cxx=CXX;;
    *.dccc) por="\$(LIBSRC)/dccc.por"
	    deps="$deps $por\n\t@\$(DCCC)$deps";;
    *.sft)  set -- $deps
	    if [ $# -gt 1 ]; then
	      deps="$deps\n\t\$(SOLFMT) $deps"
	    else
	      deps="$deps\n\tsolfmt -o$i $deps"
	    fi;;
    *doit)  def_target $i.dep "$deps\n\tmkdoit3 -M -o $i $deps\n-include $i.dep"
	    deps="$deps\n\tmkdoit3 -o $i $deps"
	    add_member IDISTRIB $i;;
    *doit.dep)
	    deps="$deps\n\tmkdoit3 -M -o ${i%.dep} $deps\ninclude $i";;
    *)      LINK=norm;;
  esac

  if [ -n "$LINK" ]; then
    unset ouifiles ouiout hdeps cdeps
    add_member ouis msg
    for j in $ouis; do
      ouifiles="$ouifiles \$(OUIDIR)/$j.oui"
    done
    deps="$deps$ouifiles"
    replace_all .oui ${i}oui.c "\n\t\$(OUI)" $deps &&
      ouiout=${i}oui.c
    for dep in $deps; do
      case "x$dep" in
        x-l*) cdeps="$cdeps $dep";;
        *.o) cdeps="$cdeps $dep";;
        *.c) cdeps="$cdeps $dep";;
        *.cc) cdeps="$cdeps $dep";;
        *.h) hdeps="$hdeps $dep";;
	*) nl_error Unrecognized dependent $dep;;
      esac
    done
    deps=$cdeps
    replace_each .c .o "-\$(COMPILE.c)" -h "$hdeps" $deps
    replace_each .cc .o "-\$(COMPILE.cc)" -h "$hdeps" $deps && cxx=CXX
    unset libs odeps
    for dep in $deps; do
      case "x$dep" in
	x-l*) libs="$libs $dep";;
	*.o) odeps="$odeps $dep";;
	*.h) :;;
	*) nl_error Unrecognized dependent $dep;;
      esac
    done
    deps="$odeps\n\t\$(LINK.$LINK$cxx)$odeps$libs$ldisp$ltmph$ltmpp -ltm$lssp -lnort"
    [ -n "$ouiout" ] &&	deps="$deps\n\t\$(OUIUSE) $ouiout"
    case $LINK in
      priv*) deps="$deps\n\t\$(PROMOTE) $i";;
    esac
  fi

  set_depname $i
  eval $depname=\"\$deps\"
done

#----------------------------------------------------------------
# Clean up a little
#----------------------------------------------------------------
unset -f replace_each replace_all

# output_macro name definition
# outputs name=definition, but adds continuation characters
# to make it look nice (eventually)
function output_macro {
  typeset name i line
  name=$1; shift
  echo -n "$name="
  width=${#name}+1
  for i in $*; do
    let width=$width+${#i}+1
    if [ $width -ge 70 ]; then
      echo -n "$line\n$name+="
      width=${#name}+2+${#i}
      line=$i
    elif [ -n "$line" ]; then line="$line $i"
    else line="$i"
    fi
  done
  echo "$line"
}

#----------------------------------------------------------------
# Add a few more.
#----------------------------------------------------------------
add_member TOOL $ifile
add_member TOOL Makefile
directory=$PWD
case $directory in
  //*/*) directory=/${PWD#//*/};;
esac

#----------------------------------------------------------------
# Output the results
#----------------------------------------------------------------
echo "# Makefile Generated `date`"
output_macro MNC ${MNC:-$prefix}
output_macro HOMEDIR ${HOMEDIR:-$directory}
if [ -n "$SUBDIRS" ]; then
  output_macro SUBDIRS $SUBDIRS
fi
if [ -n "$SUBDIRS4" ]; then
  output_macro SUBDIRS4 $SUBDIRS4
fi
echo SPECFILE=$ifile
output_macro SRC $SRC
output_macro TOOL $TOOL
output_macro SCRIPT $SCRIPT
output_macro OBJ $OBJ
output_macro TGT $TGT
output_macro DISTRIB $DISTRIB
output_macro IDISTRIB $IDISTRIB
output_macro SRCDIST $SRCDIST
output_macro NONRCS $NONRCS
output_macro TMCBASE $tmcbase
output_macro CMDBASE $cmdbase
output_macro COLBASE $colbase
output_macro SWSBASE $swsbase
output_macro QCLIBASE $qclibase
echo 'RCS=$(SRC) $(TOOL) $(SCRIPT)'
echo 'SOURCE=$(RCS) $(NONRCS)'
echo 'OBJECT=$(OBJ) *.err'
echo 'TARGET=$(TGT)'
echo 'DSTRB=$(TGT) $(DISTRIB) $(SCRIPT)'

# Output selected macros if they have been defined
if [ -n "$TGTNODE" ]; then echo TGTNODE=$TGTNODE; fi
if [ -n "$TGTDIR" ]; then
  echo TGTDIR=$TGTDIR
else
  nl_error "TGTDIR definition is required"
fi

echo 'include /usr/local/share/huarp/appgen.mk'
echo
echo 'all : Makefile $(TGT) .cvsignore'
echo "Makefile : $ifile"
echo "\tappgen $ifile"
  # This was the cleandist option. No longer optional
  echo 'VERSION=`cat VERSION`'
  echo 'extdistribution : $(DSTRB) $(SRCDIST) VERSION'
  echo "\t@[ -d \$(TGTDIR)/bin ] || mkdir \$(TGTDIR)/bin"
  echo "\t@[ -d \$(TGTDIR)/bin/\$(VERSION) ] || mkdir \$(TGTDIR)/bin/\$(VERSION)"
  echo "\t@[ -d  \$(TGTDIR)/bin/\$(VERSION)/Base ] || mkdir \$(TGTDIR)/bin/\$(VERSION)/Base"
  echo "\t@distribute \$(FORCE) \$(TGTDIR)/bin/\$(VERSION) \$(DSTRB)"
  echo "\t@distribute \$(FORCE) \$(TGTDIR)/bin/\$(VERSION)/Base \$(SRCDIST)"
  echo 'distribution : extdistribution'
  echo "\t@distribute \$(FORCE) \$(TGTDIR) \$(IDISTRIB)"

for i in $targets; do
  set_depname $i
  eval deps=\"\$$depname\"
  echo "$i :$deps"
done

if [ -n "$swsbase" ]; then
  echo "SWData.h SWData.tmc SWData_col.tmc SWData.cmd : $swsbase"
  echo "\tswscomp -o SWData $swsbase"
fi

if [ -n "$qclibase" ]; then
  for i in $qclibase; do
    j=${i%.qcli}
    echo "$j.cmd $j.out $j.tmc $j.m : $i"
    echo "\tqclicomp -o $j.out -c $j.cmd -d $j.tmc \\"
    echo "\t  -v $j.log -m $j.m $i || \\"
    echo "\t  ( rm -f $j.out $j.cmd $j.tmc $j.log $j.m; false )"
  done  
fi

echo "\ntidy :\n\trm -f \$(OBJECT)"
echo "clean : tidy\n\trm -f \$(TARGET)"
echo ".cvsignore : Makefile"
echo "\t@for i in \$(OBJECT) \$(TARGET); do echo \"\$\$i\"; done >.cvsignore"

# Output anything beyond the %% in the spec file
cat
#while read i; do
#  echo "$i"
#done
exit 0

