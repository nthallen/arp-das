Look Ahead? {
  I through out look-ahead from the beginning, believing that it 
  was incompatibile with an interactive parser, but I think that 
  was probably an overreaction. Clearly I cannot look ahead when 
  a carriage return is encountered: that's the time to act, but 
  many syntaxes would be well served if I could look ahead a bit. 
  How difficult would that be? Need to separate the shift and 
  reduce operations. Obviously it would make sense to reduce 
  immediately if look-ahead is not required.
}
Skeleton {
  6/4/96 Updated skeleton because I was mishandling the value 
  stack, causing erroneous values under some constructs. I am 
  still unhappy about how the valpos is handled on the stack.
  I would like to further modify the skeleton when time allows to 
  shift first (storing the current vsp in valpos) and then 
  increment vsp if a value was used. This would require mods to 
  the P() and possible PP() macros as well as the full_reduce 
  section of the code.
}
History Implementation {
  To implement history, I believe I must do the following:
  Augment the GETCH() function (nlcon_getch()) to call a special 
  function when special scan codes are received. That function 
  would accept up and down and call cmd_init() and cmd_batch()
  and return 0 (which lets the routines percolate up to the top 
  to accept interactive input again) iomode should be saved 
  across the call to cmd_init() (Alternatively, check to see if 
  that initialization can be moved out of cmd_init() entirely.)
  Upon execution, clients would have to store command text along 
  with the context in which they were executed (? or would I just 
  scroll back through different contexts? That would be confusing 
  no doubt. Perhaps it could be an option)
  
  cic_transmit() is a good place to record history, since that is 
  where I keep track of state, etc.
}
Command Server {
  Decide on option letters to be compatible with existing set
  Uses cmd_batch() exclusively: i.e. CMD_BATCH_MODE but not
  CMD_INTERACT_MODE.
  API {
	cic_options(argc, argv, def_prefix);
	  locate server, verify version
	  prefix is truncated to 8 chars.
	  options {
		-C <node> specify node (default to local then global search)
		-h <header> replace default prefix (multiple algos)
	  }
	char ci_version[];
	  generated by cmdgen or defaulted from library to ""
	int ci_sendcmd(char *cmdtext, int test);
	  case return value:
		0         return 0
		1000      return 1000
		2000-2999 if nl_response, nl_error(syntax error) return value
		3000-     if nl_response, nl_error(1, "execution error") rv
		else      if nl_response, nl_error(nl_response, "unexpected") rv
  }
  Message Interface {
	query for version
	send command with prefix {
	  struct {
		unsigned char msg_type;
		char[9] prefix;
		char[MAXCMD] command;
	  }
	  prefix and command are both null-terminated
	}
  }
  cmdgen mods {
	Bracket actions of "client" non-terminals with:
	#ifdef CLIENT_ACTIONS
	  if (ioflags & IOF_EXECUTE)
	  { action }
	#endif
	
	Bracket all other actions with
	#ifdef SERVER_ACTIONS
	  if (ioflags & IOF_EXECUTE)
	  { action }
	#else
	  saw_server_action = 1;
	#endif
  }
}
New API: save this info for documentation {
  Working in cmdgen.skel {
	Trying to work out syntax error handling in batch mode
	For SNAFU, REJECT_CHAR can be a function call which is
	context-sensitive and reports an error in batch mode,
	but only beeps in interactive mode. (SNAFU will run
	without CMD_BATCH_MODE defined).
  }

  Two basic modes of operation: interactive and batch
  Interactive mode requires backtracking
  batch processing requires maintenance of an input buffer.
  The two are not always mutually exclusive. An interactive
  operation would benefit from history capabilities.

  cmd_init(void); {
	NOT: Performs device-specific initialization once as necessary
	Initializes all stacks to starting modes.
  }
  cmd_report(cmd_state *s); {
	Stores the current command state in the designated structure
  }
  int cmd_check(cmd_state *s); {
	Compares the current command state to the designated structure
	returning zero if the states match.
  }
  Interactive operation {
	cmd_interact() {
	  calls cmd_init();
	  reads commands.
	  Doesn't return until quit. Could call a batch mode
	  routine recursively if defined.
	}
  }
  Batch operation {
	cmd_batch(char *cmd, int test); {
	  Parses the specified command, executing if test == 0.
	  Returns non-zero if an error occurred. Possible errors:
	   1000 Command execution resulted in termination
		    (not exactly an error: more a status indication)
	   2000-2999 Syntax error. Error value minus 1000 is the
			character position where the error occurred.
	  >3000 Execution error. Error code + 3000
	}
  }
  Grouping of capabilities: {
	Remote keyboard program without execute: {
	  interactive (and batch if history is supported)
	  replace command invocations with send commands
	  ?How to determine which need to be sent? {
		Must designate somehow which are local and
		which are remote. Input mode is local, for example.
		Some are purely interpretive, and should be omitted
		when operating remotely...
		Add attribute to non-terminals; Local, Interp or
		default to "active". When compiling a "remote"
		keyboard program, execute only Local actions,
		and transmit active actions, ignoring Interps.
		When compiling a "local" command program, execute
		all actions.
	  }
	}
	Batch processing {
	  Batch interface only (don't link in keyboard access stuff)
	  Don't need prompts
	}
	SNAFU {
	  Interactive only (batch already taken care of)
	}
  }
  input() decides whether to get chars from batch or command_getch()
  command_getch() updates output and calls GETCH(), packing special
	characters as necessary. called only once by input()
  GETCH() implementation-specific macro to get a character
}
Add usage and command line options to cmdgen
Mods for handling flight algorithms {
  Stack and unshift value pretty much define state. read_var and
  read_words should return when no more input is available
  (say input() == 0) and set unshift_val. As such, read_words must
  modify its entry behaviour to retreat only at the very end of
  a word.

  Break command() into command_init() and command_exec(char *cmd);  
  command_init() just does the basic initialization. command_exec(NULL)
  takes input from the keyboard, command_exec(cmd) reads from the
  string. command_exec(NULL) could call command_exec(cmd) (in order to
  implement history), but further nesting doesn't make sense.
  command_exec(char *cmd) returns when no more input is available
  or rule 0 reduced, in which case a non-zero value is returned.
  In interactive modes, command_exec() would only return after rule
  zero reduction.
  { algo.y
mode 
	: KW_MODE TK_STRING '{' tcommands '}'
	;
tcommands
	:
	: tcommands time TK_COMMAND
	;
time
	: { continue immediately }
	: timegrp { Wait until absolute time }
	: '+' timegrp { Wait until relative time }
	;
timegrp
	: TK_INT { $$ = $1; }
	: timegrp ':' TK_INT { $$ = $1 * 60 + $3; }
	;

Mode return(KW_MODE);
[0-9]+ return(TK_INT);
>.* return(TK_COMMAND);
[a-z_]+ return(TK_STRING);
#.*
//.*
. return(.);

program structure: since we're receiving TM to get time, we must 
fit into the DC_operate format, which means we will be acting
during DC_data calls (and ultimately TMC actions). The reasonable
thing to do is to tie basic timing to MFCtr: specifically using
itime(). When a mode begins, record the start as t0=itime();
t records the time of the next command. New times read from
the algorithm are added to t0 (or to t if '+' is used). When
itime >= t, the commands are executed and a new time is read.

new_mode(char *name) {
  <locate mode and seek to it>
  t = t0 = itime();
  check_mode();
}
check_mode() {
  if (itime() >= t) {
	<execute commands until time or RBRACE is read>
  }
}
  }
}
Special Parser {
  Interactive command parsing requires a slightly different approach
  than standard language parsing. The standard LR(1) parsers don't do
  anything until looking at the next token, even if the next token
  is irrelevant. An LR(0) parser would resolve this problem, but it
  would restrict the types of grammers which could be supported. In
  particular, we couldn't have arithmetic expressions, since these
  clearly require look ahead (a+b.*c).
  
  Of course supporting arithmetic expressions has other implications.
  My current approach includes context-sensitive lexical analysis.
  Supporting arithmetic expressions requires a more robust lexical
  analysis. At the moment I support either numbers or keywords, but
  not both. For arithmetic, I would have to accept either or both.
  
  For now, I will pursue LR(0) parsing. This allows two possible
  actions on seeing a token: shift or shift_reduce.
  
  An interactive LR(1) approach would require three actions:
  shift, reduce and shift_reduce. shift_reduce is mandated
  whenever reducing triggers an action there are no conflicts.
}
Generation {
  state {
    type of terminals
    list of rules in rule number, position order {
	  rules/position
	  struct sub_item_t *si;
	}
	default action
	list of terminals in alpha order {
	  char *text;
	  action
	}
	list of non_terminals in numerical order {
	  unsigned short nt_number;
	  action
	}
  }
  A state is defined by a list of expansion rules and the position
  within those rules. What's important about this list is what's
  up next. There are three possibilities: Terminal, Variable or
  Non-Terminal.
  Some legalities {
	If a variable is in the set, no terminals may be in the set.
	At most one variable may be in the set. (Two variables of
	the same kind could be tolerated, although the prompts
	might be different...)
  }
  Sort this list of rules into terminals and non-terminals.
  Expand each non-terminal using all the substitutions for that
  non-terminal, taking care not to duplicate any rule/position
  already listed. {
	Let a state be defined with a data structure containing two
	linked-lists: one for terminals and one for non-terminals.
	As each rule is added to the state, check the appropriate list
	for duplication, then add the new rule to the end of the list
	if new. Step through the list of non-terminals adding expansions.
  }
  Once fully expanded, check legalities and sort terminals alphabetically.
  LR(0) is it.
}
Output {
  rules {
	Number of components (sub-items)
	Code
  }
  states {
	action {
	  Reduction {
		which rule
	  }
	  Terminals {
		Prompts
		Variables {
		  word or line
		  conversion function
		}
		Words {
		  Offset into grand trie
		}
	  }
	}
	list of terminals and succeeding states {
	  (or just a list of state numbers!)
	}
	list of non-terminals and succeeding states
	A state may either have an instant reduction or terminals, not both.
	Reduction must specify by which rule. If there are terminals, there
	are prompts. Variables are defined by a flag indicating whether a
	word or line is required and a pointer to an appropriate conversion
	function. Word terminals require only a pointer into the grand trie.
	struct {
	  unsigned char flag;
	  rule_type reduction;
	  unsigned short trie_offset;
	  unsigned int term_offset;
	  unsigned short nterm_offset;
	} states[];
  }
  Main Stack {
	Current State
	reference to previous stack position
	reference to value stack position
	Flag: { Terminal or NT }
	unsigned short {
	  For variables n_chars
	  For Words offset into grand trie
	  Rule number for NTs
	}
	struct {
	  state_type state;
	  unsigned char prev;
	  unsigned char non_term;
	  token_type value;
	}
  }
  Value Stack {
	union of all types used possibly including: {
	  int for %d, %x, %o
	  long int for %ld, %lx, %lo
	  float for %f
	  double for %lf
	  const char * for %s and %w
	}
  }
  Grand trie {
	#define T_FLAG 0x80
	#define T_ROOT 1
	#define T_CHAR(i) (trie[i].code&0x7F)
	#define T_MATCH(i,c) (tolower(c)==tolower(T_CHAR(i)))
	typedef unsigned char token_type;
	struct {
	  unsigned char code;
	  cg_token_type next;
	  cg_token_type prev;
	} trie[];
	code T_ROOT indicates the beginning of a trie.
	Each node consists of a list of characters to match with the
	last in the list ORed with T_ROOT (e.g. node('z')). If a
	match is found at position i (i.e. T_MATCH(i,c))
	the character is accepted and the position is advanced by
	the offest recorded in the next member
	 (i.e. i += trie[i].next;)
	For backtracking (i.e. when a backspace has been entered)
	the previous position can be found by subtracting the
	previous offset
	 (i.e. i -= trie[i].prev;)
	Needless to say, one does not backtrack beyond the T_ROOT
	code.
  }
}
Data structures summary {
	
1. Define state_type and token_type
	/* token_type is unsigned and large enough to enumerate tokens and states */
	typedef ? token_type; cmdgen.c
1.1 Define nonterm_type big enough to enumerate non_terminals. cmdgen.c
3. Generate VAR_* #defines and VTP_* #defines (see vunion.c)
   and Define value stack union vstack_type
	typedef union {
	} vstack_type;
2. Include typedef skeleton
	#define T_ROOT 0x80
	#define node(x) (x|T_ROOT)
	#define T_TERM node(1)
	type struct {
	  unsigned char code;
	  token_type next;
	  token_type prev;
	} trie_type;
	type struct {
	  unsigned char n_elts;
	  unsigned char reduce; /* non-zero if a full reduction reqd */
	  void (* action)(void);
	} rule_type;
	typedef struct {
	  int more;
	  char *text;
	} prompt_type;
	#define STFL_REDUCE 1
	#define STFL_VARIABLE 2
	#define STFL_WORD 4
	typedef struct {
	  unsigned char flag;
	  unsigned short offset; /* offset in rules[], vardef[] or trie[] */
	  short prompt; /* offset in prompts[] or -1 */
	  unsigned short term_offset; /* offset in terminals[] */
	  unsigned short nterm_offset; /* offset in non_terminals[] */
	} state_type;
	/* prev member is non-negative if we left the specified state via
	   a non-terminal. If so, it gives the tstack position of the
	   previous element on the stack. If prev is negative, we left the
	   specified state via a terminal and the previous state is
	   the previous position on the stack (offset -1). Information
	   about what kind of terminal it was is available in the
	   state description. If prev is non-negative (non-terminal),
	   value is the rule number which was reduced. If prev is
	   zero, then the state definition tells us whether the
	   terminal was a word or variable. If it is a variable,
	   value is the number of characters. If it is a word,
	   value is the final position in the grand trie.
	*/
	struct {
	  state_type state;
	  short prev;
	  unsigned char valpos;
	  unsigned short value;
	} tstack[TSTACK_SIZE];
	extern vstack_type vstack[];
4. Generate trie, storing starting offsets in each state
	trie_type trie[];
5. Generate rule functions and rules array
	static void rule_00(void) $action$
	(actions require $$ substitutions) {
	  tstack[tsp] is top of the stack (empty).
	  vstack[vsp] is top of the value stack (empty).
	  $$ == vstack[vsp];
	  #define V(x) vstack[x.valpos]
	  #define T(x,y) tstack[y-x]
	  #define P(x,y) tstack[T(x,y).prev]
	  Last element in rule is tstack[tsp-1]  T(1,tsp)
	  Value associate is vstack[tstack[tsp-1].valpos] V(T(1,tsp))
	  If tstack[tsp-1] is terminal, next last is
	  tstack[tstack[tsp-1].prev] P(1,tsp)
	  Value associated is V(P(1,tsp))
	  This is too compute-intensive: redefine .prev ###
	}
	
	rule_type rules[];
	
6. Define prompts for each state
	prompt_type prompts[];

7. Define terminals[] and non_terminals[]
	/* *terminals hold states to which to shift */
	shift_type non_terminals[] {}

8. Define states
	state_type states[] = {
	}

10. Include the second skeleton file.
	/* The following can all appear in the skeleton file: */
	
	#ifdef VAR_d
	  void var_d_func(char *text) {
		vstack[vsp].VTP_SHRT = atoi(text);
	  }
	#endif
	/* conversion functions fill in the appropriate member of the top of
	   the value stack. */
	struct {
	  unsigned char whole line;
	  void (* cnv_func)(char *str);
	} vardef[] = {
		0, NULL
	  #ifdef VAR_d
		, 0, var_d_func
	  #endif
	  #ifdef VAR_ld
		, 0, var_ld_func
	  #endif
	}
	
	vstack_type vstack[VSTACK_SIZE];
}
